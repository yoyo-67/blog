---
title: "Lesson 1: Why x86 Assembly?"
weight: 1
---

# Lesson 1: Why x86 Assembly?

Before we start generating assembly, let's understand what we're building and why direct x86 output is valuable for learning.

**What you'll learn:**
- What "native code" really means
- Trade-offs between x86, LLVM, and C backends
- AT&T vs Intel syntax choice
- Which architectures work on which operating systems

---

## Sub-lesson 1.1: What is Native Code?

### The Problem

When your program runs, the CPU doesn't execute your source code. It doesn't even execute C or LLVM IR. It executes **machine code**: raw bytes that encode specific CPU instructions.

```
Your source:    return a + b;
Machine code:   89 f8 01 f0 c3    ← This is what the CPU actually runs
```

Those bytes (`89 f8 01 f0 c3`) are hard for humans to read. So we use **assembly language** as a human-readable representation:

```asm
movl    %edi, %eax    # 89 f8 - copy first parameter to result register
addl    %esi, %eax    # 01 f0 - add second parameter
ret                    # c3    - return to caller
```

### The Solution

We'll generate assembly text files that an **assembler** (like `as` or `nasm`) converts to machine code:

```
┌─────────────────────────────────────────────────────────────────────┐
│ FROM SOURCE TO MACHINE CODE                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   fn add(a, b) { return a + b; }                                   │
│            │                                                        │
│            ▼                                                        │
│   ┌─────────────────┐                                              │
│   │   Our Compiler  │  (what we're building)                       │
│   └────────┬────────┘                                              │
│            │                                                        │
│            ▼                                                        │
│   movl %edi, %eax       ← Assembly text (human-readable)           │
│   addl %esi, %eax                                                  │
│   ret                                                               │
│            │                                                        │
│            ▼                                                        │
│   ┌─────────────────┐                                              │
│   │   Assembler     │  (as, nasm, etc.)                            │
│   └────────┬────────┘                                              │
│            │                                                        │
│            ▼                                                        │
│   89 f8 01 f0 c3        ← Machine code (what CPU runs)             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**Key insight**: We generate text (assembly), not binary. This keeps our code simple and our output debuggable.

---

## Sub-lesson 1.2: Why Not Just Use LLVM?

### The Problem

LLVM is an industrial-strength compiler infrastructure used by Clang, Rust, and Swift. Why would we write our own x86 backend instead of using LLVM?

### The Trade-offs

| Aspect | LLVM Backend | Direct x86 |
|--------|--------------|------------|
| **Setup** | Install LLVM (100MB+) | Just need `as` (already installed) |
| **Complexity** | Learn LLVM IR + API | Learn x86 directly |
| **Optimization** | Excellent (-O2, -O3) | None (what you emit is what runs) |
| **Portability** | x86, ARM, WASM, RISC-V | x86-64 only |
| **Learning value** | Abstracts the machine | See exactly what CPU executes |
| **Debug output** | LLVM IR (another layer) | Assembly (the actual thing) |

### The Solution: Choose Based on Goals

**Use LLVM when:**
- Building a production compiler
- Need optimization passes
- Targeting multiple architectures

**Use direct x86 when:**
- Learning how compilers work
- Understanding the CPU's perspective
- Building a minimal, self-contained compiler
- Educational or hobby projects

For this tutorial, we choose **direct x86** because the goal is to understand what happens between your code and the CPU.

```
┌─────────────────────────────────────────────────────────────────────┐
│ LEARNING VALUE: SEEING THE WHOLE PICTURE                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ With LLVM:                                                          │
│   Your code → LLVM IR → ??? (magic) → executable                   │
│                                                                     │
│ With direct x86:                                                    │
│   Your code → x86 assembly → (simple step) → executable            │
│                              ↑                                      │
│                        You understand this!                         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Sub-lesson 1.3: Assembly Syntax Choices

### The Problem

x86 assembly has two common syntaxes that look completely different:

```asm
# AT&T syntax (GNU assembler)
movl    %esi, %eax        # move esi INTO eax

# Intel syntax (NASM, MASM)
mov     eax, esi          ; move esi INTO eax
```

Same instruction, opposite operand order! We need to pick one.

### The Solution: AT&T Syntax

We'll use **AT&T syntax** because:

1. **It's the default on Unix** - GNU assembler (`as`), GCC, and Clang use it
2. **Explicit size suffixes** - `movl` (long/32-bit), `movq` (quad/64-bit)
3. **Register prefixes** - `%eax` makes registers obvious
4. **Immediate prefixes** - `$42` clearly marks constants

**AT&T Syntax Rules:**

```
┌─────────────────────────────────────────────────────────────────────┐
│ AT&T SYNTAX RULES                                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ Format: opcode{suffix}  source, destination                        │
│                                                                     │
│ Suffixes indicate size:                                             │
│   b = byte (8 bits)     movb $1, %al                               │
│   w = word (16 bits)    movw $1, %ax                               │
│   l = long (32 bits)    movl $1, %eax    ← We'll use this mostly   │
│   q = quad (64 bits)    movq $1, %rax                              │
│                                                                     │
│ Prefixes:                                                           │
│   % = register          %eax, %rdi, %rsp                           │
│   $ = immediate value   $42, $-1, $0                               │
│                                                                     │
│ Examples:                                                           │
│   movl  $42, %eax       # eax = 42                                 │
│   addl  %esi, %eax      # eax = eax + esi                          │
│   subl  $1, %ecx        # ecx = ecx - 1                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**Comparison:**

| Aspect | AT&T | Intel |
|--------|------|-------|
| Operand order | src, dst | dst, src |
| Register prefix | %eax | eax |
| Immediate prefix | $42 | 42 |
| Size suffix | movl, movq | mov with context |
| Assembler | `as` (GNU) | `nasm` |

---

## Sub-lesson 1.4: Architectures and Operating Systems

### The Problem

x86-64 isn't the only CPU architecture. If you're on an Apple Silicon Mac (M1/M2/M3), your CPU speaks a completely different instruction set. What works where?

### The Solution: Know Your Target

**Major CPU Architectures:**

```
┌─────────────────────────────────────────────────────────────────────┐
│ CPU ARCHITECTURES AND OPERATING SYSTEMS                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ x86-64 (also called AMD64, x64, Intel 64):                         │
│   ├── Windows (most PCs)                                           │
│   ├── Linux (most servers and desktops)                            │
│   ├── macOS (Intel Macs, 2006-2020)                                │
│   └── WSL, Docker on Intel/AMD                                     │
│                                                                     │
│ ARM64 (also called AArch64):                                        │
│   ├── macOS (Apple Silicon: M1, M2, M3, M4)                        │
│   ├── Linux (Raspberry Pi 4+, AWS Graviton, servers)               │
│   ├── Windows (Surface Pro X, some laptops)                        │
│   └── iOS, Android (phones and tablets)                            │
│                                                                     │
│ Other architectures (less common for desktops):                     │
│   ├── RISC-V (emerging open standard)                              │
│   ├── x86-32 (legacy 32-bit, mostly obsolete)                      │
│   └── PowerPC, MIPS, SPARC (specialized uses)                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**What This Means for You:**

| Your System | This Tutorial | Notes |
|-------------|---------------|-------|
| Intel/AMD Mac (pre-2020) | ✅ Works directly | Native x86-64 |
| Apple Silicon Mac (M1+) | ⚠️ Runs via Rosetta 2 | `cc` auto-translates |
| Linux on Intel/AMD | ✅ Works directly | Native x86-64 |
| Linux on ARM64 | ❌ Won't work | Different instruction set |
| Windows + WSL | ✅ Works directly | Native x86-64 |
| Windows on ARM | ⚠️ Via emulation | May work with x86 emulation |

### Check Your Architecture

```bash
# On macOS or Linux:
uname -m
# x86_64  → You're on x86-64 (tutorial works natively)
# arm64   → You're on ARM64 (M1/M2/M3 Mac or ARM Linux)
# aarch64 → Same as arm64

# On macOS specifically:
sysctl -n machdep.cpu.brand_string
# Shows "Apple M1" or "Intel(R) Core(TM)..."
```

### Apple Silicon Note

If you're on an Apple Silicon Mac, the good news is that **Rosetta 2** can run x86-64 code:

```bash
# Force x86-64 mode on Apple Silicon:
arch -x86_64 cc -o test test.s
arch -x86_64 ./test
echo $?

# Or just use cc directly (it handles this automatically):
cc -o test test.s      # Creates a universal or x86 binary
./test                  # Rosetta 2 runs it
```

**The assembly code we write is the same** - macOS handles the translation at runtime.

### Why x86-64 for This Tutorial?

```
┌─────────────────────────────────────────────────────────────────────┐
│ WHY WE CHOSE x86-64                                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ 1. Most common desktop/laptop architecture                          │
│    - All Windows PCs with Intel/AMD                                │
│    - Most Linux machines                                            │
│    - Macs from 2006-2020 (and via Rosetta 2 on newer)             │
│                                                                     │
│ 2. Well-documented                                                  │
│    - 40+ years of documentation                                     │
│    - Many tutorials and references available                        │
│                                                                     │
│ 3. CISC architecture                                                │
│    - Complex instructions show more concepts                        │
│    - Division quirks, flag registers, etc.                         │
│                                                                     │
│ 4. Industry standard calling convention                             │
│    - System V AMD64 ABI (Linux, macOS)                             │
│    - Can call C library functions directly                         │
│                                                                     │
│ Want ARM64 instead? The concepts transfer:                          │
│    x86: movl $42, %eax     →  ARM64: mov w0, #42                   │
│    x86: addl %esi, %eax    →  ARM64: add w0, w0, w1                │
│    x86: ret                →  ARM64: ret                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Summary: Our x86 Backend Design

```
┌────────────────────────────────────────────────────────────────────┐
│ x86 BACKEND DESIGN DECISIONS                                       │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│ Target:       x86-64 (64-bit mode)                                 │
│ Syntax:       AT&T (src, dst with % and $ prefixes)                │
│ Assembler:    GNU as (part of binutils)                            │
│ Platform:     Linux / macOS (System V AMD64 ABI)                   │
│ Output:       .s text file → assembled with `as`                   │
│                                                                    │
│ What we generate:                                                  │
│   - Assembly text (human-readable)                                 │
│   - No optimizations (clarity over speed)                          │
│   - Standard calling convention (so we can link with C)            │
│                                                                    │
│ Build command:                                                     │
│   as -o output.o output.s && cc -o program output.o                │
│   # or simply: cc -o program output.s                              │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## Try It Yourself

Before continuing, verify your system is ready:

```bash
# Check you have an assembler
as --version

# Write a minimal assembly file
cat > test.s << 'EOF'
    .text
    .globl main
main:
    movl    $42, %eax
    ret
EOF

# Assemble and link
cc -o test test.s

# Run (should exit with code 42)
./test
echo $?
```

If you see `42`, you're ready for the next lesson!

---

## What's Next

Now that we understand why we're building an x86 backend, let's learn the basics of x86-64 architecture: registers, instructions, and memory.

**Next: [Lesson 2: x86-64 Basics](../02-x86-basics/)** →
