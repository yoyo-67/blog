<!doctype html>
<html
  lang="en-us"
  dir="ltr"
  class="scroll-smooth"
  data-default-appearance="dark"
  data-auto-appearance="true"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  
    <meta http-equiv="content-language" content="en-us">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color">

  
  
    <title>Zig Compiler Internals Part 3: Parser and AST &middot; Yohai&#39;s Blog</title>
    <meta name="title" content="Zig Compiler Internals Part 3: Parser and AST &middot; Yohai&#39;s Blog">
  

  
  
  
  
  
  <link rel="canonical" href="http://localhost:1313/drafts/03-parser-ast/">
  

  
  
    <meta name="author" content="Yohai">
  
  

  
  <meta property="og:url" content="http://localhost:1313/drafts/03-parser-ast/">
  <meta property="og:site_name" content="Yohai&#39;s Blog">
  <meta property="og:title" content="Zig Compiler Internals Part 3: Parser and AST">
  <meta property="og:description" content="Zig Compiler Internals Part 3: Parser and AST # Building trees from tokens with recursive descent
Introduction # After the tokenizer breaks source code into tokens, the parser organizes those tokens into a hierarchical structure called the Abstract Syntax Tree (AST). This tree represents the syntactic structure of the program.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="drafts">
    <meta property="article:published_time" content="2025-12-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-12-17T00:00:00+00:00">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Zig Compiler Internals Part 3: Parser and AST">
  <meta name="twitter:description" content="Zig Compiler Internals Part 3: Parser and AST # Building trees from tokens with recursive descent
Introduction # After the tokenizer breaks source code into tokens, the parser organizes those tokens into a hierarchical structure called the Abstract Syntax Tree (AST). This tree represents the syntactic structure of the program.">

  
  
  
  
    
      
    
  
    
      
    
  
    
      
    
  
  
    
  

  
  
  
  
  
  

  

  
  
  
  
  
  
  
  
    
  
  
  <link
    type="text/css"
    rel="stylesheet"
    href="/css/main.bundle.min.0975a8c7c266a0697f94839b45e1574c449de253527d44ed516d5c5c3c820c9389d7d86576faae12267b129f8749ecbf7581cddb636aba7690aa633b95aaa87d.css"
    integrity="sha512-CXWox8JmoGl/lIObReFXTESd4lNSfUTtUW1cXDyCDJOJ19hldvquEiZ7Ep&#43;HSey/dYHN22NqunaQqmM7laqofQ==">

  
  
  <script
    type="text/javascript"
    src="/js/appearance.min.6f41174b3a05b680820fe08cadbfa5fb7a7ca347b76a0955cdc68b9d8aca1ce24f0547e138cea33bcc7904d551a90afcb1cc7f2d9fe8557075d501419046c08c.js"
    integrity="sha512-b0EXSzoFtoCCD&#43;CMrb&#43;l&#43;3p8o0e3aglVzcaLnYrKHOJPBUfhOM6jO8x5BNVRqQr8scx/LZ/oVXB11QFBkEbAjA=="></script>
  
  
  
  
  
  
    
    <script src="/lib/zoom/zoom.min.umd.a527109b68c082a70f3697716dd72a9d5aa8b545cf800cecbbc7399f2ca6f6e0ce3e431f2062b48bbfa47c9ea42822714060bef309be073f49b9c0e30d318d7b.js" integrity="sha512-pScQm2jAgqcPNpdxbdcqnVqotUXPgAzsu8c5nyym9uDOPkMfIGK0i7&#43;kfJ6kKCJxQGC&#43;8wm&#43;Bz9JucDjDTGNew=="></script>
  

  
  
  
    
  
  
    
  
  
    
  
  
  
  
  
  
    
    <script
      defer
      type="text/javascript"
      id="script-bundle"
      src="/js/main.bundle.min.9cc802d09f28c6af56ceee7bc6e320a39251fdae98243f2a9942f221ac57a9f49c51609699a91794a7b2580ee1deaa8e4d794a68ffa94aa317c66e893ce51e02.js"
      integrity="sha512-nMgC0J8oxq9Wzu57xuMgo5JR/a6YJD8qmULyIaxXqfScUWCWmakXlKeyWA7h3qqOTXlKaP&#43;pSqMXxm6JPOUeAg=="
      data-copy="Copy"
      data-copied="Copied"></script>
  

  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>


























  

  

  

  

  





  
  
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
  

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Drafts",
    "name": "Zig Compiler Internals Part 3: Parser and AST",
    "headline": "Zig Compiler Internals Part 3: Parser and AST",
    
    "abstract": "\u003ch1 class=\u0022relative group\u0022\u003eZig Compiler Internals Part 3: Parser and AST\n    \u003cdiv id=\u0022zig-compiler-internals-part-3-parser-and-ast\u0022 class=\u0022anchor\u0022\u003e\u003c\/div\u003e\n    \n    \u003cspan\n        class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\u0022\u003e\n        \u003ca class=\u0022text-primary-300 dark:text-neutral-700 !no-underline\u0022 href=\u0022#zig-compiler-internals-part-3-parser-and-ast\u0022 aria-label=\u0022Anchor\u0022\u003e#\u003c\/a\u003e\n    \u003c\/span\u003e\n    \n\u003c\/h1\u003e\n\u003cp\u003e\u003cem\u003eBuilding trees from tokens with recursive descent\u003c\/em\u003e\u003c\/p\u003e\n\u003chr\u003e\n\n\u003ch2 class=\u0022relative group\u0022\u003eIntroduction\n    \u003cdiv id=\u0022introduction\u0022 class=\u0022anchor\u0022\u003e\u003c\/div\u003e\n    \n    \u003cspan\n        class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\u0022\u003e\n        \u003ca class=\u0022text-primary-300 dark:text-neutral-700 !no-underline\u0022 href=\u0022#introduction\u0022 aria-label=\u0022Anchor\u0022\u003e#\u003c\/a\u003e\n    \u003c\/span\u003e\n    \n\u003c\/h2\u003e\n\u003cp\u003eAfter the tokenizer breaks source code into tokens, the \u003cstrong\u003eparser\u003c\/strong\u003e organizes those tokens into a hierarchical structure called the \u003cstrong\u003eAbstract Syntax Tree (AST)\u003c\/strong\u003e. This tree represents the syntactic structure of the program.\u003c\/p\u003e",
    "inLanguage": "en-us",
    "url" : "http://localhost:1313/drafts/03-parser-ast/",
    "author" : {
      "@type": "Person",
      "name": "Yohai"
    },
    "copyrightYear": "2025",
    "dateCreated": "2025-12-17T00:00:00\u002b00:00",
    "datePublished": "2025-12-17T00:00:00\u002b00:00",
    
    "dateModified": "2025-12-17T00:00:00\u002b00:00",
    
    
    
    "mainEntityOfPage": "true",
    "wordCount": "11660"
  }]
  </script>



  
  

  
  

  
  

  
  

  
  
</head>


















  
  
  <body class="flex flex-col h-screen m-auto leading-7 max-w-7xl px-6 sm:px-14 md:px-24 lg:px-32 text-lg bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
    <div id="the-top" class="absolute flex self-center">
      <a
        class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
        href="#main-content">
        <span class="font-bold text-primary-600 pe-2 dark:text-primary-400">&darr;</span>
        Skip to main content
      </a>
    </div>
    
    
      













<div
  class="main-menu flex items-center justify-between py-6 md:justify-start gap-x-3 pt-[2px] pr-2 md:pr-4 pb-[3px] pl-0">
  
  

  <div class="flex flex-1 items-center justify-between">
    <nav class="flex space-x-3">
      
        <a href="/" class="text-base font-medium">
          Yohai&rsquo;s Blog
        </a>
      
    </nav>
    
  <nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12">
    
      
        
  <a
  href="/posts/"
  
  class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
  aria-label="Posts"
  title="Posts">
  
  
    <p class="text-base font-medium">
      Posts
    </p>
  
</a>



      
        
  <a
  href="/drafts/"
  
  class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
  aria-label="Drafts"
  title="Drafts">
  
  
    <p class="text-base font-medium">
      Drafts
    </p>
  
</a>



      
        
  <a
  href="/tags/"
  
  class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
  aria-label="Tags"
  title="Tags">
  
  
    <p class="text-base font-medium">
      Tags
    </p>
  
</a>



      
    

    

    

    
      <button
        id="search-button"
        aria-label="Search"
        class="text-base hover:text-primary-600 dark:hover:text-primary-400"
        title="Search (/)">
        <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
      </button>
    

    
      <div class=" flex items-center">
        <button
          id="appearance-switcher"
          aria-label="Dark mode switcher"
          type="button"
          class="text-base hover:text-primary-600 dark:hover:text-primary-400">
          <div class="flex items-center justify-center dark:hidden">
            <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>
</span>
          </div>
          <div class="items-center justify-center hidden dark:flex">
            <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>
</span>
          </div>
        </button>
      </div>
    
  </nav>

    
  <div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12">
    <span></span>

    

    

    
      <button
        id="search-button-mobile"
        aria-label="Search"
        class="text-base hover:text-primary-600 dark:hover:text-primary-400"
        title="Search (/)">
        <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
      </button>
    

    
      <button
        id="appearance-switcher-mobile"
        aria-label="Dark mode switcher"
        type="button"
        class="text-base hover:text-primary-600 dark:hover:text-primary-400 me-1">
        <div class="flex items-center justify-center dark:hidden">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>
</span>
        </div>
        <div class="items-center justify-center hidden dark:flex">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>
</span>
        </div>
      </button>
    
  </div>

  </div>
  
  <div class="-my-2 md:hidden">
    <div id="menu-button" class="block">
      
        <div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>
</span>
        </div>
        <div
          id="menu-wrapper"
          class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50 pt-[5px]">
          <ul
            class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none text-end max-w-7xl">
            <li id="menu-close-button">
              <span
                class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400">
                <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>
</span>
              </span>
            </li>

            
              
  <li class="mt-1">
  <a
    href="/posts/"
    
    class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
    aria-label="Posts"
    title="Posts">
    
    
      <p class="text-bg font-bg">
        Posts
      </p>
    
  </a>
</li>



            
              
  <li class="mt-1">
  <a
    href="/drafts/"
    
    class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
    aria-label="Drafts"
    title="Drafts">
    
    
      <p class="text-bg font-bg">
        Drafts
      </p>
    
  </a>
</li>



            
              
  <li class="mt-1">
  <a
    href="/tags/"
    
    class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
    aria-label="Tags"
    title="Tags">
    
    
      <p class="text-bg font-bg">
        Tags
      </p>
    
  </a>
</li>



            

          </ul>
          
        </div>
      
    </div>
  </div>

</div>





    
    <div class="relative flex flex-col grow">
      <main id="main-content" class="grow">
        
  
  <article>
    
    

    
    <header id="single_header" class="mt-5 max-w-prose">
      
        <ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden">
  
  
    
  
    
  
  <li class="hidden">
    <a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href="/"
      >Yohai&#39;s Blog</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  <li class="inline">
    <a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href="/drafts/"
      >Drafts</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  <li class="hidden">
    <a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href="/drafts/03-parser-ast/"
      >Zig Compiler Internals Part 3: Parser and AST</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

</ol>


      
      <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
        Zig Compiler Internals Part 3: Parser and AST
      </h1>
      <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
        





  
  



  

  
  
  
    
  

  

  
    
  

  

  
    
  

  
    
  

  

  

  

  

  


  <div class="flex flex-row flex-wrap items-center">
    
    
      <time datetime="2025-12-17T00:00:00&#43;00:00">December 17, 2025</time><span class="px-2 text-primary-500">&middot;</span><span>11660 words</span><span class="px-2 text-primary-500">&middot;</span><span title="Reading time">55 mins</span>
    

    
    
  </div>

  

  
  

  
  



      </div>
      
        
  
  
  
  
  
  

  

  
    
    
<div class="flex author">
  
  <div class="place-self-center">
    
      <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
        Author
      </div>
      <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
        Yohai
      </div>
    
    
    <div class="text-2xl sm:text-lg">
</div>
  </div>
</div>

  

  

  
    <div class="mb-5"></div>
  

      
    </header>

    
    <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
      
      
      
      
      
        <div class="order-first lg:ml-auto px-0 lg:order-last lg:ps-8 lg:max-w-2xs">
          <div class="toc ps-5 print:hidden lg:sticky lg:top-10">
            
              <details
  open
  id="TOCView"
  class="toc-right mt-0 overflow-y-auto overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg -ms-5 ps-5 pe-2 hidden lg:block">
  <summary
    class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="min-w-[220px] py-2 border-dotted border-s-1 -ms-5 ps-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#what-is-parsing-the-big-picture">What is Parsing? (The Big Picture)</a>
      <ul>
        <li><a href="#the-problem-flat-tokens-arent-enough">The Problem: Flat Tokens Aren&rsquo;t Enough</a></li>
        <li><a href="#the-solution-a-tree-structure">The Solution: A Tree Structure</a></li>
        <li><a href="#analogy-parsing-a-sentence">Analogy: Parsing a Sentence</a></li>
      </ul>
    </li>
    <li><a href="#the-parser-at-a-glance">The Parser at a Glance</a></li>
    <li><a href="#how-recursive-descent-works">How Recursive Descent Works</a>
      <ul>
        <li><a href="#the-core-idea">The Core Idea</a></li>
        <li><a href="#why-recursive">Why &ldquo;Recursive&rdquo;?</a></li>
        <li><a href="#visual-example-parsing-fn-add-">Visual Example: Parsing <code>fn add() {}</code></a></li>
        <li><a href="#simplified-pseudocode">Simplified Pseudocode</a></li>
      </ul>
    </li>
    <li><a href="#the-ast-structure">The AST Structure</a>
      <ul>
        <li><a href="#why-keep-the-source">Why Keep the Source?</a></li>
      </ul>
    </li>
    <li><a href="#node-structure-compact-and-efficient">Node Structure: Compact and Efficient</a>
      <ul>
        <li><a href="#visualizing-node-memory">Visualizing Node Memory</a></li>
        <li><a href="#the-data-union">The Data Union</a></li>
        <li><a href="#visual-how-data-union-works-for-different-node-types">Visual: How Data Union Works for Different Node Types</a></li>
      </ul>
    </li>
    <li><a href="#node-types-200-varieties">Node Types: 200+ Varieties</a>
      <ul>
        <li><a href="#why-so-many-variants">Why So Many Variants?</a></li>
      </ul>
    </li>
    <li><a href="#multiarraylist-cache-friendly-storage">MultiArrayList: Cache-Friendly Storage</a>
      <ul>
        <li><a href="#traditional-array-of-structs-aos">Traditional: Array-of-Structs (AoS)</a></li>
        <li><a href="#zigs-choice-struct-of-arrays-soa">Zig&rsquo;s Choice: Struct-of-Arrays (SoA)</a></li>
        <li><a href="#why-soa-is-better-for-compilers">Why SoA is Better for Compilers</a></li>
      </ul>
    </li>
    <li><a href="#the-parser-structure">The Parser Structure</a>
      <ul>
        <li><a href="#visualizing-parser-state">Visualizing Parser State</a></li>
      </ul>
    </li>
    <li><a href="#expression-parsing-precedence-climbing">Expression Parsing: Precedence Climbing</a>
      <ul>
        <li><a href="#the-problem-operator-precedence">The Problem: Operator Precedence</a></li>
        <li><a href="#the-solution-precedence-climbing">The Solution: Precedence Climbing</a></li>
        <li><a href="#the-recursive-insight">The Recursive Insight</a></li>
        <li><a href="#simple-example-1--2--3">Simple Example: <code>1 + 2 * 3</code></a></li>
        <li><a href="#why-does--win-over-">Why Does <code>* </code>Win Over <code>+</code>?</a></li>
        <li><a href="#pseudocode-precedence-climbing">Pseudocode: Precedence Climbing</a></li>
        <li><a href="#complex-example-1--2--3--4---5">Complex Example: <code>1 * 2 + 3 * 4 - 5</code></a></li>
        <li><a href="#the-actual-zig-code">The Actual Zig Code</a></li>
        <li><a href="#two-recursion-patterns-summary">Two Recursion Patterns Summary</a></li>
        <li><a href="#detailed-trace-parsing-1--2--3">Detailed Trace: Parsing <code>1 + 2 * 3</code></a></li>
        <li><a href="#visual-the-key-insight">Visual: The Key Insight</a></li>
        <li><a href="#operator-precedence-table">Operator Precedence Table</a></li>
        <li><a href="#non-associative-operators-why-a--b--c-fails">Non-Associative Operators (Why <code>a &lt; b &lt; c</code> Fails)</a></li>
      </ul>
    </li>
    <li><a href="#parsing-function-declarations-a-complete-example">Parsing Function Declarations: A Complete Example</a>
      <ul>
        <li><a href="#step-1-entry-point">Step 1: Entry Point</a></li>
        <li><a href="#step-2-parse-function-prototype">Step 2: Parse Function Prototype</a></li>
        <li><a href="#step-3-parse-parameters">Step 3: Parse Parameters</a></li>
        <li><a href="#step-4-parse-return-type">Step 4: Parse Return Type</a></li>
        <li><a href="#step-5-select-node-variant">Step 5: Select Node Variant</a></li>
        <li><a href="#step-6-parse-block-body">Step 6: Parse Block Body</a></li>
        <li><a href="#final-ast-structure">Final AST Structure</a></li>
      </ul>
    </li>
    <li><a href="#extra-data-storage">Extra Data Storage</a>
      <ul>
        <li><a href="#visualizing-extra-data">Visualizing Extra Data</a></li>
        <li><a href="#extra-data-structures">Extra Data Structures</a></li>
      </ul>
    </li>
    <li><a href="#error-recovery-dont-stop-at-first-error">Error Recovery: Don&rsquo;t Stop at First Error</a>
      <ul>
        <li><a href="#visualizing-error-recovery">Visualizing Error Recovery</a></li>
      </ul>
    </li>
    <li><a href="#token-consumption-patterns">Token Consumption Patterns</a>
      <ul>
        <li><a href="#visual-eat-vs-expect">Visual: eat vs expect</a></li>
      </ul>
    </li>
    <li><a href="#memory-efficiency-the-numbers">Memory Efficiency: The Numbers</a>
      <ul>
        <li><a href="#real-world-example">Real-World Example</a></li>
        <li><a href="#why-its-efficient">Why It&rsquo;s Efficient</a></li>
      </ul>
    </li>
    <li><a href="#high-level-ast-accessors">High-Level AST Accessors</a>
      <ul>
        <li><a href="#why-accessors">Why Accessors?</a></li>
      </ul>
    </li>
    <li><a href="#complete-example-from-source-to-tree">Complete Example: From Source to Tree</a>
      <ul>
        <li><a href="#source-code">Source Code</a></li>
        <li><a href="#token-stream">Token Stream</a></li>
        <li><a href="#resulting-ast">Resulting AST</a></li>
      </ul>
    </li>
    <li><a href="#summary-the-parsers-job">Summary: The Parser&rsquo;s Job</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
  </div>
</details>
<details class="toc-inside mt-0 overflow-hidden rounded-lg -ms-5 ps-5 lg:hidden">
  <summary
    class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="py-2 border-dotted border-neutral-300 border-s-1 -ms-5 ps-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#what-is-parsing-the-big-picture">What is Parsing? (The Big Picture)</a>
      <ul>
        <li><a href="#the-problem-flat-tokens-arent-enough">The Problem: Flat Tokens Aren&rsquo;t Enough</a></li>
        <li><a href="#the-solution-a-tree-structure">The Solution: A Tree Structure</a></li>
        <li><a href="#analogy-parsing-a-sentence">Analogy: Parsing a Sentence</a></li>
      </ul>
    </li>
    <li><a href="#the-parser-at-a-glance">The Parser at a Glance</a></li>
    <li><a href="#how-recursive-descent-works">How Recursive Descent Works</a>
      <ul>
        <li><a href="#the-core-idea">The Core Idea</a></li>
        <li><a href="#why-recursive">Why &ldquo;Recursive&rdquo;?</a></li>
        <li><a href="#visual-example-parsing-fn-add-">Visual Example: Parsing <code>fn add() {}</code></a></li>
        <li><a href="#simplified-pseudocode">Simplified Pseudocode</a></li>
      </ul>
    </li>
    <li><a href="#the-ast-structure">The AST Structure</a>
      <ul>
        <li><a href="#why-keep-the-source">Why Keep the Source?</a></li>
      </ul>
    </li>
    <li><a href="#node-structure-compact-and-efficient">Node Structure: Compact and Efficient</a>
      <ul>
        <li><a href="#visualizing-node-memory">Visualizing Node Memory</a></li>
        <li><a href="#the-data-union">The Data Union</a></li>
        <li><a href="#visual-how-data-union-works-for-different-node-types">Visual: How Data Union Works for Different Node Types</a></li>
      </ul>
    </li>
    <li><a href="#node-types-200-varieties">Node Types: 200+ Varieties</a>
      <ul>
        <li><a href="#why-so-many-variants">Why So Many Variants?</a></li>
      </ul>
    </li>
    <li><a href="#multiarraylist-cache-friendly-storage">MultiArrayList: Cache-Friendly Storage</a>
      <ul>
        <li><a href="#traditional-array-of-structs-aos">Traditional: Array-of-Structs (AoS)</a></li>
        <li><a href="#zigs-choice-struct-of-arrays-soa">Zig&rsquo;s Choice: Struct-of-Arrays (SoA)</a></li>
        <li><a href="#why-soa-is-better-for-compilers">Why SoA is Better for Compilers</a></li>
      </ul>
    </li>
    <li><a href="#the-parser-structure">The Parser Structure</a>
      <ul>
        <li><a href="#visualizing-parser-state">Visualizing Parser State</a></li>
      </ul>
    </li>
    <li><a href="#expression-parsing-precedence-climbing">Expression Parsing: Precedence Climbing</a>
      <ul>
        <li><a href="#the-problem-operator-precedence">The Problem: Operator Precedence</a></li>
        <li><a href="#the-solution-precedence-climbing">The Solution: Precedence Climbing</a></li>
        <li><a href="#the-recursive-insight">The Recursive Insight</a></li>
        <li><a href="#simple-example-1--2--3">Simple Example: <code>1 + 2 * 3</code></a></li>
        <li><a href="#why-does--win-over-">Why Does <code>* </code>Win Over <code>+</code>?</a></li>
        <li><a href="#pseudocode-precedence-climbing">Pseudocode: Precedence Climbing</a></li>
        <li><a href="#complex-example-1--2--3--4---5">Complex Example: <code>1 * 2 + 3 * 4 - 5</code></a></li>
        <li><a href="#the-actual-zig-code">The Actual Zig Code</a></li>
        <li><a href="#two-recursion-patterns-summary">Two Recursion Patterns Summary</a></li>
        <li><a href="#detailed-trace-parsing-1--2--3">Detailed Trace: Parsing <code>1 + 2 * 3</code></a></li>
        <li><a href="#visual-the-key-insight">Visual: The Key Insight</a></li>
        <li><a href="#operator-precedence-table">Operator Precedence Table</a></li>
        <li><a href="#non-associative-operators-why-a--b--c-fails">Non-Associative Operators (Why <code>a &lt; b &lt; c</code> Fails)</a></li>
      </ul>
    </li>
    <li><a href="#parsing-function-declarations-a-complete-example">Parsing Function Declarations: A Complete Example</a>
      <ul>
        <li><a href="#step-1-entry-point">Step 1: Entry Point</a></li>
        <li><a href="#step-2-parse-function-prototype">Step 2: Parse Function Prototype</a></li>
        <li><a href="#step-3-parse-parameters">Step 3: Parse Parameters</a></li>
        <li><a href="#step-4-parse-return-type">Step 4: Parse Return Type</a></li>
        <li><a href="#step-5-select-node-variant">Step 5: Select Node Variant</a></li>
        <li><a href="#step-6-parse-block-body">Step 6: Parse Block Body</a></li>
        <li><a href="#final-ast-structure">Final AST Structure</a></li>
      </ul>
    </li>
    <li><a href="#extra-data-storage">Extra Data Storage</a>
      <ul>
        <li><a href="#visualizing-extra-data">Visualizing Extra Data</a></li>
        <li><a href="#extra-data-structures">Extra Data Structures</a></li>
      </ul>
    </li>
    <li><a href="#error-recovery-dont-stop-at-first-error">Error Recovery: Don&rsquo;t Stop at First Error</a>
      <ul>
        <li><a href="#visualizing-error-recovery">Visualizing Error Recovery</a></li>
      </ul>
    </li>
    <li><a href="#token-consumption-patterns">Token Consumption Patterns</a>
      <ul>
        <li><a href="#visual-eat-vs-expect">Visual: eat vs expect</a></li>
      </ul>
    </li>
    <li><a href="#memory-efficiency-the-numbers">Memory Efficiency: The Numbers</a>
      <ul>
        <li><a href="#real-world-example">Real-World Example</a></li>
        <li><a href="#why-its-efficient">Why It&rsquo;s Efficient</a></li>
      </ul>
    </li>
    <li><a href="#high-level-ast-accessors">High-Level AST Accessors</a>
      <ul>
        <li><a href="#why-accessors">Why Accessors?</a></li>
      </ul>
    </li>
    <li><a href="#complete-example-from-source-to-tree">Complete Example: From Source to Tree</a>
      <ul>
        <li><a href="#source-code">Source Code</a></li>
        <li><a href="#token-stream">Token Stream</a></li>
        <li><a href="#resulting-ast">Resulting AST</a></li>
      </ul>
    </li>
    <li><a href="#summary-the-parsers-job">Summary: The Parser&rsquo;s Job</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
  </div>
</details>



            
          </div>
        </div>
      


      <div class="min-w-0 min-h-0 max-w-fit">
        

        <div class="article-content max-w-prose mb-20">
          
<h1 class="relative group">Zig Compiler Internals Part 3: Parser and AST
    <div id="zig-compiler-internals-part-3-parser-and-ast" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#zig-compiler-internals-part-3-parser-and-ast" aria-label="Anchor">#</a>
    </span>
    
</h1>
<p><em>Building trees from tokens with recursive descent</em></p>
<hr>

<h2 class="relative group">Introduction
    <div id="introduction" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#introduction" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>After the tokenizer breaks source code into tokens, the <strong>parser</strong> organizes those tokens into a hierarchical structure called the <strong>Abstract Syntax Tree (AST)</strong>. This tree represents the syntactic structure of the program.</p>
<p>In this article, we&rsquo;ll explore Zig&rsquo;s parser and its memory-efficient AST representation.</p>
<hr>

<h2 class="relative group">What is Parsing? (The Big Picture)
    <div id="what-is-parsing-the-big-picture" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#what-is-parsing-the-big-picture" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">The Problem: Flat Tokens Aren&rsquo;t Enough
    <div id="the-problem-flat-tokens-arent-enough" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-problem-flat-tokens-arent-enough" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The tokenizer gives us a flat list of tokens:</p>
<pre tabindex="0"><code>fn, add, (, a, :, u32, ,, b, :, u32, ), u32, {, return, a, +, b, ;, }
</code></pre><p>But this doesn&rsquo;t tell us:</p>
<ul>
<li>Which <code>u32</code> is a parameter type vs the return type?</li>
<li>Does <code>+</code> apply to <code>a</code> and <code>b</code>, or something else?</li>
<li>Where does the function start and end?</li>
</ul>

<h3 class="relative group">The Solution: A Tree Structure
    <div id="the-solution-a-tree-structure" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-solution-a-tree-structure" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The parser builds a <strong>tree</strong> that shows relationships:</p>
<pre tabindex="0"><code>                         fn_decl
                        /       \
                fn_proto         block
               /   |   \            \
          param  param  return     return_stmt
          /  \    /  \    |            |
         a  u32  b  u32  u32          add
                                     /   \
                                    a     b
</code></pre><p>Now we can answer those questions:</p>
<ul>
<li>Parameter types are children of <code>param</code> nodes</li>
<li>Return type is a child of <code>fn_proto</code></li>
<li><code>+</code> creates an <code>add</code> node with <code>a</code> and <code>b</code> as children</li>
</ul>

<h3 class="relative group">Analogy: Parsing a Sentence
    <div id="analogy-parsing-a-sentence" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#analogy-parsing-a-sentence" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Think of parsing English:</p>
<pre tabindex="0"><code>&#34;The big dog chased the small cat&#34;
</code></pre><p>A flat word list doesn&rsquo;t show structure. A parse tree does:</p>
<pre tabindex="0"><code>              Sentence
             /        \
     NounPhrase      VerbPhrase
      /   |   \       /       \
    Det  Adj  Noun  Verb    NounPhrase
     |    |    |     |      /   |   \
   &#34;The&#34; &#34;big&#34; &#34;dog&#34; &#34;chased&#34; Det Adj Noun
                              |   |    |
                           &#34;the&#34; &#34;small&#34; &#34;cat&#34;
</code></pre><p>Programming language parsing works the same way!</p>
<hr>

<h2 class="relative group">The Parser at a Glance
    <div id="the-parser-at-a-glance" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-parser-at-a-glance" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p><strong>Location</strong>: <code>lib/std/zig/Parse.zig</code> (3,724 lines)</p>
<p>Key characteristics:</p>
<ul>
<li><strong>Hand-written recursive descent</strong> parser</li>
<li><strong>Precedence climbing</strong> for expressions</li>
<li><strong>Error recovery</strong> for better diagnostics</li>
<li><strong>Zero-copy</strong> - references original source</li>
</ul>
<hr>

<h2 class="relative group">How Recursive Descent Works
    <div id="how-recursive-descent-works" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-recursive-descent-works" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">The Core Idea
    <div id="the-core-idea" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-core-idea" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Each grammar rule becomes a function. The functions call each other, &ldquo;descending&rdquo; through the grammar.</p>
<pre tabindex="0"><code>Grammar Rule                    Parser Function
─────────────────               ─────────────────
FnDecl = &#34;fn&#34; Proto Block  →    fn parseFnDecl()
Block  = &#34;{&#34; Stmts &#34;}&#34;     →    fn parseBlock()
Stmt   = Return | If | ... →    fn parseStatement()
</code></pre>
<h3 class="relative group">Why &ldquo;Recursive&rdquo;?
    <div id="why-recursive" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-recursive" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The magic insight: <strong>the call stack IS the tree structure</strong>.</p>
<p>When functions call other functions:</p>
<ol>
<li>Each function call creates a &ldquo;frame&rdquo; on the stack</li>
<li>When a function returns, its result goes to its parent</li>
<li>This parent-child relationship IS our AST!</li>
</ol>
<pre tabindex="0"><code>Code: fn add() { return 1; }

Call Stack (grows down)         AST (grows down)
─────────────────────           ─────────────────
parseFnDecl()              →    fn_decl
  └─ parseFnProto()        →      ├─ fn_proto
  └─ parseBlock()          →      └─ block
       └─ parseStatement() →           └─ return_stmt
            └─ parseExpr() →                └─ literal &#34;1&#34;
</code></pre><p>The recursion &ldquo;unwinds&rdquo; naturally:</p>
<ul>
<li><code>parseExpr()</code> returns node for &ldquo;1&rdquo;</li>
<li><code>parseStatement()</code> wraps it in &ldquo;return_stmt&rdquo;, returns that</li>
<li><code>parseBlock()</code> collects statements, returns &ldquo;block&rdquo;</li>
<li><code>parseFnDecl()</code> combines proto + block, returns &ldquo;fn_decl&rdquo;</li>
</ul>

<h3 class="relative group">Visual Example: Parsing <code>fn add() {}</code>
    <div id="visual-example-parsing-fn-add-" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visual-example-parsing-fn-add-" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Source: fn add() { }

Step 1: parseFnDecl() called
        ┌─────────────────────────────────────┐
        │ See &#34;fn&#34;? Yes → continue            │
        │ Parse prototype → call parseFnProto │
        │ Parse body → call parseBlock        │
        └─────────────────────────────────────┘
                     │
                     ▼
Step 2: parseFnProto() called
        ┌─────────────────────────────────────┐
        │ Eat identifier &#34;add&#34;                │
        │ See &#34;(&#34;? Yes → parse params         │
        │ See return type? No → void          │
        └─────────────────────────────────────┘
                     │
                     ▼
Step 3: parseBlock() called
        ┌─────────────────────────────────────┐
        │ See &#34;{&#34;? Yes → continue             │
        │ Parse statements (none here)        │
        │ See &#34;}&#34;? Yes → done                 │
        └─────────────────────────────────────┘
</code></pre><p>The call stack naturally forms the tree structure!</p>

<h3 class="relative group">Simplified Pseudocode
    <div id="simplified-pseudocode" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#simplified-pseudocode" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Here&rsquo;s the pattern distilled to its essence:</p>
<pre tabindex="0"><code>// Each parse function:
// 1. Checks if it should handle current token
// 2. Consumes tokens it recognizes
// 3. Calls other parsers for nested structures
// 4. Returns a node

fn parseFnDecl():
    if not see(&#34;fn&#34;): return null    // Not my job
    eat(&#34;fn&#34;)                         // Consume token

    proto = parseFnProto()            // RECURSE: child parser
    body = parseBlock()               // RECURSE: another child

    return FnDeclNode(proto, body)    // Combine &amp; return

fn parseBlock():
    expect(&#34;{&#34;)                       // Must have this

    statements = []
    while not see(&#34;}&#34;):
        stmt = parseStatement()       // RECURSE: for each stmt
        statements.append(stmt)

    expect(&#34;}&#34;)
    return BlockNode(statements)

fn parseStatement():
    if see(&#34;return&#34;): return parseReturn()   // RECURSE
    if see(&#34;if&#34;):     return parseIf()       // RECURSE
    if see(&#34;while&#34;):  return parseWhile()    // RECURSE
    // ... etc
</code></pre><p><strong>Key insight</strong>: The &ldquo;recursive&rdquo; part is just that parsers call other parsers. The call stack tracks where we are in the nested structure automatically!</p>
<hr>

<h2 class="relative group">The AST Structure
    <div id="the-ast-structure" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-ast-structure" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p><strong>Location</strong>: <code>lib/std/zig/Ast.zig</code> (4,029 lines)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">Ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">source</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">        </span><span class="c1">// Original source code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">tokens</span><span class="o">:</span><span class="w"> </span><span class="n">TokenList</span><span class="p">.</span><span class="n">Slice</span><span class="p">,</span><span class="w">     </span><span class="c1">// All tokens
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">nodes</span><span class="o">:</span><span class="w"> </span><span class="n">NodeList</span><span class="p">.</span><span class="n">Slice</span><span class="p">,</span><span class="w">       </span><span class="c1">// All AST nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">extra_data</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="kt">u32</span><span class="p">,</span><span class="w">           </span><span class="c1">// Overflow storage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">mode</span><span class="o">:</span><span class="w"> </span><span class="n">Mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">zig</span><span class="p">,</span><span class="w">           </span><span class="c1">// .zig or .zon
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">errors</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="kr">const</span><span class="w"> </span><span class="n">Error</span><span class="p">,</span><span class="w">       </span><span class="c1">// Parse errors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Why Keep the Source?
    <div id="why-keep-the-source" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-keep-the-source" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The AST doesn&rsquo;t copy strings. Identifiers like <code>add</code> are just indices pointing back to the source:</p>
<pre tabindex="0"><code>Source: &#34;fn add(a: u32) u32 { ... }&#34;
         ↑  ↑   ↑  ↑
         0  3   7  10  (byte positions)

Token for &#34;add&#34;:
  .tag = .identifier
  .start = 3
  .end = 6

AST node just stores: main_token = 1 (index of &#34;add&#34; token)
</code></pre><p>This saves memory and enables source location tracking.</p>
<hr>

<h2 class="relative group">Node Structure: Compact and Efficient
    <div id="node-structure-compact-and-efficient" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#node-structure-compact-and-efficient" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Every AST node is just 13 bytes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">tag</span><span class="o">:</span><span class="w"> </span><span class="n">Tag</span><span class="p">,</span><span class="w">             </span><span class="c1">// 1 byte - what kind of node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">main_token</span><span class="o">:</span><span class="w"> </span><span class="n">TokenIndex</span><span class="p">,</span><span class="w">  </span><span class="c1">// 4 bytes - primary token
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">data</span><span class="o">:</span><span class="w"> </span><span class="n">Data</span><span class="p">,</span><span class="w">           </span><span class="c1">// 8 bytes - node-specific data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kr">comptime</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nf">assert</span><span class="p">(</span><span class="nb">@sizeOf</span><span class="p">(</span><span class="n">Tag</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">runtime_safety</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nf">assert</span><span class="p">(</span><span class="nb">@sizeOf</span><span class="p">(</span><span class="n">Data</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Visualizing Node Memory
    <div id="visualizing-node-memory" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visualizing-node-memory" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────┐
│                   AST Node (13 bytes)           │
├─────────┬───────────────────┬───────────────────┤
│   Tag   │    main_token     │       Data        │
│ 1 byte  │     4 bytes       │     8 bytes       │
├─────────┼───────────────────┼───────────────────┤
│  .add   │        7          │  { lhs=3, rhs=5 } │
│         │   (the &#34;+&#34; token) │                   │
└─────────┴───────────────────┴───────────────────┘
</code></pre>
<h3 class="relative group">The Data Union
    <div id="the-data-union" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-data-union" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The <code>Data</code> field stores different information depending on the node type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">node</span><span class="o">:</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w">                              </span><span class="c1">// Single child node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">opt_node</span><span class="o">:</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">                  </span><span class="c1">// Optional child node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">token</span><span class="o">:</span><span class="w"> </span><span class="n">TokenIndex</span><span class="p">,</span><span class="w">                        </span><span class="c1">// Token reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">node_and_node</span><span class="o">:</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="p">},</span><span class="w">   </span><span class="c1">// Two children
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">opt_node_and_opt_node</span><span class="o">:</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">extra_range</span><span class="o">:</span><span class="w"> </span><span class="n">SubRange</span><span class="p">,</span><span class="w">                    </span><span class="c1">// Range into extra_data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// ... more variants
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Visual: How Data Union Works for Different Node Types
    <div id="visual-how-data-union-works-for-different-node-types" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visual-how-data-union-works-for-different-node-types" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────┐
│ Node Type: .add  (binary operation)                          │
├──────────────────────────────────────────────────────────────┤
│ Data = .node_and_node = { lhs: 3, rhs: 5 }                   │
│                                                              │
│         add (this node)                                      │
│        /   \                                                 │
│   node[3]  node[5]                                           │
│      a        b                                              │
└──────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────┐
│ Node Type: .negation  (unary operation)                      │
├──────────────────────────────────────────────────────────────┤
│ Data = .node = 4                                             │
│                                                              │
│       negation (this node)                                   │
│           |                                                  │
│       node[4]                                                │
│          x                                                   │
└──────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────┐
│ Node Type: .identifier  (leaf node)                          │
├──────────────────────────────────────────────────────────────┤
│ Data = .token = 12                                           │
│                                                              │
│       identifier (this node, references token 12)            │
│           |                                                  │
│         (no children - it&#39;s a leaf!)                         │
└──────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Node Types: 200+ Varieties
    <div id="node-types-200-varieties" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#node-types-200-varieties" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>The parser recognizes many node types:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">Tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">root</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Declarations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">test_decl</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">global_var_decl</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">local_var_decl</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">simple_var_decl</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">aligned_var_decl</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">fn_decl</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Control flow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="err">@</span><span class="s">&#34;if&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">if_simple</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">@</span><span class="s">&#34;while&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">while_simple</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">while_cont</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">@</span><span class="s">&#34;for&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">for_simple</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">@</span><span class="s">&#34;switch&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Expressions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">call</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">call_one</span><span class="p">,</span><span class="w">           </span><span class="c1">// Optimization: exactly 1 argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">call_one_comma</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">field_access</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">array_access</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">deref</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Binary operators
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="n">sub</span><span class="p">,</span><span class="w"> </span><span class="n">mul</span><span class="p">,</span><span class="w"> </span><span class="n">div</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bit_and</span><span class="p">,</span><span class="w"> </span><span class="n">bit_or</span><span class="p">,</span><span class="w"> </span><span class="n">bit_xor</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bool_and</span><span class="p">,</span><span class="w"> </span><span class="n">bool_or</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">equal_equal</span><span class="p">,</span><span class="w"> </span><span class="n">bang_equal</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">less_than</span><span class="p">,</span><span class="w"> </span><span class="n">greater_than</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Unary operators
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">bool_not</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">negation</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">address_of</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">@</span><span class="s">&#34;try&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Types
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">optional_type</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">array_type</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ptr_type</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">block</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">block_two</span><span class="p">,</span><span class="w">          </span><span class="c1">// Optimized: 0-2 statements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">block_two_semicolon</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ... 200+ total
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Why So Many Variants?
    <div id="why-so-many-variants" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-so-many-variants" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Notice <code>call</code> vs <code>call_one</code> vs <code>call_one_comma</code>? These optimize common cases:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────┐
│ Node Variant Selection for Function Calls                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   foo()           → call_one      (0-1 args, fits in Data)  │
│   foo(x)          → call_one      (0-1 args, fits in Data)  │
│   foo(x,)         → call_one_comma (trailing comma)         │
│   foo(x, y)       → call          (2+ args, uses extra_data)│
│   foo(x, y, z)    → call          (2+ args, uses extra_data)│
│                                                             │
│   Most calls have 0-1 arguments, so call_one is very common │
│   and avoids extra_data allocation!                         │
└─────────────────────────────────────────────────────────────┘
</code></pre><p>Same pattern for blocks:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────┐
│ Node Variant Selection for Blocks                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   {}              → block_two  (0 stmts, fits in Data)      │
│   { x; }          → block_two  (1 stmt, fits in Data)       │
│   { x; y; }       → block_two  (2 stmts, fits in Data)      │
│   { x; y; z; }    → block      (3+ stmts, uses extra_data)  │
│                                                             │
│   Most blocks have 0-2 statements!                          │
└─────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">MultiArrayList: Cache-Friendly Storage
    <div id="multiarraylist-cache-friendly-storage" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#multiarraylist-cache-friendly-storage" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>The AST uses <code>std.MultiArrayList</code> for storage:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">NodeList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="nf">MultiArrayList</span><span class="p">(</span><span class="n">Node</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Traditional: Array-of-Structs (AoS)
    <div id="traditional-array-of-structs-aos" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#traditional-array-of-structs-aos" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Memory Layout:
┌──────────────────────────────────────────────────────────────┐
│ Node0          │ Node1          │ Node2          │ ...       │
├────┬─────┬─────┼────┬─────┬─────┼────┬─────┬─────┼───────────┤
│tag │token│data │tag │token│data │tag │token│data │ ...       │
│ 1  │  4  │  8  │ 1  │  4  │  8  │ 1  │  4  │  8  │           │
└────┴─────┴─────┴────┴─────┴─────┴────┴─────┴─────┴───────────┘
</code></pre>
<h3 class="relative group">Zig&rsquo;s Choice: Struct-of-Arrays (SoA)
    <div id="zigs-choice-struct-of-arrays-soa" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#zigs-choice-struct-of-arrays-soa" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Memory Layout:
┌─────────────────────────────────────────────────────────────┐
│ tags array:                                                 │
│ ┌────┬────┬────┬────┬────┬────┐                             │
│ │tag0│tag1│tag2│tag3│tag4│... │  All tags contiguous!       │
│ └────┴────┴────┴────┴────┴────┘                             │
├─────────────────────────────────────────────────────────────┤
│ main_tokens array:                                          │
│ ┌─────┬─────┬─────┬─────┬─────┬─────┐                       │
│ │tok0 │tok1 │tok2 │tok3 │tok4 │...  │  All tokens together! │
│ └─────┴─────┴─────┴─────┴─────┴─────┘                       │
├─────────────────────────────────────────────────────────────┤
│ data array:                                                 │
│ ┌──────┬──────┬──────┬──────┬──────┬──────┐                 │
│ │data0 │data1 │data2 │data3 │data4 │...   │  All data here! │
│ └──────┴──────┴──────┴──────┴──────┴──────┘                 │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Why SoA is Better for Compilers
    <div id="why-soa-is-better-for-compilers" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-soa-is-better-for-compilers" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Scenario: Check all node types in the AST

With AoS (traditional):
┌──────────────────────────────────────────────────────────────┐
│ Cache Line 1: [tag0][token0][data0....][tag1][token1][da...  │
│ Cache Line 2: ...ta1][tag2][token2][data2....][tag3][to...   │
│                                                              │
│ Reading tags requires loading data we don&#39;t need!            │
│ Wasted memory bandwidth.                                     │
└──────────────────────────────────────────────────────────────┘

With SoA (Zig&#39;s approach):
┌──────────────────────────────────────────────────────────────┐
│ Cache Line 1: [tag0][tag1][tag2][tag3][tag4][tag5][tag6]...  │
│ Cache Line 2: [tag64][tag65][tag66]...                       │
│                                                              │
│ One cache line gives us 64 tags! Much faster iteration.      │
└──────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">The Parser Structure
    <div id="the-parser-structure" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-parser-structure" aria-label="Anchor">#</a>
    </span>
    
</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">Parse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">gpa</span><span class="o">:</span><span class="w"> </span><span class="n">Allocator</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">source</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">tokens</span><span class="o">:</span><span class="w"> </span><span class="n">Ast</span><span class="p">.</span><span class="n">TokenList</span><span class="p">.</span><span class="n">Slice</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">tok_i</span><span class="o">:</span><span class="w"> </span><span class="n">TokenIndex</span><span class="p">,</span><span class="w">               </span><span class="c1">// Current token
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">errors</span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="nf">ArrayList</span><span class="p">(</span><span class="n">AstError</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">nodes</span><span class="o">:</span><span class="w"> </span><span class="n">Ast</span><span class="p">.</span><span class="n">NodeList</span><span class="p">,</span><span class="w">             </span><span class="c1">// Growing node list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">extra_data</span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="nf">ArrayList</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w">  </span><span class="c1">// Overflow storage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">scratch</span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="nf">ArrayList</span><span class="p">(</span><span class="n">Node</span><span class="p">.</span><span class="n">Index</span><span class="p">),</span><span class="w">  </span><span class="c1">// Temporary workspace
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Visualizing Parser State
    <div id="visualizing-parser-state" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visualizing-parser-state" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Source:  fn add(a: u32) u32 { return a; }

Tokens:  [fn] [add] [(] [a] [:] [u32] [)] [u32] [{] [return] [a] [;] [}]
           0    1    2   3   4    5    6    7    8     9     10  11  12

Parser State:
┌─────────────────────────────────────────────────────────────┐
│  tok_i: 4                                                   │
│         ↓                                                   │
│  [fn] [add] [(] [a] [:] [u32] [)] [u32] [{] ...             │
│    0    1    2   3   4    5    6    7    8                  │
│                     ↑                                       │
│              Currently parsing type annotation              │
│                                                             │
│  nodes: [root, fn_decl, fn_proto, param, ...]              │
│  scratch: [param_idx] (building param list)                 │
└─────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Expression Parsing: Precedence Climbing
    <div id="expression-parsing-precedence-climbing" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#expression-parsing-precedence-climbing" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>This is how the parser handles expressions like <code>1 + 2 * 3</code>.</p>

<h3 class="relative group">The Problem: Operator Precedence
    <div id="the-problem-operator-precedence" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-problem-operator-precedence" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Expression: 1 + 2 * 3

Wrong interpretation (left-to-right):
        +
       / \
      1   2    then  *
                    / \
                result  3

      = (1 + 2) * 3 = 9  ✗ WRONG!

Correct interpretation (precedence-aware):
        +
       / \
      1   *
         / \
        2   3

      = 1 + (2 * 3) = 7  ✓ CORRECT!
</code></pre>
<h3 class="relative group">The Solution: Precedence Climbing
    <div id="the-solution-precedence-climbing" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-solution-precedence-climbing" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The core idea is beautifully simple:</p>
<blockquote>
<p><strong>When you see an operator, ask: &ldquo;Should I handle this, or let my caller handle it?&rdquo;</strong></p>
</blockquote>
<p>The answer depends on <strong>precedence</strong> (priority). Higher precedence = binds tighter.</p>
<pre tabindex="0"><code>Precedence Table:
  +, -  → 60  (lower priority)
  *, /  → 70  (higher priority)

Rule: Only handle operators at or above your &#34;minimum precedence&#34;
</code></pre>
<h3 class="relative group">The Recursive Insight
    <div id="the-recursive-insight" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-recursive-insight" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Here&rsquo;s why this works:</p>
<pre tabindex="0"><code>parseExprPrecedence(min_prec):
    1. Parse the first operand (a number, variable, etc.)
    2. Look at the next operator
    3. If operator&#39;s precedence &gt;= min_prec:
         - Take the operator
         - RECURSE with min_prec = operator_prec + 1
         - Combine: left OP right
         - Go back to step 2
    4. If operator&#39;s precedence &lt; min_prec:
         - STOP! Return what you have
         - Let your CALLER handle this operator
</code></pre><p><strong>The magic</strong>: By recursing with <code>prec + 1</code>, we say &ldquo;only steal operands if you bind TIGHTER than me.&rdquo;</p>

<h3 class="relative group">Simple Example: <code>1 + 2 * 3</code>
    <div id="simple-example-1--2--3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#simple-example-1--2--3" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Start: parseExprPrecedence(min_prec=0)
       I&#39;ll accept anything with prec &gt;= 0

  ┌─ Parse &#34;1&#34;
  │  See &#34;+&#34;? prec=60 &gt;= 0 ✓ I&#39;ll take it!
  │
  │  Now I need the right side of &#34;+&#34;
  │  RECURSE: parseExprPrecedence(min_prec=61)  ← &#34;beat 60 or give up&#34;
  │     │
  │     │  ┌─ Parse &#34;2&#34;
  │     │  │  See &#34;*&#34;? prec=70 &gt;= 61 ✓ I&#39;ll take it!
  │     │  │
  │     │  │  RECURSE: parseExprPrecedence(min_prec=71)
  │     │  │     │
  │     │  │     └─ Parse &#34;3&#34;, no more operators
  │     │  │        Return: 3
  │     │  │
  │     │  └─ Combine: 2 * 3
  │     │     No more operators with prec &gt;= 61
  │     │     Return: (2 * 3)
  │     │
  │     └─ Got (2 * 3) as right side of &#34;+&#34;
  │
  └─ Combine: 1 + (2 * 3)
     Return: the whole expression

Result: 1 + (2 * 3) = 7 ✓
</code></pre>
<h3 class="relative group">Why Does <code>* </code>Win Over <code>+</code>?
    <div id="why-does--win-over-" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-does--win-over-" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The key is step 3: when <code>+</code> recurses, it says &ldquo;min_prec = 61&rdquo;.</p>
<ul>
<li><code>*</code> has prec = 70, and 70 &gt;= 61, so the INNER call grabs <code>*</code></li>
<li>The inner call builds <code>2 * 3</code> and returns it</li>
<li>The outer call gets <code>(2 * 3)</code> as its right operand</li>
</ul>
<p>If it were <code>1 * 2 + 3</code>:</p>
<pre tabindex="0"><code>  Parse &#34;1&#34;
  See &#34;*&#34;? prec=70, I&#39;ll take it
  RECURSE with min_prec=71 for right side
     │
     └─ Parse &#34;2&#34;
        See &#34;+&#34;? prec=60 &lt; 71 ✗ NOT MY JOB!
        Return just &#34;2&#34;

  Combine: 1 * 2
  See &#34;+&#34;? prec=60 &gt;= 0 ✓ I&#39;ll take it at the outer level
  Get &#34;3&#34; as right side
  Combine: (1 * 2) + 3

Result: (1 * 2) + 3 = 5 ✓
</code></pre><p>The <code>+</code> couldn&rsquo;t &ldquo;steal&rdquo; the 2 because it wasn&rsquo;t high-priority enough!</p>

<h3 class="relative group">Pseudocode: Precedence Climbing
    <div id="pseudocode-precedence-climbing" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#pseudocode-precedence-climbing" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Here&rsquo;s the algorithm in simple terms:</p>
<pre tabindex="0"><code>fn parseExprPrecedence(min_prec):
    // Step 1: Get the left operand (number, variable, etc.)
    left = parsePrimaryExpr()

    // Step 2: Keep eating operators while they&#39;re &#34;strong enough&#34;
    while true:
        op = currentToken()
        op_prec = getPrecedence(op)

        // Too weak? Let caller handle it
        if op_prec &lt; min_prec:
            break

        // Strong enough! Consume the operator
        advance()

        // Get right side, but only let STRONGER ops steal it
        right = parseExprPrecedence(op_prec + 1)  // ← THE KEY!

        // Combine into a single node
        left = BinaryNode(op, left, right)

    return left
</code></pre><p><strong>Why <code>op_prec + 1</code>?</strong></p>
<p>This is the crucial trick:</p>
<ul>
<li><code>+</code> has prec 60, so it recurses with min_prec = 61</li>
<li><code>*</code> has prec 70, so 70 &gt;= 61 means <code>*</code> gets grabbed by the inner call</li>
<li>But <code>+</code> has prec 60, so 60 &lt; 61 means <code>+</code> is rejected by inner call</li>
</ul>
<p>The <code>+1</code> creates a &ldquo;precedence barrier&rdquo; that only higher-precedence operators can cross.</p>

<h3 class="relative group">Complex Example: <code>1 * 2 + 3 * 4 - 5</code>
    <div id="complex-example-1--2--3--4---5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#complex-example-1--2--3--4---5" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>This example shows multiple operators at different precedence levels:</p>
<pre tabindex="0"><code>Precedence reminder:
  +, -  → 60
  *, /  → 70

Expected result: ((1 * 2) + (3 * 4)) - 5 = (2 + 12) - 5 = 9
</code></pre><p><strong>Full Walkthrough:</strong></p>
<pre tabindex="0"><code>═══════════════════════════════════════════════════════════════════════
CALL 1: parseExprPrecedence(min_prec=0)   &#34;I accept anything&#34;
═══════════════════════════════════════════════════════════════════════

Tokens: [1] [*] [2] [+] [3] [*] [4] [-] [5]
         ↑
Parse &#34;1&#34; → left = 1

Loop iteration 1:
  See &#34;*&#34;? prec=70 &gt;= 0 ✓ I&#39;ll handle it
  Consume &#34;*&#34;
  RECURSE for right side...

  ┌─────────────────────────────────────────────────────────────────
  │ CALL 2: parseExprPrecedence(min_prec=71)   &#34;beat 70 or give up&#34;
  │
  │ Tokens: [1] [*] [2] [+] [3] [*] [4] [-] [5]
  │                   ↑
  │ Parse &#34;2&#34; → left = 2
  │
  │ Loop iteration 1:
  │   See &#34;+&#34;? prec=60 &lt; 71 ✗ NOT STRONG ENOUGH!
  │   Break out of loop
  │
  │ RETURN: 2
  └─────────────────────────────────────────────────────────────────

  Got right = 2
  Combine: left = (1 * 2)

Loop iteration 2:
  Tokens: [1] [*] [2] [+] [3] [*] [4] [-] [5]
                       ↑
  See &#34;+&#34;? prec=60 &gt;= 0 ✓ I&#39;ll handle it
  Consume &#34;+&#34;
  RECURSE for right side...

  ┌─────────────────────────────────────────────────────────────────
  │ CALL 3: parseExprPrecedence(min_prec=61)   &#34;beat 60 or give up&#34;
  │
  │ Tokens: [1] [*] [2] [+] [3] [*] [4] [-] [5]
  │                           ↑
  │ Parse &#34;3&#34; → left = 3
  │
  │ Loop iteration 1:
  │   See &#34;*&#34;? prec=70 &gt;= 61 ✓ I&#39;ll handle it
  │   Consume &#34;*&#34;
  │   RECURSE for right side...
  │
  │   ┌─────────────────────────────────────────────────────────────
  │   │ CALL 4: parseExprPrecedence(min_prec=71)
  │   │
  │   │ Tokens: [1] [*] [2] [+] [3] [*] [4] [-] [5]
  │   │                                 ↑
  │   │ Parse &#34;4&#34; → left = 4
  │   │
  │   │ Loop iteration 1:
  │   │   See &#34;-&#34;? prec=60 &lt; 71 ✗ NOT STRONG ENOUGH!
  │   │   Break out of loop
  │   │
  │   │ RETURN: 4
  │   └─────────────────────────────────────────────────────────────
  │
  │   Got right = 4
  │   Combine: left = (3 * 4)
  │
  │ Loop iteration 2:
  │   See &#34;-&#34;? prec=60 &lt; 61 ✗ NOT STRONG ENOUGH!
  │   Break out of loop
  │
  │ RETURN: (3 * 4)
  └─────────────────────────────────────────────────────────────────

  Got right = (3 * 4)
  Combine: left = ((1 * 2) + (3 * 4))

Loop iteration 3:
  Tokens: [1] [*] [2] [+] [3] [*] [4] [-] [5]
                                       ↑
  See &#34;-&#34;? prec=60 &gt;= 0 ✓ I&#39;ll handle it
  Consume &#34;-&#34;
  RECURSE for right side...

  ┌─────────────────────────────────────────────────────────────────
  │ CALL 5: parseExprPrecedence(min_prec=61)
  │
  │ Tokens: [1] [*] [2] [+] [3] [*] [4] [-] [5]
  │                                          ↑
  │ Parse &#34;5&#34; → left = 5
  │
  │ No more operators!
  │ RETURN: 5
  └─────────────────────────────────────────────────────────────────

  Got right = 5
  Combine: left = (((1 * 2) + (3 * 4)) - 5)

No more operators!
RETURN: (((1 * 2) + (3 * 4)) - 5)

═══════════════════════════════════════════════════════════════════════
FINAL AST:
═══════════════════════════════════════════════════════════════════════

                    -
                   / \
                  +   5
                 / \
                *   *
               / \ / \
              1  2 3  4

Evaluation: (1*2) + (3*4) - 5 = 2 + 12 - 5 = 9 ✓
</code></pre><p><strong>Key Observations:</strong></p>
<pre tabindex="0"><code>┌────────────────────────────────────────────────────────────────────┐
│ 1. THE LOOP HANDLES LEFT-TO-RIGHT AT SAME PRECEDENCE               │
│    ────────────────────────────────────────────────────            │
│    &#34;+&#34; and &#34;-&#34; both have prec=60                                   │
│    They&#39;re handled by the SAME call (Call 1) in its loop           │
│    This makes them left-associative: (a + b) - c, not a + (b - c)  │
│                                                                     │
│ 2. RECURSION HANDLES HIGHER PRECEDENCE                             │
│    ────────────────────────────────────────────────────            │
│    When &#34;+&#34; recurses with min_prec=61, it can&#39;t see &#34;-&#34; (prec=60) │
│    But it CAN see &#34;*&#34; (prec=70), so &#34;*&#34; binds tighter              │
│                                                                     │
│ 3. THE BARRIER PROTECTS OPERANDS                                   │
│    ────────────────────────────────────────────────────            │
│    Call 3 builds (3 * 4), then sees &#34;-&#34; with prec=60               │
│    But Call 3 has min_prec=61, so it can&#39;t take &#34;-&#34;                │
│    It returns (3 * 4) and lets Call 1 handle &#34;-&#34;                   │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">The Actual Zig Code
    <div id="the-actual-zig-code" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-actual-zig-code" aria-label="Anchor">#</a>
    </span>
    
</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">fn</span><span class="w"> </span><span class="nf">parseExpr</span><span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Parse</span><span class="p">)</span><span class="w"> </span><span class="n">Error</span><span class="o">!?</span><span class="n">Node</span><span class="p">.</span><span class="n">Index</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">parseExprPrecedence</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span><span class="w"> </span><span class="nf">parseExprPrecedence</span><span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Parse</span><span class="p">,</span><span class="w"> </span><span class="n">min_prec</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="n">Error</span><span class="o">!?</span><span class="n">Node</span><span class="p">.</span><span class="n">Index</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">parsePrefixExpr</span><span class="p">()</span><span class="w"> </span><span class="k">orelse</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">banned_prec</span><span class="o">:</span><span class="w"> </span><span class="n">i8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// For non-associative operators
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">tok_tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">tokenTag</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">tok_i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">operTable</span><span class="p">[</span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="n">tok_tag</span><span class="p">)];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Stop if precedence too low
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_prec</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Catch chained comparisons: a &lt; b &lt; c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">banned_prec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">fail</span><span class="p">(.</span><span class="n">chained_comparison_operators</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">oper_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">nextToken</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Parse right-hand side with higher precedence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">parseExprPrecedence</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">orelse</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">warn</span><span class="p">(.</span><span class="n">expected_expr</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">addNode</span><span class="p">(.{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">main_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oper_token</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">node_and_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Non-associative operators can&#39;t chain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">assoc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Assoc</span><span class="p">.</span><span class="n">none</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">banned_prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">prec</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Two Recursion Patterns Summary
    <div id="two-recursion-patterns-summary" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#two-recursion-patterns-summary" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌────────────────────────────────────────────────────────────────────┐
│                    RECURSION IN PARSING                             │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. RECURSIVE DESCENT (parseFnDecl → parseBlock → parseStatement)  │
│     ─────────────────────────────────────────────────────────────  │
│     Different functions call each other                             │
│     Each function handles one grammar rule                          │
│     Call stack = tree structure                                     │
│                                                                     │
│     parseFnDecl()                                                   │
│       └─ parseFnProto()     ← Different function                   │
│       └─ parseBlock()       ← Different function                   │
│            └─ parseStatement()                                      │
│                                                                     │
│  2. PRECEDENCE CLIMBING (parseExprPrecedence calls itself)         │
│     ─────────────────────────────────────────────────────────────  │
│     Same function calls itself with different min_prec              │
│     min_prec controls &#34;who owns the operand&#34;                        │
│     Higher prec = steals operands from lower prec                   │
│                                                                     │
│     parseExprPrecedence(0)                                          │
│       └─ parseExprPrecedence(61)   ← Same function, higher bar     │
│            └─ parseExprPrecedence(71)                               │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Detailed Trace: Parsing <code>1 + 2 * 3</code>
    <div id="detailed-trace-parsing-1--2--3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#detailed-trace-parsing-1--2--3" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The following shows every step in detail (the simple example above covers the key insight).</p>
<pre tabindex="0"><code>Precedence Table (higher = binds tighter):
  +, -  → 60
  *, /  → 70

═══════════════════════════════════════════════════════════════
STEP 1: parseExprPrecedence(min_prec=0)
═══════════════════════════════════════════════════════════════

Tokens: [1] [+] [2] [*] [3]
         ↑

Action: parsePrefixExpr() returns node for &#34;1&#34;
        node = Node{.integer_literal, token=0}

Check operator: &#34;+&#34; has prec=60, which &gt;= 0, so continue

═══════════════════════════════════════════════════════════════
STEP 2: Process &#34;+&#34; operator
═══════════════════════════════════════════════════════════════

Tokens: [1] [+] [2] [*] [3]
             ↑

Action: Consume &#34;+&#34;, then recurse for RHS with min_prec=61
        (61 because we want tighter-binding operators only)

        ┌─────────────────────────────────────────────────┐
        │ RECURSIVE CALL: parseExprPrecedence(min_prec=61)│
        └─────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════
STEP 3: Inside recursive call (min_prec=61)
═══════════════════════════════════════════════════════════════

Tokens: [1] [+] [2] [*] [3]
                 ↑

Action: parsePrefixExpr() returns node for &#34;2&#34;
        node = Node{.integer_literal, token=2}

Check operator: &#34;*&#34; has prec=70, which &gt;= 61, so continue!

═══════════════════════════════════════════════════════════════
STEP 4: Process &#34;*&#34; operator (still in recursive call)
═══════════════════════════════════════════════════════════════

Tokens: [1] [+] [2] [*] [3]
                     ↑

Action: Consume &#34;*&#34;, recurse for RHS with min_prec=71

        ┌─────────────────────────────────────────────────┐
        │ ANOTHER RECURSIVE CALL: parseExprPrecedence(71) │
        └─────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════
STEP 5: Deepest recursive call (min_prec=71)
═══════════════════════════════════════════════════════════════

Tokens: [1] [+] [2] [*] [3]
                         ↑

Action: parsePrefixExpr() returns node for &#34;3&#34;
        node = Node{.integer_literal, token=4}

Check: No more operators (end of expression)
       Return node for &#34;3&#34;

═══════════════════════════════════════════════════════════════
STEP 6: Back in Step 4&#39;s call
═══════════════════════════════════════════════════════════════

Got RHS = &#34;3&#34;
Create: mul_node = Node{.mul, lhs=&#34;2&#34;, rhs=&#34;3&#34;}

Check: No more operators with prec &gt;= 61
       Return mul_node

═══════════════════════════════════════════════════════════════
STEP 7: Back in Step 2&#39;s call
═══════════════════════════════════════════════════════════════

Got RHS = mul_node (representing 2*3)
Create: add_node = Node{.add, lhs=&#34;1&#34;, rhs=mul_node}

Check: No more operators
       Return add_node

═══════════════════════════════════════════════════════════════
FINAL RESULT:
═══════════════════════════════════════════════════════════════

        add
       /   \
      1    mul
          /   \
         2     3

Which correctly represents: 1 + (2 * 3)
</code></pre>
<h3 class="relative group">Visual: The Key Insight
    <div id="visual-the-key-insight" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visual-the-key-insight" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Why does this work?

When we see &#34;+&#34; (prec 60), we ask:
  &#34;Parse the RHS, but only if operators have prec &gt; 60&#34;

This means &#34;*&#34; (prec 70) gets grabbed by the inner call:

  Outer call sees: 1 + ???
                       └── Inner call handles: 2 * 3

  Result: 1 + (2 * 3)


If it were &#34;1 * 2 + 3&#34; instead:

  Outer call starts with &#34;1&#34;, sees &#34;*&#34; (prec 70)
  Inner call (min_prec=71) sees &#34;2&#34;, then &#34;+&#34; (prec 60)
  But 60 &lt; 71, so inner call STOPS and returns just &#34;2&#34;

  Outer continues: has &#34;1 * 2&#34;, sees &#34;+&#34; (prec 60)
  60 &gt;= 0, so outer call handles the &#34;+&#34;

  Result: (1 * 2) + 3
</code></pre>
<h3 class="relative group">Operator Precedence Table
    <div id="operator-precedence-table" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#operator-precedence-table" aria-label="Anchor">#</a>
    </span>
    
</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">const</span><span class="w"> </span><span class="n">operTable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">enums</span><span class="p">.</span><span class="nf">directEnumArrayDefault</span><span class="p">(</span><span class="n">Token</span><span class="p">.</span><span class="n">Tag</span><span class="p">,</span><span class="w"> </span><span class="n">OperInfo</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">root</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">keyword_or</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">bool_or</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">keyword_and</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">bool_and</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Comparison (non-associative)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">.</span><span class="n">equal_equal</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">equal_equal</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">none</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">bang_equal</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">bang_equal</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">none</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">angle_bracket_left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">less_than</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">none</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Bitwise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">.</span><span class="n">ampersand</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">bit_and</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">pipe</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">bit_or</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">keyword_orelse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="err">@</span><span class="s">&#34;orelse&#34;</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">keyword_catch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="err">@</span><span class="s">&#34;catch&#34;</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Arithmetic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">.</span><span class="n">plus</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">60</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">add</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">minus</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">60</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">sub</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">asterisk</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">70</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">mul</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">slash</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">70</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">div</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">});</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Non-Associative Operators (Why <code>a &lt; b &lt; c</code> Fails)
    <div id="non-associative-operators-why-a--b--c-fails" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#non-associative-operators-why-a--b--c-fails" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>In Python:  a &lt; b &lt; c  means  (a &lt; b) and (b &lt; c)
In Zig:     a &lt; b &lt; c  is a COMPILE ERROR

Why? It&#39;s ambiguous and error-prone. Zig forces explicit grouping.

The parser catches this with `banned_prec`:

Parsing: a &lt; b &lt; c

1. Parse &#34;a&#34;, see &#34;&lt;&#34; (prec=30, assoc=none)
2. Set banned_prec = 30
3. Parse RHS &#34;b&#34;
4. See &#34;&lt;&#34; again (prec=30)
5. 30 == banned_prec → ERROR: chained_comparison_operators

This prevents subtle bugs!
</code></pre><hr>

<h2 class="relative group">Parsing Function Declarations: A Complete Example
    <div id="parsing-function-declarations-a-complete-example" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#parsing-function-declarations-a-complete-example" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Let&rsquo;s trace parsing this function:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">fn</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Step 1: Entry Point
    <div id="step-1-entry-point" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#step-1-entry-point" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>parseFnDecl() called

Tokens: [fn] [add] [(] [a] [:] [u32] [,] [b] [:] [u32] [)] [u32] [{] ...
         ↑

See &#34;fn&#34;? Yes! Continue parsing.
</code></pre>
<h3 class="relative group">Step 2: Parse Function Prototype
    <div id="step-2-parse-function-prototype" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#step-2-parse-function-prototype" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>parseFnProto() called

Tokens: [fn] [add] [(] [a] [:] [u32] [,] [b] [:] [u32] [)] [u32] [{]
              ↑

Eat identifier &#34;add&#34; → function name

See &#34;(&#34;? Yes! Parse parameter list.
</code></pre>
<h3 class="relative group">Step 3: Parse Parameters
    <div id="step-3-parse-parameters" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#step-3-parse-parameters" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>parseParamDeclList() called

┌─────────────────────────────────────────────────────────────┐
│ Parameter 1:                                                │
│                                                             │
│ [a] [:] [u32] [,]                                           │
│  ↑                                                          │
│                                                             │
│ - Identifier: &#34;a&#34;                                           │
│ - See &#34;:&#34;? Yes → parse type                                 │
│ - Type: u32                                                 │
│ - See &#34;,&#34;? Yes → more params coming                         │
│                                                             │
│ Create: param_node = { name=&#34;a&#34;, type=u32 }                 │
│ Add to scratch buffer                                       │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ Parameter 2:                                                │
│                                                             │
│ [b] [:] [u32] [)]                                           │
│  ↑                                                          │
│                                                             │
│ - Identifier: &#34;b&#34;                                           │
│ - See &#34;:&#34;? Yes → parse type                                 │
│ - Type: u32                                                 │
│ - See &#34;)&#34;? Yes → end of params                              │
│                                                             │
│ Create: param_node = { name=&#34;b&#34;, type=u32 }                 │
│ Add to scratch buffer                                       │
└─────────────────────────────────────────────────────────────┘

Scratch buffer now: [param_a, param_b]
</code></pre>
<h3 class="relative group">Step 4: Parse Return Type
    <div id="step-4-parse-return-type" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#step-4-parse-return-type" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Tokens: ... [)] [u32] [{] ...
               ↑

parseTypeExpr() called
Returns: identifier_node for &#34;u32&#34;
</code></pre>
<h3 class="relative group">Step 5: Select Node Variant
    <div id="step-5-select-node-variant" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#step-5-select-node-variant" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>This is where Zig&rsquo;s AST optimization shines. The parser doesn&rsquo;t just create &ldquo;a function node&rdquo; - it picks the <strong>most compact variant</strong> that can represent this specific function.</p>

<h4 class="relative group">Background: The 8-Byte Constraint
    <div id="background-the-8-byte-constraint" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#background-the-8-byte-constraint" aria-label="Anchor">#</a>
    </span>
    
</h4>
<p>Remember, every AST node has exactly 8 bytes for its <code>data</code> field:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">tag</span><span class="o">:</span><span class="w"> </span><span class="n">Tag</span><span class="p">,</span><span class="w">           </span><span class="c1">// 1 byte  - what kind of node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">main_token</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w">    </span><span class="c1">// 4 bytes - primary token index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">data</span><span class="o">:</span><span class="w"> </span><span class="n">Data</span><span class="p">,</span><span class="w">         </span><span class="c1">// 8 bytes - THIS IS ALL WE HAVE!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>Data</code> union can hold different things, but always exactly 8 bytes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Two node indices (4 + 4 = 8 bytes)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">node_and_node</span><span class="o">:</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// One node + one extra_data index (4 + 4 = 8 bytes)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">node_and_extra</span><span class="o">:</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">ExtraIndex</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Range into extra_data array (4 + 4 = 8 bytes)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">extra_range</span><span class="o">:</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">start</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Two optional nodes (4 + 4 = 8 bytes)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">opt_node_and_opt_node</span><span class="o">:</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>The challenge</strong>: How do you fit variable amounts of data into exactly 8 bytes?</p>

<h4 class="relative group">Background: What is <code>extra_data</code>?
    <div id="background-what-is-extra_data" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#background-what-is-extra_data" aria-label="Anchor">#</a>
    </span>
    
</h4>
<p>When node data exceeds 8 bytes, the overflow goes into a separate array called <code>extra_data</code>:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│                         AST STORAGE                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  NODES ARRAY (fixed-size entries):                                   │
│  ┌──────────┬──────────┬──────────┬──────────┐                      │
│  │ Node 0   │ Node 1   │ Node 2   │ Node 3   │ ...                  │
│  │ 13 bytes │ 13 bytes │ 13 bytes │ 13 bytes │                      │
│  └──────────┴──────────┴──────────┴──────────┘                      │
│       │                      │                                       │
│       │                      └─── data points to extra_data ────┐   │
│       │                                                          │   │
│  EXTRA_DATA ARRAY (overflow storage):                            ▼   │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐            │
│  │  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │ ... │            │
│  │param│param│param│align│addr │sect │call │     │     │            │
│  │  a  │  b  │  c  │expr │space│ion  │conv │     │     │            │
│  └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘            │
│                                                                      │
│  Node.data stores an INDEX or RANGE into extra_data                 │
│  Example: { start: 0, end: 3 } means &#34;params are at indices 0,1,2&#34;  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h4 class="relative group">Background: What Are These Optional Expressions?
    <div id="background-what-are-these-optional-expressions" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#background-what-are-these-optional-expressions" aria-label="Anchor">#</a>
    </span>
    
</h4>
<p>Zig functions can have advanced attributes that most functions don&rsquo;t use. Let&rsquo;s understand each one from the ground up.</p>
<hr>

<h5 class="relative group">1. ALIGNMENT (<code>align</code>) - Memory Layout Control
    <div id="1-alignment-align---memory-layout-control" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#1-alignment-align---memory-layout-control" aria-label="Anchor">#</a>
    </span>
    
</h5>
<p><strong>What is memory alignment?</strong></p>
<p>RAM is organized like a grid. CPUs read memory most efficiently when data starts at addresses that are multiples of certain numbers (2, 4, 8, 16, etc.).</p>
<pre tabindex="0"><code>Memory addresses:
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │  8  │  9  │ 10  │ 11  │ ...
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

4-byte aligned means: starts at 0, 4, 8, 12, 16...  (multiples of 4)
8-byte aligned means: starts at 0, 8, 16, 24...     (multiples of 8)
16-byte aligned means: starts at 0, 16, 32, 48...   (multiples of 16)
</code></pre><p><strong>Why does it matter?</strong></p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ ALIGNED ACCESS (fast):                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ CPU wants to read 4 bytes starting at address 4:                   │
│                                                                     │
│ ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐                  │
│ │  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │                  │
│ └─────┴─────┴─────┴─────┼━━━━━┿━━━━━┿━━━━━┿━━━━━┤                  │
│                         │█████│█████│█████│█████│ ← ONE memory read │
│                         └─────┴─────┴─────┴─────┘                   │
│                                                                     │
│ Result: Single memory access, maximum speed!                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ MISALIGNED ACCESS (slow or crashes):                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ CPU wants to read 4 bytes starting at address 3:                   │
│                                                                     │
│ ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐                  │
│ │  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │                  │
│ └─────┴─────┴─────┼━━━━━┿━━━━━┿━━━━━┿━━━━━┼─────┘                  │
│                   │█████│█████│█████│█████│                         │
│                   └─────┴─────┴─────┴─────┘                         │
│                         ↑           ↑                               │
│                    spans two memory &#34;chunks&#34;                        │
│                                                                     │
│ Result: CPU must do TWO reads and combine them (2x slower)         │
│         On some CPUs: crashes with &#34;bus error&#34;!                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><p><strong>When do you use <code>align()</code> on functions?</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// SIMD (Single Instruction Multiple Data) operations
</span></span></span><span class="line"><span class="cl"><span class="c1">// SSE/AVX instructions require 16/32-byte aligned data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">processVector</span><span class="p">(</span><span class="n">data</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">align</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="kr">align</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// The function code itself is 16-byte aligned in memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// This helps with instruction cache performance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Hot loops that need to be cache-line aligned (64 bytes typically)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">criticalLoop</span><span class="p">()</span><span class="w"> </span><span class="kr">align</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Ensures this function starts at a cache line boundary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Reduces cache misses when calling frequently
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Real-world example:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&#34;std&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Without align: function might start at any address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">normalFunc</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// With align(16): function starts at address divisible by 16
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">alignedFunc</span><span class="p">()</span><span class="w"> </span><span class="kr">align</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="nf">print</span><span class="p">(</span><span class="s">&#34;normalFunc at: {*}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="o">&amp;</span><span class="n">normalFunc</span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Might print: normalFunc at: 0x104a3c7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="nf">print</span><span class="p">(</span><span class="s">&#34;alignedFunc at: {*}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="o">&amp;</span><span class="n">alignedFunc</span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Will print: alignedFunc at: 0x104a3d0  (ends in 0 = divisible by 16)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>

<h5 class="relative group">2. CALLING CONVENTION (<code>callconv</code>) - How Functions Talk to Each Other
    <div id="2-calling-convention-callconv---how-functions-talk-to-each-other" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#2-calling-convention-callconv---how-functions-talk-to-each-other" aria-label="Anchor">#</a>
    </span>
    
</h5>
<p><strong>What is a calling convention?</strong></p>
<p>When you call a function, the CPU needs to know:</p>
<ul>
<li>Where do arguments go? (which registers? the stack?)</li>
<li>Who saves which registers? (caller or callee?)</li>
<li>Where does the return value go?</li>
<li>How do we clean up the stack afterward?</li>
</ul>
<p>Different systems have different rules. That&rsquo;s a &ldquo;calling convention.&rdquo;</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ FUNCTION CALL AT CPU LEVEL                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ High-level code:    result = add(5, 3);                            │
│                                                                     │
│ What actually happens:                                              │
│                                                                     │
│ ┌─────────────────────────────────────────────────────────────────┐│
│ │ CALLER (your code)                                              ││
│ │                                                                 ││
│ │ 1. Put 5 somewhere (register? stack?)    ← WHERE?               ││
│ │ 2. Put 3 somewhere (register? stack?)    ← WHERE?               ││
│ │ 3. Save registers I need later           ← WHICH ONES?          ││
│ │ 4. Jump to add function                                         ││
│ │ 5. Get result from somewhere             ← WHERE?               ││
│ │ 6. Clean up stack                        ← HOW MUCH?            ││
│ └─────────────────────────────────────────────────────────────────┘│
│                          │                                          │
│                          ▼                                          │
│ ┌─────────────────────────────────────────────────────────────────┐│
│ │ CALLEE (add function)                                           ││
│ │                                                                 ││
│ │ 1. Get arguments from somewhere          ← WHERE?               ││
│ │ 2. Save registers I&#39;ll modify            ← WHICH ONES?          ││
│ │ 3. Do the work                                                  ││
│ │ 4. Put result somewhere                  ← WHERE?               ││
│ │ 5. Restore saved registers                                      ││
│ │ 6. Return to caller                                             ││
│ └─────────────────────────────────────────────────────────────────┘│
│                                                                     │
│ The CALLING CONVENTION answers all the &#34;WHERE?&#34; and &#34;WHICH?&#34; questions
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><p><strong>Common calling conventions:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// Default Zig calling convention (optimized, not stable)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">zigFunc</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// - Zig can pass args in any registers it wants
</span></span></span><span class="line"><span class="cl"><span class="c1">// - Can change between compiler versions
</span></span></span><span class="line"><span class="cl"><span class="c1">// - Fastest for Zig-to-Zig calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// C calling convention (stable, cross-language)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">cFunc</span><span class="p">()</span><span class="w"> </span><span class="nf">callconv</span><span class="p">(.</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// - Follows the platform&#39;s C ABI (Application Binary Interface)
</span></span></span><span class="line"><span class="cl"><span class="c1">// - On x86-64 Linux: first 6 int args in rdi, rsi, rdx, rcx, r8, r9
</span></span></span><span class="line"><span class="cl"><span class="c1">// - Required when: calling C libraries, being called from C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Example: Calling a C library function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">extern</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">printf</span><span class="p">(</span><span class="n">format</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="o">*:</span><span class="mi">0</span><span class="p">]</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="nf">callconv</span><span class="p">(.</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="kt">c_int</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Hello from Zig!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="w">  </span><span class="c1">// This works because we matched C&#39;s convention
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>More calling conventions:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// Naked function - NO prologue/epilogue, you control everything
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">nakedFunc</span><span class="p">()</span><span class="w"> </span><span class="nf">callconv</span><span class="p">(.</span><span class="n">naked</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// No automatic stack setup!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// No automatic register saving!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// You must write raw assembly and handle everything yourself
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="kr">volatile</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="sh">\\mov eax, 42</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="sh">\\ret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Used for: bootloaders, context switching, ultra-optimized hot paths
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Interrupt handler - special hardware requirements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">interruptHandler</span><span class="p">()</span><span class="w"> </span><span class="nf">callconv</span><span class="p">(.</span><span class="n">interrupt</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Automatically saves ALL registers (hardware requirement)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Uses special &#39;iret&#39; instruction to return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Stack is set up differently than normal calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Used for: keyboard handlers, timer ticks, exceptions, syscalls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Kernel/System calling convention
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">syscallHandler</span><span class="p">()</span><span class="w"> </span><span class="nf">callconv</span><span class="p">(.</span><span class="n">system</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Uses the system call convention for your OS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Different register usage than .c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Why does this matter?</strong></p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ WITHOUT MATCHING CALLING CONVENTION:                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ C code:        zig_add(5, 3);                                      │
│ C puts:        5 in rdi, 3 in rsi  (C convention)                  │
│                                                                     │
│ Zig code:      fn zig_add(a: i32, b: i32) i32 { return a + b; }    │
│ Zig expects:   a in rax, b in rbx  (Zig convention - hypothetical) │
│                                                                     │
│ Result: Zig reads GARBAGE from rax and rbx!                        │
│         Program crashes or returns wrong answer.                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ WITH MATCHING CALLING CONVENTION:                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ C code:        zig_add(5, 3);                                      │
│ C puts:        5 in rdi, 3 in rsi  (C convention)                  │
│                                                                     │
│ Zig code:      export fn zig_add(a: i32, b: i32) callconv(.c) i32 {│
│                    return a + b;                                   │
│                }                                                    │
│ Zig expects:   a in rdi, b in rsi  (C convention - same!)          │
│                                                                     │
│ Result: Works perfectly! Both sides agree on the rules.            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h5 class="relative group">3. ADDRESS SPACE (<code>addrspace</code>) - Different Types of Memory
    <div id="3-address-space-addrspace---different-types-of-memory" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#3-address-space-addrspace---different-types-of-memory" aria-label="Anchor">#</a>
    </span>
    
</h5>
<p><strong>What is an address space?</strong></p>
<p>Most programs think of memory as one big array. But in reality, computers can have multiple types of memory that work differently:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ SIMPLE VIEW (what most programmers see):                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ ┌─────────────────────────────────────────────────────────────────┐│
│ │                      MEMORY                                     ││
│ │  0x0000 ──────────────────────────────────────────────► 0xFFFF ││
│ │                                                                 ││
│ │  All memory is the same, just different addresses              ││
│ └─────────────────────────────────────────────────────────────────┘│
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ REALITY (GPU / Embedded systems):                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐      │
│ │  GLOBAL MEMORY  │  │  SHARED MEMORY  │  │  LOCAL MEMORY   │      │
│ │                 │  │                 │  │                 │      │
│ │ - Large (GBs)   │  │ - Small (KBs)   │  │ - Per-thread    │      │
│ │ - Slow          │  │ - Very fast     │  │ - Fastest       │      │
│ │ - All threads   │  │ - Per workgroup │  │ - Private       │      │
│ │   can access    │  │   can share     │  │                 │      │
│ └─────────────────┘  └─────────────────┘  └─────────────────┘      │
│                                                                     │
│ SAME address (e.g., 0x1000) means DIFFERENT things in each space! │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><p><strong>GPU example (CUDA/OpenCL):</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// Pointer to global GPU memory (accessible by all threads)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">processData</span><span class="p">(</span><span class="n">data</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="nf">addrspace</span><span class="p">(.</span><span class="n">global</span><span class="p">)</span><span class="w"> </span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// This pointer points to GPU&#39;s main memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Slow to access, but large and shared
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Pointer to shared memory (fast, but small)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">fastProcess</span><span class="p">(</span><span class="n">cache</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="nf">addrspace</span><span class="p">(.</span><span class="n">shared</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// This pointer points to on-chip shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Very fast, but only 48KB typically
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Only threads in same workgroup can see it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Pointer to local memory (per-thread)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">threadLocal</span><span class="p">(</span><span class="n">scratch</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="nf">addrspace</span><span class="p">(.</span><span class="n">local</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// This pointer points to thread-private memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Fastest, but only this thread can access it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Embedded systems example:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// Memory-mapped I/O register (hardware control)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span><span class="w"> </span><span class="n">GPIO_BASE</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="nf">addrspace</span><span class="p">(.</span><span class="n">io</span><span class="p">)</span><span class="w"> </span><span class="kr">volatile</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@ptrFromInt</span><span class="p">(</span><span class="mh">0x4002_0000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Flash memory (read-only, persistent)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span><span class="w"> </span><span class="n">FLASH_START</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="nf">addrspace</span><span class="p">(.</span><span class="n">flash</span><span class="p">)</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@ptrFromInt</span><span class="p">(</span><span class="mh">0x0800_0000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// SRAM (read-write, fast)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span><span class="w"> </span><span class="n">SRAM_START</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="nf">addrspace</span><span class="p">(.</span><span class="n">sram</span><span class="p">)</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@ptrFromInt</span><span class="p">(</span><span class="mh">0x2000_0000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span><span class="w"> </span><span class="nf">blinkLED</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Writing to GPIO register actually controls hardware!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// The address space tells the compiler this is special memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">GPIO_BASE</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w">  </span><span class="c1">// Turn on LED
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Why can&rsquo;t we just use regular pointers?</strong></p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ THE PROBLEM:                                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ // On a GPU, these are DIFFERENT memory locations:                 │
│                                                                     │
│ var globalPtr: *f32 = getGlobalPtr();   // Points to global memory │
│ var sharedPtr: *f32 = getSharedPtr();   // Points to shared memory │
│                                                                     │
│ // But to the CPU/compiler, they look the same - just *f32!        │
│ // If we accidentally pass globalPtr where sharedPtr is expected:  │
│                                                                     │
│ fn needsShared(ptr: *f32) void { ... }                             │
│ needsShared(globalPtr);  // COMPILES! But wrong memory type!       │
│                                                                     │
│ // GPU will crash or produce garbage results                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ THE SOLUTION - Address Spaces:                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ var globalPtr: *addrspace(.global) f32 = getGlobalPtr();           │
│ var sharedPtr: *addrspace(.shared) f32 = getSharedPtr();           │
│                                                                     │
│ fn needsShared(ptr: *addrspace(.shared) f32) void { ... }          │
│ needsShared(globalPtr);  // COMPILE ERROR! Type mismatch!          │
│ needsShared(sharedPtr);  // OK                                      │
│                                                                     │
│ The compiler catches the bug at compile time!                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h5 class="relative group">4. LINKER SECTION (<code>linksection</code>) - Where Code Lives in the Binary
    <div id="4-linker-section-linksection---where-code-lives-in-the-binary" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#4-linker-section-linksection---where-code-lives-in-the-binary" aria-label="Anchor">#</a>
    </span>
    
</h5>
<p><strong>What is linking?</strong></p>
<p>After the compiler creates object files, the linker combines them into an executable. The linker organizes the binary into &ldquo;sections&rdquo;:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ EXECUTABLE FILE LAYOUT:                                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ ┌─────────────────────────────────────┐                            │
│ │           HEADERS                    │  Metadata about the file  │
│ ├─────────────────────────────────────┤                            │
│ │                                     │                            │
│ │           .text                     │  Executable code           │
│ │     (your functions live here)      │  Read-only, executable     │
│ │                                     │                            │
│ ├─────────────────────────────────────┤                            │
│ │                                     │                            │
│ │           .rodata                   │  Read-only data            │
│ │     (string literals, constants)    │  Read-only, not executable │
│ │                                     │                            │
│ ├─────────────────────────────────────┤                            │
│ │                                     │                            │
│ │           .data                     │  Initialized variables     │
│ │     (var x: i32 = 42;)             │  Read-write                │
│ │                                     │                            │
│ ├─────────────────────────────────────┤                            │
│ │                                     │                            │
│ │           .bss                      │  Uninitialized variables   │
│ │     (var y: i32 = undefined;)      │  Read-write, zeroed        │
│ │                                     │                            │
│ └─────────────────────────────────────┘                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><p><strong>Special sections you might need:</strong></p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ SPECIAL SECTIONS AND THEIR PURPOSES:                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ .init      Code that runs BEFORE main()                            │
│            Used for: C runtime setup, static constructors          │
│                                                                     │
│ .fini      Code that runs AFTER main() returns                     │
│            Used for: Cleanup, static destructors                    │
│                                                                     │
│ .vectors   Interrupt vector table (embedded)                       │
│            Must be at specific address (often 0x0000)              │
│                                                                     │
│ .ramfunc   Code that runs from RAM instead of flash (embedded)     │
│            Used for: Flash programming (can&#39;t run from flash       │
│            while erasing it!)                                       │
│                                                                     │
│ .bootloader  Bootloader code, often at fixed address               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><p><strong>Real examples:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// 1. STARTUP CODE - Must run before anything else
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">initializeHardware</span><span class="p">()</span><span class="w"> </span><span class="kr">linksection</span><span class="p">(</span><span class="s">&#34;.init&#34;</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Set up clocks, memory controllers, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// This runs automatically before main()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 2. INTERRUPT VECTOR TABLE - Must be at address 0x0000 on ARM Cortex-M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span><span class="w"> </span><span class="n">vector_table</span><span class="w"> </span><span class="kr">linksection</span><span class="p">(</span><span class="s">&#34;.vectors&#34;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="o">?*</span><span class="kr">const</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">resetHandler</span><span class="p">,</span><span class="w">      </span><span class="c1">// 0x00: Reset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">nmiHandler</span><span class="p">,</span><span class="w">        </span><span class="c1">// 0x04: NMI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">hardFaultHandler</span><span class="p">,</span><span class="w">  </span><span class="c1">// 0x08: Hard Fault
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// ... etc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 3. CODE THAT RUNS FROM RAM - For flash programming
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">eraseFlashPage</span><span class="p">(</span><span class="n">page</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="kr">linksection</span><span class="p">(</span><span class="s">&#34;.ramfunc&#34;</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// This function is copied to RAM at startup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// It can run while we&#39;re erasing flash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// (Can&#39;t execute code from flash while erasing it!)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 4. DATA AT SPECIFIC ADDRESS - For bootloader handoff
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">var</span><span class="w"> </span><span class="n">sharedData</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="kr">linksection</span><span class="p">(</span><span class="s">&#34;.shared_ram&#34;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Bootloader and app both know this address
</span></span></span><span class="line"><span class="cl"><span class="c1">// Used to pass data between them
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Linker script connection:</strong></p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ HOW IT WORKS TOGETHER:                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ Your Zig code:                                                      │
│ ┌───────────────────────────────────────────────────────────────┐  │
│ │ fn startup() linksection(&#34;.init&#34;) void { ... }                │  │
│ └───────────────────────────────────────────────────────────────┘  │
│                          │                                          │
│                          ▼                                          │
│ Linker script (link.ld):                                           │
│ ┌───────────────────────────────────────────────────────────────┐  │
│ │ SECTIONS {                                                     │  │
│ │     .init 0x08000000 : {   /* Flash start on STM32 */         │  │
│ │         *(.init)            /* Put all .init stuff here */    │  │
│ │     }                                                          │  │
│ │     .text : {                                                  │  │
│ │         *(.text)            /* Regular code after init */     │  │
│ │     }                                                          │  │
│ │ }                                                              │  │
│ └───────────────────────────────────────────────────────────────┘  │
│                          │                                          │
│                          ▼                                          │
│ Final binary:                                                       │
│ ┌───────────────────────────────────────────────────────────────┐  │
│ │ Address 0x08000000:  startup() code                           │  │
│ │ Address 0x08000100:  main() and other functions               │  │
│ └───────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h5 class="relative group">Summary: When You&rsquo;ll Use Each
    <div id="summary-when-youll-use-each" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#summary-when-youll-use-each" aria-label="Anchor">#</a>
    </span>
    
</h5>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│                    WHEN TO USE EACH ATTRIBUTE                        │
├──────────────┬──────────────────────────────────────────────────────┤
│              │                                                      │
│   align()    │ • SIMD code (SSE, AVX, NEON)                        │
│              │ • Cache optimization (hot loops)                    │
│              │ • Memory-mapped I/O with alignment requirements     │
│              │ • DMA buffers                                        │
│              │                                                      │
├──────────────┼──────────────────────────────────────────────────────┤
│              │                                                      │
│  callconv()  │ • Calling C libraries (use .c)                      │
│              │ • Being called FROM C (use .c + export)             │
│              │ • Interrupt handlers (use .interrupt)               │
│              │ • Bootloaders/kernels (use .naked)                  │
│              │ • System calls (use .system)                        │
│              │                                                      │
├──────────────┼──────────────────────────────────────────────────────┤
│              │                                                      │
│ addrspace()  │ • GPU programming (CUDA, OpenCL, Vulkan compute)    │
│              │ • Embedded with multiple memory regions              │
│              │ • Memory-mapped I/O registers                        │
│              │ • Harvard architecture (separate code/data memory)  │
│              │                                                      │
├──────────────┼──────────────────────────────────────────────────────┤
│              │                                                      │
│ linksection()│ • Embedded startup code                             │
│              │ • Interrupt vector tables                            │
│              │ • Bootloaders                                        │
│              │ • Self-modifying code (must be in RAM)               │
│              │ • Shared memory between processes                    │
│              │                                                      │
└──────────────┴──────────────────────────────────────────────────────┘
</code></pre><hr>
<p>Now let&rsquo;s see the simple version again:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// Simple function (most common) - NO optional expressions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Function with ALIGNMENT
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">aligned</span><span class="p">()</span><span class="w"> </span><span class="kr">align</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Function with CALLING CONVENTION
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">cFunc</span><span class="p">()</span><span class="w"> </span><span class="nf">callconv</span><span class="p">(.</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Function with ADDRESS SPACE (rare, usually on pointers not functions)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">gpuFunc</span><span class="p">()</span><span class="w"> </span><span class="nf">addrspace</span><span class="p">(.</span><span class="n">global</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Function with LINKER SECTION
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">initFunc</span><span class="p">()</span><span class="w"> </span><span class="kr">linksection</span><span class="p">(</span><span class="s">&#34;.init&#34;</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Function with MULTIPLE attributes (very rare!)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">complex</span><span class="p">()</span><span class="w"> </span><span class="kr">align</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="nf">callconv</span><span class="p">(.</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="kr">linksection</span><span class="p">(</span><span class="s">&#34;.special&#34;</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Statistics from real codebases:</strong></p>
<pre tabindex="0"><code>┌────────────────────────────────────────────────────────────────┐
│ Analysis of ~10,000 functions in typical Zig projects:         │
├────────────────────────────────────────────────────────────────┤
│ No optional expressions:     ~95%   (simple functions)         │
│ Has callconv only:           ~3%    (C interop code)           │
│ Has align only:              ~1%    (SIMD, memory-mapped I/O)  │
│ Has linksection only:        ~0.5%  (embedded, bootloaders)    │
│ Has multiple attributes:     ~0.5%  (very specialized code)    │
└────────────────────────────────────────────────────────────────┘
</code></pre><p>This is why optimizing for the common case matters so much!</p>

<h4 class="relative group">The Problem: Variable-Size Data
    <div id="the-problem-variable-size-data" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-problem-variable-size-data" aria-label="Anchor">#</a>
    </span>
    
</h4>
<p>A function prototype can have:</p>
<ul>
<li>0 parameters, 1 parameter, or many parameters</li>
<li>Optional alignment expression</li>
<li>Optional calling convention</li>
<li>Optional address space</li>
<li>Optional linker section</li>
</ul>
<p>Storing ALL of these for EVERY function would waste memory. Most functions are simple!</p>
<p><strong>The Solution: Multiple Node Variants</strong></p>
<pre tabindex="0"><code>┌────────────────────────────────────────────────────────────────────┐
│                    FUNCTION PROTOTYPE VARIANTS                      │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  fn_proto_simple    (most common - ~80% of functions)              │
│  ─────────────────────────────────────────────────                 │
│  • 0 or 1 parameters                                               │
│  • No alignment, callconv, addrspace, section                      │
│  • Everything fits in the 8-byte Data field!                       │
│  • NO extra_data allocation needed                                 │
│                                                                     │
│  fn_proto_multi     (common - ~15% of functions)                   │
│  ─────────────────────────────────────────────────                 │
│  • 2+ parameters                                                   │
│  • No alignment, callconv, addrspace, section                      │
│  • Params stored in extra_data, but nothing else                   │
│                                                                     │
│  fn_proto_one       (rare - ~4% of functions)                      │
│  ─────────────────────────────────────────────────                 │
│  • 0 or 1 parameters                                               │
│  • HAS alignment/callconv/addrspace/section                        │
│  • Uses extra_data for the optional expressions                    │
│                                                                     │
│  fn_proto           (very rare - ~1% of functions)                 │
│  ─────────────────────────────────────────────────                 │
│  • 2+ parameters AND optional expressions                          │
│  • Full extra_data usage                                           │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
</code></pre><p><strong>The Decision Tree:</strong></p>
<pre tabindex="0"><code>                        Does it have align/callconv/
                        addrspace/section expressions?
                                   │
                    ┌──────────────┴──────────────┐
                    │ NO                          │ YES
                    ▼                             ▼
            How many params?              How many params?
                    │                             │
           ┌───────┴───────┐             ┌───────┴───────┐
           │ 0-1           │ 2+          │ 0-1           │ 2+
           ▼               ▼             ▼               ▼
    fn_proto_simple   fn_proto_multi  fn_proto_one   fn_proto
    (MOST COMPACT)                    (uses extra)  (MOST COMPLEX)
</code></pre><p><strong>Code That Makes The Decision:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// Choose node variant based on complexity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">align_expr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">section_expr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="k">and</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">callconv_expr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">addrspace_expr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Simple case: no extra expressions needed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">zero_or_one</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">param</span><span class="o">|</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">setNode</span><span class="p">(</span><span class="n">fn_proto_index</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">fn_proto_simple</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">opt_node_and_opt_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="n">param</span><span class="p">,</span><span class="w"> </span><span class="n">return_type</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Everything fits in 8 bytes! No extra_data needed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">multi</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">span</span><span class="o">|</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">setNode</span><span class="p">(</span><span class="n">fn_proto_index</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">fn_proto_multi</span><span class="p">,</span><span class="w">  </span><span class="c1">// ← Our example uses this (2 params)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">extra_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">span</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Only params go to extra_data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Complex case: need to store optional expressions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">zero_or_one</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">param</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// fn_proto_one: store extras in extra_data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="kr">const</span><span class="w"> </span><span class="n">extra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">addExtra</span><span class="p">(</span><span class="n">FnProtoOne</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">return_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">return_type</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">align_expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">align_expr</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">addrspace_expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addrspace_expr</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">section_expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">section_expr</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">callconv_expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">callconv_expr</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">setNode</span><span class="p">(</span><span class="n">fn_proto_index</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">fn_proto_one</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">node_and_extra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="n">param</span><span class="p">,</span><span class="w"> </span><span class="n">extra</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">multi</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">span</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// fn_proto: full complexity, everything in extra_data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="c1">// ... similar but with param range
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Memory Impact Example:</strong></p>
<pre tabindex="0"><code>Function: fn add(a: u32, b: u32) u32 { ... }

With fn_proto_multi (what we use):
┌─────────────────────────────────────────────────────────────────┐
│ Node (13 bytes):                                                │
│   tag: .fn_proto_multi                                          │
│   main_token: 1 (&#34;fn&#34;)                                          │
│   data: { start: 0, end: 2 }  // range into extra_data          │
├─────────────────────────────────────────────────────────────────┤
│ extra_data (8 bytes):                                           │
│   [0]: param_node_a                                             │
│   [1]: param_node_b                                             │
├─────────────────────────────────────────────────────────────────┤
│ TOTAL: 21 bytes                                                 │
└─────────────────────────────────────────────────────────────────┘

If we used fn_proto (full variant) for EVERYTHING:
┌─────────────────────────────────────────────────────────────────┐
│ Node (13 bytes):                                                │
│   tag: .fn_proto                                                │
│   main_token: 1                                                 │
│   data: { extra_index }                                         │
├─────────────────────────────────────────────────────────────────┤
│ extra_data (24 bytes):                                          │
│   [0]: params_start                                             │
│   [1]: params_end                                               │
│   [2]: align_expr (null)      ← wasted!                         │
│   [3]: addrspace_expr (null)  ← wasted!                         │
│   [4]: section_expr (null)    ← wasted!                         │
│   [5]: callconv_expr (null)   ← wasted!                         │
├─────────────────────────────────────────────────────────────────┤
│ TOTAL: 37 bytes (76% more memory!)                              │
└─────────────────────────────────────────────────────────────────┘
</code></pre><p><strong>Why This Matters At Scale:</strong></p>
<pre tabindex="0"><code>Parsing Zig&#39;s standard library (~500,000 lines):
┌──────────────────────────────────────────────────────────────────┐
│ Estimated function count: ~15,000 functions                      │
│                                                                  │
│ With smart variants:                                             │
│   ~12,000 × fn_proto_simple (21 bytes)  = 252,000 bytes          │
│   ~2,500  × fn_proto_multi  (25 bytes)  =  62,500 bytes          │
│   ~500    × fn_proto_one/full (37 bytes)=  18,500 bytes          │
│   TOTAL: ~333 KB                                                 │
│                                                                  │
│ If everything used fn_proto:                                     │
│   ~15,000 × 37 bytes = 555 KB                                    │
│                                                                  │
│ SAVINGS: 222 KB (40% reduction!) just for function nodes         │
└──────────────────────────────────────────────────────────────────┘
</code></pre><p>This pattern repeats across the AST: blocks, calls, if statements, loops - all have optimized variants for common cases.</p>

<h4 class="relative group">Step-by-Step: How The Parser Collects Data
    <div id="step-by-step-how-the-parser-collects-data" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#step-by-step-how-the-parser-collects-data" aria-label="Anchor">#</a>
    </span>
    
</h4>
<p>Let&rsquo;s trace exactly what happens when parsing <code>fn add(a: u32, b: u32) u32</code>:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ PHASE 1: Parse and Collect                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Parser state as we go:                                               │
│                                                                      │
│ Tokens: [fn] [add] [(] [a] [:] [u32] [,] [b] [:] [u32] [)] [u32] ... │
│          ↑                                                           │
│ 1. See &#34;fn&#34; → start parsing function prototype                      │
│    align_expr = null                                                 │
│    callconv_expr = null                                              │
│    addrspace_expr = null                                             │
│    section_expr = null                                               │
│                                                                      │
│ Tokens: [fn] [add] [(] [a] [:] [u32] [,] [b] [:] [u32] [)] [u32] ... │
│               ↑                                                      │
│ 2. Consume &#34;add&#34; → function name (main_token = 1)                   │
│                                                                      │
│ Tokens: [fn] [add] [(] [a] [:] [u32] [,] [b] [:] [u32] [)] [u32] ... │
│                    ↑                                                 │
│ 3. See &#34;(&#34; → start parameter list                                   │
│    scratch buffer: []  (empty)                                       │
│                                                                      │
│ 4. Parse first parameter &#34;a: u32&#34;                                   │
│    Create param node, add index to scratch buffer                   │
│    scratch buffer: [node_3]                                          │
│                                                                      │
│ 5. See &#34;,&#34; → more parameters coming                                 │
│                                                                      │
│ 6. Parse second parameter &#34;b: u32&#34;                                  │
│    Create param node, add index to scratch buffer                   │
│    scratch buffer: [node_3, node_4]                                  │
│                                                                      │
│ 7. See &#34;)&#34; → end of parameters                                      │
│    param_count = 2                                                   │
│                                                                      │
│ Tokens: [fn] [add] [(] [a] [:] [u32] [,] [b] [:] [u32] [)] [u32] ... │
│                                                                ↑     │
│ 8. Parse return type &#34;u32&#34;                                          │
│    return_type = node_5 (identifier &#34;u32&#34;)                          │
│                                                                      │
│ 9. Check for optional attributes:                                   │
│    See &#34;align&#34;? NO                                                  │
│    See &#34;callconv&#34;? NO                                               │
│    See &#34;addrspace&#34;? NO                                              │
│    See &#34;linksection&#34;? NO                                            │
│    All optional expressions remain null!                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ PHASE 2: Make The Decision                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Current state:                                                       │
│   align_expr = null                                                  │
│   callconv_expr = null                                               │
│   addrspace_expr = null                                              │
│   section_expr = null                                                │
│   param_count = 2                                                    │
│   scratch buffer = [node_3, node_4]                                  │
│                                                                      │
│ Decision process:                                                    │
│                                                                      │
│   if (align_expr == null AND                                        │
│       callconv_expr == null AND                                     │
│       addrspace_expr == null AND                                    │
│       section_expr == null) {                                       │
│       // YES! All are null ✓                                        │
│                                                                      │
│       if (param_count &lt;= 1) {                                       │
│           // NO, we have 2 params                                   │
│           use fn_proto_simple                                        │
│       } else {                                                       │
│           // YES! 2+ params ✓                                       │
│           use fn_proto_multi  ← THIS ONE!                           │
│       }                                                              │
│   }                                                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ PHASE 3: Create The Node                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. Copy params from scratch buffer to extra_data:                   │
│                                                                      │
│    extra_data before: [...]                                          │
│    extra_data after:  [..., node_3, node_4]                          │
│                             ↑       ↑                                │
│                           idx 10  idx 11                             │
│                                                                      │
│ 2. Create the fn_proto_multi node:                                  │
│                                                                      │
│    ┌────────────────────────────────────────────────────────────┐   │
│    │ Node {                                                      │   │
│    │   tag: .fn_proto_multi,                                    │   │
│    │   main_token: 1,  // points to &#34;add&#34; token                 │   │
│    │   data: .extra_range = {                                   │   │
│    │       start: 10,  // first param at extra_data[10]         │   │
│    │       end: 12,    // exclusive, so params are [10, 11]     │   │
│    │   }                                                         │   │
│    │ }                                                           │   │
│    └────────────────────────────────────────────────────────────┘   │
│                                                                      │
│ 3. Return type is stored separately (in the node&#39;s extra data)     │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h4 class="relative group">The Scratch Buffer Explained
    <div id="the-scratch-buffer-explained" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-scratch-buffer-explained" aria-label="Anchor">#</a>
    </span>
    
</h4>
<p>The parser uses a temporary &ldquo;scratch buffer&rdquo; to collect items before knowing how many there will be:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">Parse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ... other fields ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">scratch</span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="nf">ArrayList</span><span class="p">(</span><span class="n">Node</span><span class="p">.</span><span class="n">Index</span><span class="p">),</span><span class="w">  </span><span class="c1">// Temporary workspace
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Why a scratch buffer?</strong></p>
<pre tabindex="0"><code>Problem: We don&#39;t know how many parameters until we see &#34;)&#34;

  fn foo( ??? ) ...
          ↑
          Could be 0, 1, 2, 10, 100 parameters!

Solution: Collect into scratch buffer, then copy to extra_data

  1. Parse each param → append to scratch
  2. See &#34;)&#34; → we now know the count!
  3. Copy scratch[start..end] to extra_data
  4. Store the range in the node
  5. Clear scratch (ready for next use)
</code></pre><pre tabindex="0"><code>┌────────────────────────────────────────────────────────────────────┐
│                    SCRATCH BUFFER LIFECYCLE                         │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Start parsing fn add(a: u32, b: u32):                             │
│                                                                     │
│  scratch: [ ]                          // empty                    │
│           ↑ scratch_top = 0                                        │
│                                                                     │
│  After parsing param &#34;a&#34;:                                          │
│                                                                     │
│  scratch: [ node_3 ]                                               │
│                    ↑ scratch_top = 1                               │
│                                                                     │
│  After parsing param &#34;b&#34;:                                          │
│                                                                     │
│  scratch: [ node_3, node_4 ]                                       │
│                           ↑ scratch_top = 2                        │
│                                                                     │
│  See &#34;)&#34; - done with params:                                       │
│                                                                     │
│  extra_data: [..., node_3, node_4 ]                                │
│                    ↑              ↑                                │
│               start=10        end=12                                │
│                                                                     │
│  scratch: [ node_3, node_4 ]   // still has data, but...          │
│           ↑ scratch_top = 0     // reset for next use!             │
│                                                                     │
│  The scratch buffer is reused for the next list we need to parse!  │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
</code></pre>
<h4 class="relative group">Why Not Just Use <code>ArrayList</code> Directly?
    <div id="why-not-just-use-arraylist-directly" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-not-just-use-arraylist-directly" aria-label="Anchor">#</a>
    </span>
    
</h4>
<p>You might wonder: why have both scratch buffer AND extra_data?</p>
<pre tabindex="0"><code>┌────────────────────────────────────────────────────────────────────┐
│ Option A: Store param list directly in ArrayList (BAD)             │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ Node {                                                              │
│   tag: .fn_proto,                                                  │
│   params: ArrayList(Node.Index),  // POINTER to heap allocation!   │
│ }                                                                   │
│                                                                     │
│ Problems:                                                           │
│ - Each ArrayList has overhead (pointer + length + capacity)        │
│ - Thousands of tiny heap allocations                               │
│ - Poor cache locality (params scattered in memory)                 │
│ - Node size becomes variable                                       │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────┐
│ Option B: Use shared extra_data array (GOOD - what Zig does)       │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ Node {                                                              │
│   tag: .fn_proto_multi,                                            │
│   data: { start: 10, end: 12 },  // Just two integers!             │
│ }                                                                   │
│                                                                     │
│ Benefits:                                                           │
│ - Fixed-size nodes (always 13 bytes)                               │
│ - Single contiguous extra_data array                               │
│ - Great cache locality                                             │
│ - One large allocation instead of many small ones                  │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
</code></pre>
<h4 class="relative group">Complete Node Selection Table
    <div id="complete-node-selection-table" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#complete-node-selection-table" aria-label="Anchor">#</a>
    </span>
    
</h4>
<p>Here&rsquo;s every function prototype variant with examples:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────────┐
│ VARIANT           │ PARAMS │ EXTRAS │ EXAMPLE                          │
├───────────────────┼────────┼────────┼──────────────────────────────────┤
│                   │        │        │                                  │
│ fn_proto_simple   │  0     │  none  │ fn foo() void {}                 │
│                   │        │        │                                  │
│ fn_proto_simple   │  1     │  none  │ fn bar(x: u32) u32 {}            │
│                   │        │        │                                  │
│ fn_proto_multi    │  2+    │  none  │ fn add(a: u32, b: u32) u32 {}    │
│                   │        │        │                                  │
│ fn_proto_one      │  0     │  some  │ fn init() callconv(.c) void {}   │
│                   │        │        │                                  │
│ fn_proto_one      │  1     │  some  │ fn isr(ctx: *Ctx)                │
│                   │        │        │     callconv(.interrupt) void {} │
│                   │        │        │                                  │
│ fn_proto          │  2+    │  some  │ fn simd(a: @Vector, b: @Vector)  │
│                   │        │        │     align(32) @Vector {}         │
│                   │        │        │                                  │
└─────────────────────────────────────────────────────────────────────────┘

Data storage for each:

fn_proto_simple:   data = { param_or_null, return_type }     // All in 8 bytes!
fn_proto_multi:    data = { params_start, params_end }       // Points to extra_data
fn_proto_one:      data = { param_or_null, extra_index }     // Extras in extra_data
fn_proto:          data = { extra_index }                    // Everything in extra_data
</code></pre>
<h3 class="relative group">Step 6: Parse Block Body
    <div id="step-6-parse-block-body" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#step-6-parse-block-body" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>parseBlock() called

Tokens: [{] [return] [a] [+] [b] [;] [}]
         ↑

See &#34;{&#34;? Yes!

Parse statements:
  - parseStatement() finds &#34;return&#34;
  - parseReturnExpr() parses &#34;a + b&#34;
    - This uses precedence climbing!
  - Expect &#34;;&#34; → found

See &#34;}&#34;? Yes → block complete

Only 1 statement → use block_two variant (optimized!)
</code></pre>
<h3 class="relative group">Final AST Structure
    <div id="final-ast-structure" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#final-ast-structure" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>                    root (node 0)
                      │
                   fn_decl (node 1)
                   /      \
        fn_proto_multi    block_two
            (node 2)       (node 8)
           /   |   \           │
      param  param  u32     return
      (3)    (4)    (5)      (9)
      / \    / \               │
     a  u32 b  u32           add
        (6)    (7)           (10)
                            /    \
                       ident    ident
                        (11)     (12)
                         &#34;a&#34;      &#34;b&#34;
</code></pre><hr>

<h2 class="relative group">Extra Data Storage
    <div id="extra-data-storage" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#extra-data-storage" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>When node data exceeds 8 bytes, it goes to <code>extra_data</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">SubRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">start</span><span class="o">:</span><span class="w"> </span><span class="n">ExtraIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">end</span><span class="o">:</span><span class="w"> </span><span class="n">ExtraIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span><span class="w"> </span><span class="nf">addExtra</span><span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Parse</span><span class="p">,</span><span class="w"> </span><span class="n">extra</span><span class="o">:</span><span class="w"> </span><span class="n">anytype</span><span class="p">)</span><span class="w"> </span><span class="n">Allocator</span><span class="p">.</span><span class="n">Error</span><span class="o">!</span><span class="n">ExtraIndex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">meta</span><span class="p">.</span><span class="nf">fields</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">extra</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">extra_data</span><span class="p">.</span><span class="nf">ensureUnusedCapacity</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">gpa</span><span class="p">,</span><span class="w"> </span><span class="n">fields</span><span class="p">.</span><span class="n">len</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="n">ExtraIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@enumFromInt</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">extra_data</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">len</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">fields</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">field</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">data</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="kt">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Node</span><span class="p">.</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w"> </span><span class="n">OptionalTokenIndex</span><span class="p">,</span><span class="w"> </span><span class="n">ExtraIndex</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="nb">@field</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="p">.</span><span class="n">name</span><span class="p">)),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">TokenIndex</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">@field</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="p">.</span><span class="n">name</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">@compileError</span><span class="p">(</span><span class="s">&#34;unexpected field type&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">extra_data</span><span class="p">.</span><span class="nf">appendAssumeCapacity</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Visualizing Extra Data
    <div id="visualizing-extra-data" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visualizing-extra-data" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Scenario: A block with 5 statements

Node can only store 8 bytes (2 indices).
How do we store 5 statement indices?

Solution: Store a RANGE pointing to extra_data

┌─────────────────────────────────────────────────────────────┐
│  nodes array:                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ...  │ block_node                              │ ... │   │
│  │      │ tag: .block                             │     │   │
│  │      │ data: { start: 10, end: 15 }  ─────────┼──┐  │   │
│  └──────┴────────────────────────────────────────┴──┼──┘   │
│                                                     │      │
└─────────────────────────────────────────────────────┼──────┘
                                                      │
┌─────────────────────────────────────────────────────┼──────┐
│  extra_data array:                                  ▼      │
│  ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐ │
│  │ ...│ ...│ ...│ ...│stmt│stmt│stmt│stmt│stmt│ ...│ ...│ │
│  │    │    │    │    │ 0  │ 1  │ 2  │ 3  │ 4  │    │    │ │
│  └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘ │
│                        ↑                       ↑           │
│                      index 10               index 15       │
│                       start                   end          │
└────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Extra Data Structures
    <div id="extra-data-structures" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#extra-data-structures" aria-label="Anchor">#</a>
    </span>
    
</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">GlobalVarDecl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">type_node</span><span class="o">:</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">align_node</span><span class="o">:</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">addrspace_node</span><span class="o">:</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">section_node</span><span class="o">:</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">FnProto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">params_start</span><span class="o">:</span><span class="w"> </span><span class="n">ExtraIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">params_end</span><span class="o">:</span><span class="w"> </span><span class="n">ExtraIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">align_expr</span><span class="o">:</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">addrspace_expr</span><span class="o">:</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">section_expr</span><span class="o">:</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">callconv_expr</span><span class="o">:</span><span class="w"> </span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">then_expr</span><span class="o">:</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">else_expr</span><span class="o">:</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>

<h2 class="relative group">Error Recovery: Don&rsquo;t Stop at First Error
    <div id="error-recovery-dont-stop-at-first-error" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#error-recovery-dont-stop-at-first-error" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>The parser can recover from errors and report multiple issues:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">fn</span><span class="w"> </span><span class="nf">expectStatementRecoverable</span><span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Parse</span><span class="p">)</span><span class="w"> </span><span class="n">Error</span><span class="o">!?</span><span class="n">Node</span><span class="p">.</span><span class="n">Index</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">expectStatement</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">error</span><span class="p">.</span><span class="n">OutOfMemory</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">OutOfMemory</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">error</span><span class="p">.</span><span class="n">ParseError</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">p</span><span class="p">.</span><span class="nf">findNextStmt</span><span class="p">();</span><span class="w">  </span><span class="c1">// Skip to next statement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="nf">tokenTag</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">tok_i</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">r_brace</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">eof</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">ParseError</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span><span class="w"> </span><span class="nf">findNextStmt</span><span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Parse</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">level</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">nextToken</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="nf">tokenTag</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">l_brace</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">r_brace</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">p</span><span class="p">.</span><span class="n">tok_i</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">level</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">semicolon</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">eof</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">p</span><span class="p">.</span><span class="n">tok_i</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Visualizing Error Recovery
    <div id="visualizing-error-recovery" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visualizing-error-recovery" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Source with errors:
┌─────────────────────────────────────────────────────────────┐
│ fn broken() {                                               │
│     const x =      // ERROR: missing expression             │
│     const y = 5;   // This should still parse!              │
│     return y;                                               │
│ }                                                           │
└─────────────────────────────────────────────────────────────┘

Without recovery:
  Parser stops at first error. Only reports &#34;missing expression&#34;.

With recovery:
┌─────────────────────────────────────────────────────────────┐
│ 1. Try to parse &#34;const x =&#34;                                 │
│ 2. ERROR: missing expression after &#34;=&#34;                      │
│ 3. Call findNextStmt() - skip until &#34;;&#34;                     │
│ 4. Continue parsing from &#34;const y = 5;&#34;                     │
│ 5. Successfully parse &#34;const y = 5;&#34;                        │
│ 6. Successfully parse &#34;return y;&#34;                           │
│                                                             │
│ Reports error but also builds partial AST!                  │
└─────────────────────────────────────────────────────────────┘

The `findNextStmt` algorithm:

Tokens: const x = [???] const y = 5 ; return y ; }
                   ↑
                   Error here!

Step 1: level=0, look for &#34;;&#34; or matching &#34;}&#34;
Step 2: Skip unknown tokens...
Step 3: Found &#34;;&#34; at level=0 → stop here!

Tokens: const x = [???] const y = 5 ; return y ; }
                                    ↑
                                    Resume here
</code></pre><hr>

<h2 class="relative group">Token Consumption Patterns
    <div id="token-consumption-patterns" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#token-consumption-patterns" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>The parser uses helper functions to consume tokens:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// Try to eat a token (returns null if not matched)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">eatToken</span><span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Parse</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="o">:</span><span class="w"> </span><span class="n">Token</span><span class="p">.</span><span class="n">Tag</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="n">TokenIndex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="nf">tokenTag</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">tok_i</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">nextToken</span><span class="p">()</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Expect a token (reports error if not matched)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span><span class="w"> </span><span class="nf">expectToken</span><span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Parse</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="o">:</span><span class="w"> </span><span class="n">Token</span><span class="p">.</span><span class="n">Tag</span><span class="p">)</span><span class="w"> </span><span class="n">Error</span><span class="o">!</span><span class="n">TokenIndex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="nf">tokenTag</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">tok_i</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">failMsg</span><span class="p">(.{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">expected_token</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">tok_i</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">extra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">expected_tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="nf">nextToken</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span><span class="w"> </span><span class="nf">nextToken</span><span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Parse</span><span class="p">)</span><span class="w"> </span><span class="n">TokenIndex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">tok_i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">tok_i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Visual: eat vs expect
    <div id="visual-eat-vs-expect" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visual-eat-vs-expect" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Scenario: Parsing optional trailing comma

fn parseList(p: *Parse) !void {
    // ... parse items ...

    // Trailing comma is optional
    _ = p.eatToken(.comma);  // If not there, no error!

    // Closing bracket is required
    _ = try p.expectToken(.r_bracket);  // Error if missing!
}

┌──────────────────────────────────────────────────────────┐
│ eatToken(.comma)                                         │
│                                                          │
│ Input: [1, 2, 3]   →  comma not there, returns null     │
│                 ↑      (no error, continue parsing)      │
│                                                          │
│ Input: [1, 2, 3,]  →  comma found! returns token index  │
│                 ↑      (consumed and continue)           │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│ expectToken(.r_bracket)                                  │
│                                                          │
│ Input: [1, 2, 3]   →  &#34;]&#34; found! returns token index    │
│                 ↑                                        │
│                                                          │
│ Input: [1, 2, 3    →  ERROR: expected &#34;]&#34;               │
│                 ↑      (reports error, may recover)      │
└──────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Memory Efficiency: The Numbers
    <div id="memory-efficiency-the-numbers" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#memory-efficiency-the-numbers" aria-label="Anchor">#</a>
    </span>
    
</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="c1">// From Ast.parse():
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Empirically, Zig source has 8:1 ratio of bytes to tokens
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span><span class="w"> </span><span class="n">estimated_token_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="nf">ensureTotalCapacity</span><span class="p">(</span><span class="n">gpa</span><span class="p">,</span><span class="w"> </span><span class="n">estimated_token_count</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Empirically, Zig source has 2:1 ratio of tokens to nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span><span class="w"> </span><span class="n">estimated_node_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="nf">ensureTotalCapacity</span><span class="p">(</span><span class="n">gpa</span><span class="p">,</span><span class="w"> </span><span class="n">estimated_node_count</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Real-World Example
    <div id="real-world-example" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#real-world-example" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Parsing a 10,000 byte source file:

┌─────────────────────────────────────────────────────────────┐
│ Source Size:     10,000 bytes                               │
├─────────────────────────────────────────────────────────────┤
│ Estimated Tokens: 10,000 / 8 = 1,250 tokens                 │
│ Token Size:       8 bytes each (start, end)                 │
│ Token Memory:     1,250 × 8 = 10,000 bytes                  │
├─────────────────────────────────────────────────────────────┤
│ Estimated Nodes:  1,250 / 2 = 625 nodes                     │
│ Node Size:        13 bytes each                             │
│ Node Memory:      625 × 13 = 8,125 bytes                    │
├─────────────────────────────────────────────────────────────┤
│ Extra Data:       ~2,000 bytes (estimate)                   │
├─────────────────────────────────────────────────────────────┤
│ TOTAL AST:        ~20,000 bytes                             │
│                   = 2× source size                          │
│                                                             │
│ Compare to typical AST implementations:                     │
│   - With per-node allocations: ~100,000+ bytes              │
│   - With pointer-heavy trees: ~50,000+ bytes                │
│                                                             │
│ Zig&#39;s AST is 2.5-5× more memory efficient!                  │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Why It&rsquo;s Efficient
    <div id="why-its-efficient" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-its-efficient" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────┐
│ 1. Compact nodes (13 bytes)                                 │
│    - Tag: 1 byte (not 8 for enum pointer)                   │
│    - Indices: 4 bytes (not 8-byte pointers)                 │
│    - Data union: reuses space for different node types      │
├─────────────────────────────────────────────────────────────┤
│ 2. Zero-copy source                                         │
│    - Tokens reference original source bytes                 │
│    - No string duplication                                  │
├─────────────────────────────────────────────────────────────┤
│ 3. Specialized variants                                     │
│    - block_two vs block saves extra_data allocations        │
│    - call_one vs call for common 0-1 arg calls              │
├─────────────────────────────────────────────────────────────┤
│ 4. Flat storage                                             │
│    - All nodes in one contiguous array                      │
│    - No per-node allocation overhead (16+ bytes each)       │
│    - Better cache locality                                  │
├─────────────────────────────────────────────────────────────┤
│ 5. Index-based references                                   │
│    - 4-byte indices vs 8-byte pointers                      │
│    - Halves the cost of every reference!                    │
└─────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">High-Level AST Accessors
    <div id="high-level-ast-accessors" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#high-level-ast-accessors" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>The AST provides convenient accessors to hide the complexity:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">VarDecl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">visib_token</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">TokenIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">extern_export_token</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">TokenIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">lib_name</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">TokenIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">threadlocal_token</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">TokenIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">comptime_token</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">TokenIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ast</span><span class="o">:</span><span class="w"> </span><span class="n">Components</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">Components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">mut_token</span><span class="o">:</span><span class="w"> </span><span class="n">TokenIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">type_node</span><span class="o">:</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">align_node</span><span class="o">:</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">addrspace_node</span><span class="o">:</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">section_node</span><span class="o">:</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">init_node</span><span class="o">:</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="n">OptionalIndex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Similar for FnProto, If, While, For, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">fullVarDecl</span><span class="p">(</span><span class="n">tree</span><span class="o">:</span><span class="w"> </span><span class="n">Ast</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">:</span><span class="w"> </span><span class="n">Node</span><span class="p">.</span><span class="n">Index</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="n">full</span><span class="p">.</span><span class="n">VarDecl</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">nodeTag</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">global_var_decl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="nf">globalVarDecl</span><span class="p">(</span><span class="n">node</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">local_var_decl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="nf">localVarDecl</span><span class="p">(</span><span class="n">node</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">aligned_var_decl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="nf">alignedVarDecl</span><span class="p">(</span><span class="n">node</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">simple_var_decl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="nf">simpleVarDecl</span><span class="p">(</span><span class="n">node</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Why Accessors?
    <div id="why-accessors" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-accessors" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Problem: Multiple node variants for the same concept

  .global_var_decl  - uses extra_data
  .local_var_decl   - different layout
  .simple_var_decl  - optimized, no extra_data
  .aligned_var_decl - has alignment

Raw access is error-prone:
  // Wrong! Different nodes have different layouts
  const type_node = ast.nodes.items(.data)[node].something???

Solution: fullVarDecl() returns a unified view

  if (ast.fullVarDecl(node)) |var_decl| {
      // Works for ALL var decl variants!
      if (var_decl.ast.type_node) |type_node| {
          // Process type
      }
  }
</code></pre><hr>

<h2 class="relative group">Complete Example: From Source to Tree
    <div id="complete-example-from-source-to-tree" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#complete-example-from-source-to-tree" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">Source Code
    <div id="source-code" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#source-code" aria-label="Anchor">#</a>
    </span>
    
</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 class="relative group">Token Stream
    <div id="token-stream" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#token-stream" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>[pub] [fn] [max] [(] [a] [:] [u32] [,] [b] [:] [u32] [)] [u32] [{]
  0     1    2    3   4   5    6    7   8   9   10   11   12   13

[if] [(] [a] [&gt;] [b] [)] [{] [return] [a] [;] [}] [else] [{] [return] [b] [;] [}] [}]
 14   15  16  17  18  19  20    21    22  23  24   25    26    27     28  29  30  31
</code></pre>
<h3 class="relative group">Resulting AST
    <div id="resulting-ast" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#resulting-ast" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>                              root (0)
                                │
                            fn_decl (1)
                           /        \
                   fn_proto_multi    block_two (9)
                       (2)              │
                    /  |  \            if (10)
                 param param u32     /   |   \
                  (3)   (4)  (5)  cond  then  else
                 / \    / \       (11)  (12)  (13)
                a u32  b u32       │      │     │
                  (6)    (7)    greater block block
                                  / \     │     │
                                 a   b  return return
                                          │     │
                                          a     b

Node Table:
┌──────┬─────────────────┬───────────┬─────────────────────────┐
│ Idx  │ Tag             │ MainToken │ Data                    │
├──────┼─────────────────┼───────────┼─────────────────────────┤
│  0   │ root            │     0     │ extra_range: 0..1       │
│  1   │ fn_decl         │     1     │ {proto: 2, body: 9}     │
│  2   │ fn_proto_multi  │     1     │ {params: extra, ret: 5} │
│  3   │ param           │     4     │ {name: _, type: 6}      │
│  4   │ param           │     8     │ {name: _, type: 7}      │
│  5   │ identifier      │    12     │ (u32)                   │
│  6   │ identifier      │     6     │ (u32)                   │
│  7   │ identifier      │    10     │ (u32)                   │
│  8   │ (reserved)      │     -     │ -                       │
│  9   │ block_two       │    13     │ {stmt: 10, _}           │
│ 10   │ if              │    14     │ {cond: 11, extra: ...}  │
│ 11   │ greater_than    │    17     │ {lhs: a, rhs: b}        │
│ ...  │ ...             │    ...    │ ...                     │
└──────┴─────────────────┴───────────┴─────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Summary: The Parser&rsquo;s Job
    <div id="summary-the-parsers-job" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#summary-the-parsers-job" aria-label="Anchor">#</a>
    </span>
    
</h2>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────┐
│                      PARSER OVERVIEW                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  INPUT:                                                      │
│    Flat token stream from tokenizer                          │
│    [fn] [add] [(] [a] [:] [u32] [)] [u32] [{] [return] ...   │
│                                                              │
│  PROCESS:                                                    │
│    1. Recursive descent through grammar rules                │
│    2. Precedence climbing for expressions                    │
│    3. Build tree structure showing relationships             │
│    4. Recover from errors to report multiple issues          │
│                                                              │
│  OUTPUT:                                                     │
│    Compact AST in flat arrays                                │
│                                                              │
│            fn_decl                                           │
│           /       \                                          │
│      fn_proto    block                                       │
│        / \          \                                        │
│     param param   return                                     │
│                      |                                       │
│                     add                                      │
│                    /   \                                     │
│                   a     b                                    │
│                                                              │
│  KEY TECHNIQUES:                                             │
│    • 13-byte nodes with union data                           │
│    • MultiArrayList (SoA) for cache efficiency               │
│    • Specialized variants (block_two, call_one)              │
│    • Extra data for overflow                                 │
│    • Index-based references (not pointers)                   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Conclusion
    <div id="conclusion" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#conclusion" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Zig&rsquo;s parser and AST are designed for both correctness and efficiency:</p>
<ul>
<li><strong>Recursive descent</strong> makes the parser readable and maintainable</li>
<li><strong>Precedence climbing</strong> handles expressions elegantly</li>
<li><strong>MultiArrayList</strong> provides cache-friendly storage</li>
<li><strong>Node specialization</strong> optimizes common cases</li>
<li><strong>Error recovery</strong> enables better diagnostics</li>
</ul>
<p>The AST is the foundation for everything that follows. In the next article, we&rsquo;ll see how <strong>AstGen</strong> transforms this tree into <strong>ZIR</strong> (Zig Intermediate Representation).</p>
<hr>
<p><strong>Previous</strong>: <a
  href="./02-tokenizer.md">Part 2: Tokenizer</a>
<strong>Next</strong>: <a
  href="./04-zir-generation.md">Part 4: ZIR Generation</a></p>
<p><strong>Series Index</strong>:</p>
<ol>
<li><a
  href="./01-bootstrap-process.md">Bootstrap Process</a></li>
<li><a
  href="./02-tokenizer.md">Tokenizer</a></li>
<li><strong>Parser and AST</strong> (this article)</li>
<li><a
  href="./04-zir-generation.md">ZIR Generation</a></li>
<li><a
  href="./05-sema.md">Semantic Analysis</a></li>
<li><a
  href="./06-air-codegen.md">AIR and Code Generation</a></li>
<li><a
  href="./07-linking.md">Linking</a></li>
</ol>

          
          
          
        </div>
        
        

        

        

      </div>

      
      
        
        
          
          
        
        
        
        <script
          type="text/javascript"
          src="/js/page.min.54b6f4371722649edbe871e431d8670d670878c22be8f36e229fe53cc9b786fe25a834def5e6de621f7a3e37b72bc8cd73839aa5ed907ed6cbd45cd3e1b0fa20.js"
          integrity="sha512-VLb0NxciZJ7b6HHkMdhnDWcIeMIr6PNuIp/lPMm3hv4lqDTe9ebeYh96Pje3K8jNc4Oape2QftbL1FzT4bD6IA=="
          data-oid="views_drafts/03-parser-ast.md"
          data-oid-likes="likes_drafts/03-parser-ast.md"></script>
      
    </section>

    
    <footer class="pt-8 max-w-prose print:hidden">
      
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600">
      <div class="flex justify-between pt-3">
        <span class="flex flex-col">
          
            <a
              class="flex text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
              href="/drafts/04-zir-generation/">
              <span class="leading-6">
                <span class="inline-block rtl:rotate-180">&larr;</span>&ensp;Zig Compiler Internals Part 4: ZIR Generation
              </span>
            </a>
            
              <span class="ms-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                <time datetime="2025-12-17T00:00:00&#43;00:00">December 17, 2025</time>
              </span>
            
          
        </span>
        <span class="flex flex-col items-end">
          
            <a
              class="flex text-right text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
              href="/drafts/02-tokenizer/">
              <span class="leading-6">
                Zig Compiler Internals Part 2: The Tokenizer&ensp;<span class="inline-block rtl:rotate-180">&rarr;</span>
              </span>
            </a>
            
              <span class="me-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                <time datetime="2025-12-17T00:00:00&#43;00:00">December 17, 2025</time>
              </span>
            
          
        </span>
      </div>
    </div>
  


      
    </footer>
  </article>

        


  






<div
  id="scroll-to-top"
  class="fixed bottom-6 end-6 z-50 transform translate-y-4 opacity-0 duration-200">
  <a
    href="#the-top"
    class="pointer-events-auto flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="Scroll to top"
    title="Scroll to top">
    &uarr;
  </a>
</div>

      </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
  
  <div class="flex items-center justify-between">
    
    
      <p class="text-sm text-neutral-500 dark:text-neutral-400">
          &copy;
          2025
          Yohai
      </p>
    

    
    
      <p class="text-xs text-neutral-500 dark:text-neutral-400">
        
        
        Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
          href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
          href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a>
      </p>
    
  </div>
  
    <script>
      mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
        margin: 24,
        background: "rgba(0,0,0,0.5)",
        scrollOffset: 0,
      });
    </script>
  
  
  
  <script
    type="text/javascript"
    src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js"
    integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh] z-500"
  data-url="http://localhost:1313/">
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800">
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="Search"
          tabindex="0">
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="Close (Esc)">
        <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>
</span>
      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

    </div>
  </body>
  
</html>
