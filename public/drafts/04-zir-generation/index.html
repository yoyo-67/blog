<!doctype html>
<html
  lang="en-us"
  dir="ltr"
  class="scroll-smooth"
  data-default-appearance="dark"
  data-auto-appearance="true"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  
    <meta http-equiv="content-language" content="en-us">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color">

  
  
    <title>Zig Compiler Internals Part 4: ZIR Generation &middot; Yohai&#39;s Blog</title>
    <meta name="title" content="Zig Compiler Internals Part 4: ZIR Generation &middot; Yohai&#39;s Blog">
  

  
  
  
  
  
  <link rel="canonical" href="http://localhost:1313/drafts/04-zir-generation/">
  

  
  
    <meta name="author" content="Yohai">
  
  

  
  <meta property="og:url" content="http://localhost:1313/drafts/04-zir-generation/">
  <meta property="og:site_name" content="Yohai&#39;s Blog">
  <meta property="og:title" content="Zig Compiler Internals Part 4: ZIR Generation">
  <meta property="og:description" content="Zig Compiler Internals Part 4: ZIR Generation # From trees to instructions with AstGen
Introduction # After parsing produces the AST, the next step is to convert it into ZIR (Zig Intermediate Representation). But before we dive into how this works, let’s understand why we need ZIR in the first place.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="drafts">
    <meta property="article:published_time" content="2025-12-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-12-17T00:00:00+00:00">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Zig Compiler Internals Part 4: ZIR Generation">
  <meta name="twitter:description" content="Zig Compiler Internals Part 4: ZIR Generation # From trees to instructions with AstGen
Introduction # After parsing produces the AST, the next step is to convert it into ZIR (Zig Intermediate Representation). But before we dive into how this works, let’s understand why we need ZIR in the first place.">

  
  
  
  
    
      
    
  
    
      
    
  
    
      
    
  
  
    
  

  
  
  
  
  
  

  

  
  
  
  
  
  
  
  
    
  
  
  <link
    type="text/css"
    rel="stylesheet"
    href="/css/main.bundle.min.0975a8c7c266a0697f94839b45e1574c449de253527d44ed516d5c5c3c820c9389d7d86576faae12267b129f8749ecbf7581cddb636aba7690aa633b95aaa87d.css"
    integrity="sha512-CXWox8JmoGl/lIObReFXTESd4lNSfUTtUW1cXDyCDJOJ19hldvquEiZ7Ep&#43;HSey/dYHN22NqunaQqmM7laqofQ==">

  
  
  <script
    type="text/javascript"
    src="/js/appearance.min.6f41174b3a05b680820fe08cadbfa5fb7a7ca347b76a0955cdc68b9d8aca1ce24f0547e138cea33bcc7904d551a90afcb1cc7f2d9fe8557075d501419046c08c.js"
    integrity="sha512-b0EXSzoFtoCCD&#43;CMrb&#43;l&#43;3p8o0e3aglVzcaLnYrKHOJPBUfhOM6jO8x5BNVRqQr8scx/LZ/oVXB11QFBkEbAjA=="></script>
  
  
  
  
  
  
    
    <script src="/lib/zoom/zoom.min.umd.a527109b68c082a70f3697716dd72a9d5aa8b545cf800cecbbc7399f2ca6f6e0ce3e431f2062b48bbfa47c9ea42822714060bef309be073f49b9c0e30d318d7b.js" integrity="sha512-pScQm2jAgqcPNpdxbdcqnVqotUXPgAzsu8c5nyym9uDOPkMfIGK0i7&#43;kfJ6kKCJxQGC&#43;8wm&#43;Bz9JucDjDTGNew=="></script>
  

  
  
  
    
  
  
    
  
  
    
  
  
  
  
  
  
    
    <script
      defer
      type="text/javascript"
      id="script-bundle"
      src="/js/main.bundle.min.9cc802d09f28c6af56ceee7bc6e320a39251fdae98243f2a9942f221ac57a9f49c51609699a91794a7b2580ee1deaa8e4d794a68ffa94aa317c66e893ce51e02.js"
      integrity="sha512-nMgC0J8oxq9Wzu57xuMgo5JR/a6YJD8qmULyIaxXqfScUWCWmakXlKeyWA7h3qqOTXlKaP&#43;pSqMXxm6JPOUeAg=="
      data-copy="Copy"
      data-copied="Copied"></script>
  

  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>


























  

  

  

  

  





  
  
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
  

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Drafts",
    "name": "Zig Compiler Internals Part 4: ZIR Generation",
    "headline": "Zig Compiler Internals Part 4: ZIR Generation",
    
    "abstract": "\u003ch1 class=\u0022relative group\u0022\u003eZig Compiler Internals Part 4: ZIR Generation\n    \u003cdiv id=\u0022zig-compiler-internals-part-4-zir-generation\u0022 class=\u0022anchor\u0022\u003e\u003c\/div\u003e\n    \n    \u003cspan\n        class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\u0022\u003e\n        \u003ca class=\u0022text-primary-300 dark:text-neutral-700 !no-underline\u0022 href=\u0022#zig-compiler-internals-part-4-zir-generation\u0022 aria-label=\u0022Anchor\u0022\u003e#\u003c\/a\u003e\n    \u003c\/span\u003e\n    \n\u003c\/h1\u003e\n\u003cp\u003e\u003cem\u003eFrom trees to instructions with AstGen\u003c\/em\u003e\u003c\/p\u003e\n\u003chr\u003e\n\n\u003ch2 class=\u0022relative group\u0022\u003eIntroduction\n    \u003cdiv id=\u0022introduction\u0022 class=\u0022anchor\u0022\u003e\u003c\/div\u003e\n    \n    \u003cspan\n        class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\u0022\u003e\n        \u003ca class=\u0022text-primary-300 dark:text-neutral-700 !no-underline\u0022 href=\u0022#introduction\u0022 aria-label=\u0022Anchor\u0022\u003e#\u003c\/a\u003e\n    \u003c\/span\u003e\n    \n\u003c\/h2\u003e\n\u003cp\u003eAfter parsing produces the AST, the next step is to convert it into \u003cstrong\u003eZIR\u003c\/strong\u003e (Zig Intermediate Representation). But before we dive into how this works, let\u0026rsquo;s understand \u003cstrong\u003ewhy\u003c\/strong\u003e we need ZIR in the first place.\u003c\/p\u003e",
    "inLanguage": "en-us",
    "url" : "http://localhost:1313/drafts/04-zir-generation/",
    "author" : {
      "@type": "Person",
      "name": "Yohai"
    },
    "copyrightYear": "2025",
    "dateCreated": "2025-12-17T00:00:00\u002b00:00",
    "datePublished": "2025-12-17T00:00:00\u002b00:00",
    
    "dateModified": "2025-12-17T00:00:00\u002b00:00",
    
    
    
    "mainEntityOfPage": "true",
    "wordCount": "5965"
  }]
  </script>



  
  

  
  

  
  

  
  

  
  
</head>


















  
  
  <body class="flex flex-col h-screen m-auto leading-7 max-w-7xl px-6 sm:px-14 md:px-24 lg:px-32 text-lg bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
    <div id="the-top" class="absolute flex self-center">
      <a
        class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
        href="#main-content">
        <span class="font-bold text-primary-600 pe-2 dark:text-primary-400">&darr;</span>
        Skip to main content
      </a>
    </div>
    
    
      













<div
  class="main-menu flex items-center justify-between py-6 md:justify-start gap-x-3 pt-[2px] pr-2 md:pr-4 pb-[3px] pl-0">
  
  

  <div class="flex flex-1 items-center justify-between">
    <nav class="flex space-x-3">
      
        <a href="/" class="text-base font-medium">
          Yohai&rsquo;s Blog
        </a>
      
    </nav>
    
  <nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12">
    
      
        
  <a
  href="/posts/"
  
  class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
  aria-label="Posts"
  title="Posts">
  
  
    <p class="text-base font-medium">
      Posts
    </p>
  
</a>



      
        
  <a
  href="/drafts/"
  
  class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
  aria-label="Drafts"
  title="Drafts">
  
  
    <p class="text-base font-medium">
      Drafts
    </p>
  
</a>



      
        
  <a
  href="/tags/"
  
  class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
  aria-label="Tags"
  title="Tags">
  
  
    <p class="text-base font-medium">
      Tags
    </p>
  
</a>



      
    

    

    

    
      <button
        id="search-button"
        aria-label="Search"
        class="text-base hover:text-primary-600 dark:hover:text-primary-400"
        title="Search (/)">
        <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
      </button>
    

    
      <div class=" flex items-center">
        <button
          id="appearance-switcher"
          aria-label="Dark mode switcher"
          type="button"
          class="text-base hover:text-primary-600 dark:hover:text-primary-400">
          <div class="flex items-center justify-center dark:hidden">
            <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>
</span>
          </div>
          <div class="items-center justify-center hidden dark:flex">
            <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>
</span>
          </div>
        </button>
      </div>
    
  </nav>

    
  <div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12">
    <span></span>

    

    

    
      <button
        id="search-button-mobile"
        aria-label="Search"
        class="text-base hover:text-primary-600 dark:hover:text-primary-400"
        title="Search (/)">
        <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
      </button>
    

    
      <button
        id="appearance-switcher-mobile"
        aria-label="Dark mode switcher"
        type="button"
        class="text-base hover:text-primary-600 dark:hover:text-primary-400 me-1">
        <div class="flex items-center justify-center dark:hidden">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>
</span>
        </div>
        <div class="items-center justify-center hidden dark:flex">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>
</span>
        </div>
      </button>
    
  </div>

  </div>
  
  <div class="-my-2 md:hidden">
    <div id="menu-button" class="block">
      
        <div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>
</span>
        </div>
        <div
          id="menu-wrapper"
          class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50 pt-[5px]">
          <ul
            class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none text-end max-w-7xl">
            <li id="menu-close-button">
              <span
                class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400">
                <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>
</span>
              </span>
            </li>

            
              
  <li class="mt-1">
  <a
    href="/posts/"
    
    class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
    aria-label="Posts"
    title="Posts">
    
    
      <p class="text-bg font-bg">
        Posts
      </p>
    
  </a>
</li>



            
              
  <li class="mt-1">
  <a
    href="/drafts/"
    
    class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
    aria-label="Drafts"
    title="Drafts">
    
    
      <p class="text-bg font-bg">
        Drafts
      </p>
    
  </a>
</li>



            
              
  <li class="mt-1">
  <a
    href="/tags/"
    
    class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
    aria-label="Tags"
    title="Tags">
    
    
      <p class="text-bg font-bg">
        Tags
      </p>
    
  </a>
</li>



            

          </ul>
          
        </div>
      
    </div>
  </div>

</div>





    
    <div class="relative flex flex-col grow">
      <main id="main-content" class="grow">
        
  
  <article>
    
    

    
    <header id="single_header" class="mt-5 max-w-prose">
      
        <ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden">
  
  
    
  
    
  
  <li class="hidden">
    <a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href="/"
      >Yohai&#39;s Blog</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  <li class="inline">
    <a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href="/drafts/"
      >Drafts</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  <li class="hidden">
    <a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href="/drafts/04-zir-generation/"
      >Zig Compiler Internals Part 4: ZIR Generation</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

</ol>


      
      <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
        Zig Compiler Internals Part 4: ZIR Generation
      </h1>
      <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
        





  
  



  

  
  
  
    
  

  

  
    
  

  

  
    
  

  
    
  

  

  

  

  

  


  <div class="flex flex-row flex-wrap items-center">
    
    
      <time datetime="2025-12-17T00:00:00&#43;00:00">December 17, 2025</time><span class="px-2 text-primary-500">&middot;</span><span>5965 words</span><span class="px-2 text-primary-500">&middot;</span><span title="Reading time">29 mins</span>
    

    
    
  </div>

  

  
  

  
  



      </div>
      
        
  
  
  
  
  
  

  

  
    
    
<div class="flex author">
  
  <div class="place-self-center">
    
      <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
        Author
      </div>
      <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
        Yohai
      </div>
    
    
    <div class="text-2xl sm:text-lg">
</div>
  </div>
</div>

  

  

  
    <div class="mb-5"></div>
  

      
    </header>

    
    <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
      
      
      
      
      
        <div class="order-first lg:ml-auto px-0 lg:order-last lg:ps-8 lg:max-w-2xs">
          <div class="toc ps-5 print:hidden lg:sticky lg:top-10">
            
              <details
  open
  id="TOCView"
  class="toc-right mt-0 overflow-y-auto overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg -ms-5 ps-5 pe-2 hidden lg:block">
  <summary
    class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="min-w-[220px] py-2 border-dotted border-s-1 -ms-5 ps-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#part-1-why-do-we-need-zir">Part 1: Why Do We Need ZIR?</a>
      <ul>
        <li><a href="#the-problem-trees-are-hard-to-execute">The Problem: Trees Are Hard to Execute</a></li>
        <li><a href="#the-solution-linear-instructions">The Solution: Linear Instructions</a></li>
        <li><a href="#zir--zigs-linear-instruction-format">ZIR = Zig&rsquo;s Linear Instruction Format</a></li>
      </ul>
    </li>
    <li><a href="#part-2-what-is-an-intermediate-representation">Part 2: What is an &ldquo;Intermediate Representation&rdquo;?</a>
      <ul>
        <li><a href="#the-compiler-as-a-translator">The Compiler as a Translator</a></li>
        <li><a href="#why-not-translate-directly">Why Not Translate Directly?</a></li>
        <li><a href="#the-solution-intermediate-steps">The Solution: Intermediate Steps</a></li>
        <li><a href="#analogy-recipe-translation">Analogy: Recipe Translation</a></li>
      </ul>
    </li>
    <li><a href="#part-3-what-makes-zir-special">Part 3: What Makes ZIR Special?</a>
      <ul>
        <li><a href="#zir-is-untyped---what-does-that-mean">ZIR is &ldquo;Untyped&rdquo; - What Does That Mean?</a></li>
        <li><a href="#why-keep-zir-untyped">Why Keep ZIR Untyped?</a></li>
      </ul>
    </li>
    <li><a href="#part-4-how-zir-instructions-work">Part 4: How ZIR Instructions Work</a>
      <ul>
        <li><a href="#instruction-format-explained">Instruction Format Explained</a></li>
        <li><a href="#reference-numbers-explained">Reference Numbers Explained</a></li>
        <li><a href="#common-instruction-types">Common Instruction Types</a></li>
      </ul>
    </li>
    <li><a href="#part-5-step-by-step-examples">Part 5: Step-by-Step Examples</a>
      <ul>
        <li><a href="#example-1-simple-addition">Example 1: Simple Addition</a></li>
        <li><a href="#example-2-if-expression">Example 2: If Expression</a></li>
        <li><a href="#example-3-function-definition">Example 3: Function Definition</a></li>
        <li><a href="#example-4-loop">Example 4: Loop</a></li>
      </ul>
    </li>
    <li><a href="#part-6-how-astgen-walks-the-tree">Part 6: How AstGen Walks the Tree</a>
      <ul>
        <li><a href="#the-main-pattern-recursive-descent">The Main Pattern: Recursive Descent</a></li>
        <li><a href="#trace-processing-1--2--3">Trace: Processing <code>(1 + 2) * 3</code></a></li>
      </ul>
    </li>
    <li><a href="#part-7-source-location-tracking">Part 7: Source Location Tracking</a>
      <ul>
        <li><a href="#why-track-locations">Why Track Locations?</a></li>
        <li><a href="#how-locations-are-stored">How Locations are Stored</a></li>
      </ul>
    </li>
    <li><a href="#part-8-the-string-table">Part 8: The String Table</a>
      <ul>
        <li><a href="#why-a-string-table">Why a String Table?</a></li>
      </ul>
    </li>
    <li><a href="#part-9-putting-it-all-together">Part 9: Putting It All Together</a>
      <ul>
        <li><a href="#complete-example-full-function">Complete Example: Full Function</a></li>
      </ul>
    </li>
    <li><a href="#part-10-the-big-picture">Part 10: The Big Picture</a>
      <ul>
        <li><a href="#where-zir-fits">Where ZIR Fits</a></li>
        <li><a href="#the-scope-system">The Scope System</a></li>
        <li><a href="#string-interning">String Interning</a></li>
        <li><a href="#summary-what-zir-achieves">Summary: What ZIR Achieves</a></li>
      </ul>
    </li>
    <li><a href="#try-it-yourself">Try It Yourself</a></li>
    <li><a href="#further-reading">Further Reading</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
  </div>
</details>
<details class="toc-inside mt-0 overflow-hidden rounded-lg -ms-5 ps-5 lg:hidden">
  <summary
    class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="py-2 border-dotted border-neutral-300 border-s-1 -ms-5 ps-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#part-1-why-do-we-need-zir">Part 1: Why Do We Need ZIR?</a>
      <ul>
        <li><a href="#the-problem-trees-are-hard-to-execute">The Problem: Trees Are Hard to Execute</a></li>
        <li><a href="#the-solution-linear-instructions">The Solution: Linear Instructions</a></li>
        <li><a href="#zir--zigs-linear-instruction-format">ZIR = Zig&rsquo;s Linear Instruction Format</a></li>
      </ul>
    </li>
    <li><a href="#part-2-what-is-an-intermediate-representation">Part 2: What is an &ldquo;Intermediate Representation&rdquo;?</a>
      <ul>
        <li><a href="#the-compiler-as-a-translator">The Compiler as a Translator</a></li>
        <li><a href="#why-not-translate-directly">Why Not Translate Directly?</a></li>
        <li><a href="#the-solution-intermediate-steps">The Solution: Intermediate Steps</a></li>
        <li><a href="#analogy-recipe-translation">Analogy: Recipe Translation</a></li>
      </ul>
    </li>
    <li><a href="#part-3-what-makes-zir-special">Part 3: What Makes ZIR Special?</a>
      <ul>
        <li><a href="#zir-is-untyped---what-does-that-mean">ZIR is &ldquo;Untyped&rdquo; - What Does That Mean?</a></li>
        <li><a href="#why-keep-zir-untyped">Why Keep ZIR Untyped?</a></li>
      </ul>
    </li>
    <li><a href="#part-4-how-zir-instructions-work">Part 4: How ZIR Instructions Work</a>
      <ul>
        <li><a href="#instruction-format-explained">Instruction Format Explained</a></li>
        <li><a href="#reference-numbers-explained">Reference Numbers Explained</a></li>
        <li><a href="#common-instruction-types">Common Instruction Types</a></li>
      </ul>
    </li>
    <li><a href="#part-5-step-by-step-examples">Part 5: Step-by-Step Examples</a>
      <ul>
        <li><a href="#example-1-simple-addition">Example 1: Simple Addition</a></li>
        <li><a href="#example-2-if-expression">Example 2: If Expression</a></li>
        <li><a href="#example-3-function-definition">Example 3: Function Definition</a></li>
        <li><a href="#example-4-loop">Example 4: Loop</a></li>
      </ul>
    </li>
    <li><a href="#part-6-how-astgen-walks-the-tree">Part 6: How AstGen Walks the Tree</a>
      <ul>
        <li><a href="#the-main-pattern-recursive-descent">The Main Pattern: Recursive Descent</a></li>
        <li><a href="#trace-processing-1--2--3">Trace: Processing <code>(1 + 2) * 3</code></a></li>
      </ul>
    </li>
    <li><a href="#part-7-source-location-tracking">Part 7: Source Location Tracking</a>
      <ul>
        <li><a href="#why-track-locations">Why Track Locations?</a></li>
        <li><a href="#how-locations-are-stored">How Locations are Stored</a></li>
      </ul>
    </li>
    <li><a href="#part-8-the-string-table">Part 8: The String Table</a>
      <ul>
        <li><a href="#why-a-string-table">Why a String Table?</a></li>
      </ul>
    </li>
    <li><a href="#part-9-putting-it-all-together">Part 9: Putting It All Together</a>
      <ul>
        <li><a href="#complete-example-full-function">Complete Example: Full Function</a></li>
      </ul>
    </li>
    <li><a href="#part-10-the-big-picture">Part 10: The Big Picture</a>
      <ul>
        <li><a href="#where-zir-fits">Where ZIR Fits</a></li>
        <li><a href="#the-scope-system">The Scope System</a></li>
        <li><a href="#string-interning">String Interning</a></li>
        <li><a href="#summary-what-zir-achieves">Summary: What ZIR Achieves</a></li>
      </ul>
    </li>
    <li><a href="#try-it-yourself">Try It Yourself</a></li>
    <li><a href="#further-reading">Further Reading</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
  </div>
</details>



            
          </div>
        </div>
      


      <div class="min-w-0 min-h-0 max-w-fit">
        

        <div class="article-content max-w-prose mb-20">
          
<h1 class="relative group">Zig Compiler Internals Part 4: ZIR Generation
    <div id="zig-compiler-internals-part-4-zir-generation" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#zig-compiler-internals-part-4-zir-generation" aria-label="Anchor">#</a>
    </span>
    
</h1>
<p><em>From trees to instructions with AstGen</em></p>
<hr>

<h2 class="relative group">Introduction
    <div id="introduction" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#introduction" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>After parsing produces the AST, the next step is to convert it into <strong>ZIR</strong> (Zig Intermediate Representation). But before we dive into how this works, let&rsquo;s understand <strong>why</strong> we need ZIR in the first place.</p>
<hr>

<h2 class="relative group">Part 1: Why Do We Need ZIR?
    <div id="part-1-why-do-we-need-zir" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-1-why-do-we-need-zir" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">The Problem: Trees Are Hard to Execute
    <div id="the-problem-trees-are-hard-to-execute" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-problem-trees-are-hard-to-execute" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The AST (Abstract Syntax Tree) is great for representing code structure, but it&rsquo;s terrible for execution. Here&rsquo;s why:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ THE AST PROBLEM                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Code: result = a + b * c                                            │
│                                                                      │
│ AST looks like this:                                                │
│                                                                      │
│              assign                                                  │
│             /      \                                                 │
│         result      +                                                │
│                   /   \                                              │
│                  a     *                                             │
│                       / \                                            │
│                      b   c                                           │
│                                                                      │
│ Questions a CPU would ask:                                          │
│                                                                      │
│   ❓ &#34;Where do I start?&#34;                                            │
│   ❓ &#34;What do I do first?&#34;                                          │
│   ❓ &#34;How do I traverse this tree?&#34;                                 │
│   ❓ &#34;Where do intermediate values go?&#34;                             │
│                                                                      │
│ Trees require INTERPRETATION (walking/visiting) - slow!             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">The Solution: Linear Instructions
    <div id="the-solution-linear-instructions" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-solution-linear-instructions" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>CPUs don&rsquo;t execute trees - they execute <strong>sequences of instructions</strong>, one after another:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ WHAT CPUs UNDERSTAND                                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Same code: result = a + b * c                                       │
│                                                                      │
│ As LINEAR INSTRUCTIONS:                                              │
│                                                                      │
│   Step 1:  temp1 = b * c      // First, multiply                    │
│   Step 2:  temp2 = a + temp1  // Then, add                          │
│   Step 3:  result = temp2     // Finally, assign                    │
│                                                                      │
│ CPU can execute this directly:                                      │
│   ✓ Start at step 1                                                 │
│   ✓ Go to step 2                                                    │
│   ✓ Go to step 3                                                    │
│   ✓ Done!                                                           │
│                                                                      │
│ This is MUCH faster than walking a tree!                            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">ZIR = Zig&rsquo;s Linear Instruction Format
    <div id="zir--zigs-linear-instruction-format" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#zir--zigs-linear-instruction-format" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>ZIR converts the tree into a linear sequence that&rsquo;s easier to work with:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ AST → ZIR TRANSFORMATION                                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ BEFORE (AST - tree structure):                                      │
│                                                                      │
│              assign                                                  │
│             /      \                                                 │
│         result      +           Must walk tree recursively          │
│                   /   \         to figure out execution order       │
│                  a     *                                             │
│                       / \                                            │
│                      b   c                                           │
│                                                                      │
│                        │                                             │
│                        ▼                                             │
│                                                                      │
│ AFTER (ZIR - linear instructions):                                  │
│                                                                      │
│   %1 = load(b)           // Read b from memory                      │
│   %2 = load(c)           // Read c from memory                      │
│   %3 = mul(%1, %2)       // Multiply: b * c                         │
│   %4 = load(a)           // Read a from memory                      │
│   %5 = add(%4, %3)       // Add: a + (b * c)                        │
│   %6 = store(result, %5) // Store to result                         │
│                                                                      │
│   Each instruction clearly says:                                    │
│   - What operation to do                                            │
│   - What inputs to use (by reference number)                        │
│   - Result gets a reference number for later use                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Part 2: What is an &ldquo;Intermediate Representation&rdquo;?
    <div id="part-2-what-is-an-intermediate-representation" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-2-what-is-an-intermediate-representation" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">The Compiler as a Translator
    <div id="the-compiler-as-a-translator" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-compiler-as-a-translator" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Think of a compiler as a translator between languages:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ COMPILATION AS TRANSLATION                                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Source Language          →          Target Language                 │
│ (Human-friendly)                    (Machine-friendly)              │
│                                                                      │
│ ┌─────────────────┐                 ┌─────────────────┐            │
│ │                 │                 │                 │            │
│ │  fn add(a, b)   │      ???        │  mov rax, rdi   │            │
│ │    return a+b   │  ─────────►     │  add rax, rsi   │            │
│ │  }              │                 │  ret            │            │
│ │                 │                 │                 │            │
│ └─────────────────┘                 └─────────────────┘            │
│                                                                      │
│ These are VERY different! Hard to translate directly.               │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Why Not Translate Directly?
    <div id="why-not-translate-directly" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-not-translate-directly" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Direct translation is problematic:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ PROBLEMS WITH DIRECT TRANSLATION                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. SOURCE IS HIGH-LEVEL                                             │
│    - Abstract concepts (functions, types, loops)                    │
│    - No concern for memory layout                                   │
│    - No concern for CPU registers                                   │
│                                                                      │
│ 2. TARGET IS LOW-LEVEL                                              │
│    - Concrete operations (add, mov, jump)                           │
│    - Specific memory addresses                                      │
│    - Specific CPU registers                                         │
│                                                                      │
│ 3. DIFFERENT TARGETS NEED DIFFERENT OUTPUT                          │
│    - x86-64 has different instructions than ARM                     │
│    - WebAssembly is completely different                            │
│    - We don&#39;t want to rewrite the whole compiler for each!         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">The Solution: Intermediate Steps
    <div id="the-solution-intermediate-steps" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-solution-intermediate-steps" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Instead of one big jump, we take small steps through &ldquo;intermediate representations&rdquo;:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ THE COMPILER PIPELINE                                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   Source Code (very high level)                                     │
│        │                                                            │
│        │  &#34;Lower&#34; = make more concrete                              │
│        ▼                                                            │
│   ┌─────────┐                                                       │
│   │   AST   │  Still high-level, but structured                    │
│   └────┬────┘                                                       │
│        │                                                            │
│        ▼                                                            │
│   ┌─────────┐                                                       │
│   │   ZIR   │  Linear instructions, but no types yet    ◄── HERE   │
│   └────┬────┘                                                       │
│        │                                                            │
│        ▼                                                            │
│   ┌─────────┐                                                       │
│   │   AIR   │  Typed instructions, machine-independent             │
│   └────┬────┘                                                       │
│        │                                                            │
│        ▼                                                            │
│   Machine Code (very low level)                                     │
│                                                                      │
│                                                                      │
│ Each step makes the code a LITTLE more concrete.                    │
│ No single step is too big of a jump.                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Analogy: Recipe Translation
    <div id="analogy-recipe-translation" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#analogy-recipe-translation" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Think of it like translating a recipe from French to English to a shopping list:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ RECIPE ANALOGY                                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ French Recipe (Source):                                             │
│   &#34;Préparez un gâteau au chocolat avec de la crème&#34;                │
│                                                                      │
│        ↓ (Parse: understand structure)                              │
│                                                                      │
│ Structured Recipe (AST):                                            │
│   Make:                                                              │
│     - Type: Cake                                                    │
│     - Flavor: Chocolate                                             │
│     - Topping: Cream                                                │
│                                                                      │
│        ↓ (AstGen: make actionable)                                  │
│                                                                      │
│ Step-by-Step Instructions (ZIR):                                    │
│   1. Get chocolate                                                  │
│   2. Get flour                                                      │
│   3. Mix ingredients                                                │
│   4. Bake at ??? degrees  ← Temperature not specified yet!         │
│   5. Add cream topping                                              │
│                                                                      │
│        ↓ (Sema: fill in details)                                    │
│                                                                      │
│ Detailed Instructions (AIR):                                        │
│   1. Get 200g chocolate                                             │
│   2. Get 300g flour                                                 │
│   3. Mix for 5 minutes                                              │
│   4. Bake at 350°F for 30 minutes                                   │
│   5. Add 100ml cream topping                                        │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Part 3: What Makes ZIR Special?
    <div id="part-3-what-makes-zir-special" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-3-what-makes-zir-special" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">ZIR is &ldquo;Untyped&rdquo; - What Does That Mean?
    <div id="zir-is-untyped---what-does-that-mean" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#zir-is-untyped---what-does-that-mean" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ TYPED vs UNTYPED                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ TYPED (knows exact types):                                          │
│                                                                      │
│   const x: u32 = 5;         // We know x is a 32-bit unsigned int  │
│   const y: u32 = 10;        // We know y is a 32-bit unsigned int  │
│   const z: u32 = x + y;     // Addition uses 32-bit math           │
│                                                                      │
│   The compiler knows:                                                │
│   - Exactly how many bytes each variable uses                       │
│   - Exactly which CPU instruction to use for addition               │
│   - Whether the operation is valid (can&#39;t add u32 to string)       │
│                                                                      │
│ ─────────────────────────────────────────────────────────────────── │
│                                                                      │
│ UNTYPED (doesn&#39;t know types yet):                                   │
│                                                                      │
│   %1 = load(&#34;x&#34;)            // Load something called &#34;x&#34;           │
│   %2 = load(&#34;y&#34;)            // Load something called &#34;y&#34;           │
│   %3 = add(%1, %2)          // Add them (somehow)                  │
│                                                                      │
│   The compiler DOESN&#39;T know yet:                                    │
│   - Are these integers? Floats? Something else?                     │
│   - Is this addition valid?                                         │
│   - How many bytes are involved?                                    │
│                                                                      │
│   These questions are answered LATER during &#34;Sema&#34; (type checking) │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Why Keep ZIR Untyped?
    <div id="why-keep-zir-untyped" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-keep-zir-untyped" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>This seems backwards - why not figure out types immediately? There are excellent reasons:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ REASON 1: CACHING                                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ ZIR can be saved to disk and reused!                                │
│                                                                      │
│ First compile:                                                       │
│   source.zig  ──►  [Parse]  ──►  [AstGen]  ──►  source.zir (saved) │
│                                                                      │
│ Second compile (source unchanged):                                  │
│   source.zir (loaded from disk)  ──►  [Sema]  ──►  ...             │
│                                                                      │
│ Skip parsing and AstGen entirely! Much faster rebuilds.             │
│                                                                      │
│ If ZIR contained type info, we couldn&#39;t cache it - changing a type │
│ in one file would invalidate ZIR in other files.                   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ REASON 2: GENERICS (same code, different types)                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Consider this generic function:                                      │
│                                                                      │
│   fn add(comptime T: type, a: T, b: T) T {                         │
│       return a + b;                                                 │
│   }                                                                  │
│                                                                      │
│ This SINGLE function can be called with:                            │
│   - add(u32, 5, 10)      → uses 32-bit integer addition            │
│   - add(f64, 1.5, 2.5)   → uses 64-bit float addition              │
│   - add(i8, 1, 2)        → uses 8-bit integer addition             │
│                                                                      │
│ With UNTYPED ZIR:                                                   │
│   - Generate ZIR ONCE for the function                              │
│   - Sema instantiates it multiple times with different types       │
│                                                                      │
│ With TYPED IR:                                                      │
│   - Would need to generate separate IR for each type combination   │
│   - Much more complex and wasteful                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ REASON 3: LAZY ANALYSIS                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Not all code needs to be analyzed!                                  │
│                                                                      │
│   fn usedFunction() void {                                          │
│       // This WILL be type-checked                                  │
│   }                                                                  │
│                                                                      │
│   fn unusedFunction() void {                                        │
│       // This WON&#39;T be type-checked (never called)                 │
│       // Saves time!                                                │
│   }                                                                  │
│                                                                      │
│ With UNTYPED ZIR:                                                   │
│   - Generate ZIR for everything (fast, no type checking)           │
│   - Only type-check functions that are actually used               │
│                                                                      │
│ With TYPED IR:                                                      │
│   - Would need to type-check everything upfront                    │
│   - Wastes time on unused code                                     │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Part 4: How ZIR Instructions Work
    <div id="part-4-how-zir-instructions-work" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-4-how-zir-instructions-work" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">Instruction Format Explained
    <div id="instruction-format-explained" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#instruction-format-explained" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Every ZIR instruction has two parts:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ ZIR INSTRUCTION ANATOMY                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ ┌─────────────────────────────────────────────────────────────────┐│
│ │               ZIR Instruction                                    ││
│ │  ┌───────────────────┬─────────────────────────────────────┐   ││
│ │  │       TAG         │              DATA                    │   ││
│ │  │  (what to do)     │    (what to do it with)             │   ││
│ │  └───────────────────┴─────────────────────────────────────┘   ││
│ └─────────────────────────────────────────────────────────────────┘│
│                                                                      │
│ Examples:                                                            │
│                                                                      │
│   TAG: .add                                                         │
│   DATA: { lhs: %3, rhs: %5 }                                       │
│   Meaning: &#34;Add the values from instruction 3 and instruction 5&#34;   │
│                                                                      │
│   TAG: .load                                                        │
│   DATA: { operand: %2 }                                            │
│   Meaning: &#34;Load the value that instruction 2 points to&#34;           │
│                                                                      │
│   TAG: .int                                                         │
│   DATA: { value: 42 }                                              │
│   Meaning: &#34;The integer literal 42&#34;                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Reference Numbers Explained
    <div id="reference-numbers-explained" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#reference-numbers-explained" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Each instruction gets a &ldquo;reference number&rdquo; (like %1, %2, %3). This is how instructions refer to each other:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ HOW INSTRUCTIONS REFERENCE EACH OTHER                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Code: x = 5 + 3                                                     │
│                                                                      │
│ ZIR:                                                                │
│   %1 = int(5)       // Instruction 1 produces the value 5          │
│   %2 = int(3)       // Instruction 2 produces the value 3          │
│   %3 = add(%1, %2)  // Instruction 3 adds results of %1 and %2     │
│   %4 = store(x, %3) // Instruction 4 stores result of %3 to x      │
│                                                                      │
│ Visual:                                                              │
│                                                                      │
│   %1 ──────────┐                                                    │
│   (value: 5)   │                                                    │
│                ├──► %3 ──────────┐                                  │
│   %2 ──────────┘    (5 + 3 = 8)  │                                  │
│   (value: 3)                     ├──► %4                            │
│                                  │    (store 8 to x)                │
│                   x ─────────────┘                                  │
│                   (location)                                         │
│                                                                      │
│ Think of it like variables in a program:                            │
│   temp1 = 5                                                         │
│   temp2 = 3                                                         │
│   temp3 = temp1 + temp2                                             │
│   x = temp3                                                         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Common Instruction Types
    <div id="common-instruction-types" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#common-instruction-types" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ ZIR INSTRUCTION CATEGORIES                                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. LITERALS (create values)                                         │
│    ──────────────────────────                                       │
│    .int           → Integer literal       %1 = int(42)             │
│    .float         → Float literal         %1 = float(3.14)         │
│    .str           → String literal        %1 = str(&#34;hello&#34;)        │
│                                                                      │
│                                                                      │
│ 2. ARITHMETIC (math operations)                                     │
│    ──────────────────────────                                       │
│    .add           → Addition              %3 = add(%1, %2)         │
│    .sub           → Subtraction           %3 = sub(%1, %2)         │
│    .mul           → Multiplication        %3 = mul(%1, %2)         │
│    .div           → Division              %3 = div(%1, %2)         │
│                                                                      │
│                                                                      │
│ 3. COMPARISON (produce true/false)                                  │
│    ──────────────────────────                                       │
│    .cmp_eq        → Equal                 %3 = cmp_eq(%1, %2)      │
│    .cmp_neq       → Not equal             %3 = cmp_neq(%1, %2)     │
│    .cmp_lt        → Less than             %3 = cmp_lt(%1, %2)      │
│    .cmp_gt        → Greater than          %3 = cmp_gt(%1, %2)      │
│                                                                      │
│                                                                      │
│ 4. MEMORY (read/write memory)                                       │
│    ──────────────────────────                                       │
│    .load          → Read from pointer     %2 = load(%1)            │
│    .store         → Write to pointer      store(%1, %2)            │
│    .alloc         → Reserve stack space   %1 = alloc(u32)          │
│                                                                      │
│                                                                      │
│ 5. CONTROL FLOW (change execution order)                            │
│    ──────────────────────────                                       │
│    .block         → Start a block         block: { ... }           │
│    .condbr        → Conditional branch    condbr(%1, then, else)   │
│    .br            → Unconditional branch  br(target)               │
│    .ret           → Return from function  ret(%1)                  │
│                                                                      │
│                                                                      │
│ 6. FUNCTION (function-related)                                      │
│    ──────────────────────────                                       │
│    .param         → Function parameter    %1 = param(0)            │
│    .call          → Call a function       %2 = call(%1, args...)   │
│    .func          → Define a function     func(body, ...)          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Part 5: Step-by-Step Examples
    <div id="part-5-step-by-step-examples" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-5-step-by-step-examples" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">Example 1: Simple Addition
    <div id="example-1-simple-addition" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-1-simple-addition" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Let&rsquo;s trace how <code>const z = x + y;</code> becomes ZIR:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ EXAMPLE: const z = x + y;                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ STEP 1: Start with the AST                                          │
│ ─────────────────────────────                                       │
│                                                                      │
│   AST structure:                                                    │
│                                                                      │
│           const_decl                                                │
│           /    |    \                                               │
│         &#34;z&#34;  type    +                                              │
│              (none) / \                                              │
│                    x   y                                            │
│                                                                      │
│ STEP 2: Process the right side first (x + y)                        │
│ ─────────────────────────────                                       │
│                                                                      │
│   We need to generate ZIR for the &#34;+&#34; node.                         │
│   But &#34;+&#34; needs its operands first!                                 │
│                                                                      │
│   So we process left-to-right, bottom-up:                          │
│                                                                      │
│   a) Process &#34;x&#34; (identifier)                                       │
│      → Need to find where &#34;x&#34; is defined                           │
│      → Generate: %1 = load(&#34;x&#34;)                                    │
│                                                                      │
│   b) Process &#34;y&#34; (identifier)                                       │
│      → Need to find where &#34;y&#34; is defined                           │
│      → Generate: %2 = load(&#34;y&#34;)                                    │
│                                                                      │
│   c) Process &#34;+&#34; (binary operator)                                  │
│      → Generate: %3 = add(%1, %2)                                  │
│                                                                      │
│ STEP 3: Process the const declaration                               │
│ ─────────────────────────────                                       │
│                                                                      │
│   d) Allocate space for &#34;z&#34;                                         │
│      → Generate: %4 = alloc()                                      │
│                                                                      │
│   e) Store the result                                               │
│      → Generate: %5 = store(%4, %3)                                │
│                                                                      │
│ FINAL ZIR:                                                          │
│ ─────────────────────────────                                       │
│                                                                      │
│   %1 = load(&#34;x&#34;)        // Get value of x                          │
│   %2 = load(&#34;y&#34;)        // Get value of y                          │
│   %3 = add(%1, %2)      // Add them                                │
│   %4 = alloc()          // Make space for z                        │
│   %5 = store(%4, %3)    // Store result in z                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Example 2: If Expression
    <div id="example-2-if-expression" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-2-if-expression" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Let&rsquo;s trace <code>const max = if (a &gt; b) a else b;</code>:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ EXAMPLE: const max = if (a &gt; b) a else b;                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ AST structure:                                                      │
│                                                                      │
│              const_decl                                             │
│             /    |    \                                             │
│          &#34;max&#34; type   if_expr                                       │
│                (none) /  |   \                                       │
│                     &gt;  &#34;a&#34;  &#34;b&#34;                                     │
│                    / \   ↑    ↑                                     │
│                   a   b  │    │                                     │
│                         then else                                   │
│                                                                      │
│ ZIR GENERATION:                                                     │
│ ─────────────────────────────                                       │
│                                                                      │
│ 1. Generate condition (a &gt; b):                                      │
│    %1 = load(&#34;a&#34;)                                                   │
│    %2 = load(&#34;b&#34;)                                                   │
│    %3 = cmp_gt(%1, %2)      // Is a &gt; b?                           │
│                                                                      │
│ 2. Generate conditional branch:                                     │
│    %4 = condbr(%3)          // Branch based on comparison          │
│          │                                                          │
│          ├──► then_block:                                          │
│          │      %5 = load(&#34;a&#34;)    // If true, result is a          │
│          │      br(end, %5)       // Jump to end with value        │
│          │                                                          │
│          └──► else_block:                                          │
│                 %6 = load(&#34;b&#34;)    // If false, result is b         │
│                 br(end, %6)       // Jump to end with value        │
│                                                                      │
│ 3. End block collects the result:                                  │
│    end:                                                              │
│      %7 = block_result        // Either %5 or %6                   │
│                                                                      │
│ 4. Store in &#34;max&#34;:                                                  │
│    %8 = store(&#34;max&#34;, %7)                                           │
│                                                                      │
│ VISUAL FLOW:                                                        │
│ ─────────────────────────────                                       │
│                                                                      │
│                  ┌─────────────┐                                    │
│                  │ %3 = a &gt; b? │                                    │
│                  └──────┬──────┘                                    │
│                         │                                           │
│              ┌──────────┴──────────┐                                │
│              │ condbr              │                                │
│         true │                     │ false                          │
│              ▼                     ▼                                │
│     ┌─────────────┐       ┌─────────────┐                          │
│     │ %5 = a      │       │ %6 = b      │                          │
│     │ br(end, %5) │       │ br(end, %6) │                          │
│     └──────┬──────┘       └──────┬──────┘                          │
│            │                     │                                  │
│            └─────────┬───────────┘                                  │
│                      ▼                                              │
│             ┌─────────────┐                                         │
│             │ end:        │                                         │
│             │ %7 = result │                                         │
│             └─────────────┘                                         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Example 3: Function Definition
    <div id="example-3-function-definition" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-3-function-definition" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Let&rsquo;s trace <code>fn add(a: u32, b: u32) u32 { return a + b; }</code>:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ EXAMPLE: fn add(a: u32, b: u32) u32 { return a + b; }              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ This generates ZIR at TWO levels:                                   │
│                                                                      │
│ LEVEL 1: Function Declaration (at file scope)                       │
│ ─────────────────────────────                                       │
│                                                                      │
│   %1 = declaration(&#34;add&#34;)     // Declare that &#34;add&#34; exists         │
│   %2 = func(...)              // Function details                  │
│                                                                      │
│ LEVEL 2: Function Body (inside the function)                        │
│ ─────────────────────────────                                       │
│                                                                      │
│   %10 = block {               // Function body block               │
│       %11 = param(0)          // First parameter (a)               │
│       %12 = param(1)          // Second parameter (b)              │
│       %13 = add(%11, %12)     // a + b                             │
│       %14 = ret(%13)          // return the result                 │
│   }                                                                  │
│                                                                      │
│ WHAT EACH INSTRUCTION MEANS:                                        │
│ ─────────────────────────────                                       │
│                                                                      │
│   param(0)                                                          │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ &#34;Give me the first parameter that was passed to this        │  │
│   │  function. I don&#39;t know its type yet (that&#39;s for Sema),    │  │
│   │  but I know it&#39;s parameter number 0.&#34;                       │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
│   param(1)                                                          │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ &#34;Give me the second parameter (index 1).&#34;                   │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
│   add(%11, %12)                                                     │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ &#34;Add the values from instructions 11 and 12 together.       │  │
│   │  I don&#39;t know if they&#39;re u32, i64, or floats - Sema will   │  │
│   │  figure that out and pick the right machine instruction.&#34;  │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
│   ret(%13)                                                          │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ &#34;Return from this function with the value from              │  │
│   │  instruction 13. Sema will verify it matches the declared  │  │
│   │  return type (u32).&#34;                                        │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Example 4: Loop
    <div id="example-4-loop" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-4-loop" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Let&rsquo;s trace a while loop:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ EXAMPLE: while (i &lt; 10) { sum += i; i += 1; }                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ ZIR STRUCTURE:                                                      │
│                                                                      │
│   loop_block: {                                                     │
│       // 1. Check condition                                         │
│       %1 = load(&#34;i&#34;)                                               │
│       %2 = int(10)                                                 │
│       %3 = cmp_lt(%1, %2)       // i &lt; 10?                         │
│                                                                      │
│       // 2. Branch based on condition                               │
│       %4 = condbr(%3)                                              │
│            │                                                        │
│            ├──► continue (condition true):                         │
│            │       // Loop body                                    │
│            │       %5 = load(&#34;sum&#34;)                                │
│            │       %6 = load(&#34;i&#34;)                                  │
│            │       %7 = add(%5, %6)                                │
│            │       %8 = store(&#34;sum&#34;, %7)   // sum += i             │
│            │                                                        │
│            │       %9 = load(&#34;i&#34;)                                  │
│            │       %10 = int(1)                                    │
│            │       %11 = add(%9, %10)                              │
│            │       %12 = store(&#34;i&#34;, %11)   // i += 1               │
│            │                                                        │
│            │       %13 = repeat(loop_block) // Jump back to start  │
│            │                                                        │
│            └──► break (condition false):                           │
│                    %14 = break(loop_block)  // Exit the loop       │
│   }                                                                  │
│                                                                      │
│ VISUAL FLOW:                                                        │
│                                                                      │
│   ┌──────────────────────────────────────────────┐                 │
│   │                                              │                 │
│   │    ┌─────────────────┐                       │                 │
│   └───►│  i &lt; 10?        │                       │                 │
│        └────────┬────────┘                       │                 │
│                 │                                │                 │
│        ┌───────┴───────┐                        │                 │
│        │ true          │ false                  │                 │
│        ▼               ▼                        │                 │
│   ┌─────────┐    ┌──────────┐                  │                 │
│   │sum += i │    │  EXIT    │                  │                 │
│   │i += 1   │    │  LOOP    │                  │                 │
│   └────┬────┘    └──────────┘                  │                 │
│        │                                        │                 │
│        └────────────────────────────────────────┘                 │
│              (repeat - jump back)                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Part 6: How AstGen Walks the Tree
    <div id="part-6-how-astgen-walks-the-tree" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-6-how-astgen-walks-the-tree" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">The Main Pattern: Recursive Descent
    <div id="the-main-pattern-recursive-descent" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-main-pattern-recursive-descent" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>AstGen uses the same pattern as the parser - functions call other functions:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ ASTGEN RECURSIVE PATTERN                                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ The main function is `expr()` - it handles ANY expression:         │
│                                                                      │
│   fn expr(node) -&gt; ZirInstruction {                                │
│       switch (node.type) {                                         │
│           .add =&gt; {                                                │
│               // First, generate ZIR for left side                 │
│               lhs = expr(node.left);   // RECURSE!                │
│                                                                      │
│               // Then, generate ZIR for right side                 │
│               rhs = expr(node.right);  // RECURSE!                │
│                                                                      │
│               // Finally, generate the add instruction             │
│               return addInstruction(.add, lhs, rhs);               │
│           },                                                        │
│                                                                      │
│           .number =&gt; {                                             │
│               // Base case - no recursion needed                   │
│               return addInstruction(.int, node.value);             │
│           },                                                        │
│                                                                      │
│           .if_expr =&gt; {                                            │
│               cond = expr(node.condition);  // RECURSE             │
│               then = expr(node.then_body);  // RECURSE             │
│               els = expr(node.else_body);   // RECURSE             │
│               return addInstruction(.condbr, cond, then, els);     │
│           },                                                        │
│                                                                      │
│           // ... many more cases                                    │
│       }                                                             │
│   }                                                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Trace: Processing <code>(1 + 2) * 3</code>
    <div id="trace-processing-1--2--3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#trace-processing-1--2--3" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ TRACE: (1 + 2) * 3                                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ AST:          *                                                     │
│              / \                                                     │
│             +   3                                                   │
│            / \                                                       │
│           1   2                                                     │
│                                                                      │
│ EXECUTION:                                                          │
│                                                                      │
│ expr( * ) called                                                    │
│ │                                                                   │
│ │  &#34;I need to process a multiply. Let me get my operands...&#34;       │
│ │                                                                   │
│ ├──► expr( + ) called  // Get left operand                         │
│ │    │                                                              │
│ │    │  &#34;I need to process an add. Let me get MY operands...&#34;      │
│ │    │                                                              │
│ │    ├──► expr( 1 ) called  // Get left operand                    │
│ │    │    │                                                        │
│ │    │    │  &#34;This is just a number. Easy!&#34;                        │
│ │    │    │  EMIT: %1 = int(1)                                     │
│ │    │    │  return %1                                             │
│ │    │    │                                                        │
│ │    │◄───┘                                                        │
│ │    │                                                              │
│ │    ├──► expr( 2 ) called  // Get right operand                   │
│ │    │    │                                                        │
│ │    │    │  &#34;This is just a number. Easy!&#34;                        │
│ │    │    │  EMIT: %2 = int(2)                                     │
│ │    │    │  return %2                                             │
│ │    │    │                                                        │
│ │    │◄───┘                                                        │
│ │    │                                                              │
│ │    │  &#34;Now I have both operands: %1 and %2&#34;                      │
│ │    │  EMIT: %3 = add(%1, %2)                                     │
│ │    │  return %3                                                  │
│ │    │                                                              │
│ │◄───┘                                                              │
│ │                                                                   │
│ ├──► expr( 3 ) called  // Get right operand                        │
│ │    │                                                              │
│ │    │  &#34;This is just a number. Easy!&#34;                              │
│ │    │  EMIT: %4 = int(3)                                          │
│ │    │  return %4                                                   │
│ │    │                                                              │
│ │◄───┘                                                              │
│ │                                                                   │
│ │  &#34;Now I have both operands: %3 and %4&#34;                           │
│ │  EMIT: %5 = mul(%3, %4)                                          │
│ │  return %5                                                        │
│                                                                      │
│ FINAL ZIR:                                                          │
│   %1 = int(1)                                                       │
│   %2 = int(2)                                                       │
│   %3 = add(%1, %2)     // 1 + 2                                    │
│   %4 = int(3)                                                       │
│   %5 = mul(%3, %4)     // (1 + 2) * 3                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Part 7: Source Location Tracking
    <div id="part-7-source-location-tracking" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-7-source-location-tracking" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">Why Track Locations?
    <div id="why-track-locations" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-track-locations" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>When there&rsquo;s an error, we need to tell the user WHERE:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ ERROR MESSAGES NEED LOCATION INFO                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ BAD error message:                                                  │
│   &#34;Error: type mismatch&#34;                                            │
│   (Where?? In which file? Which line?)                             │
│                                                                      │
│ GOOD error message:                                                 │
│   &#34;Error: type mismatch&#34;                                            │
│   &#34; --&gt; src/main.zig:42:15&#34;                                        │
│   &#34; |&#34;                                                              │
│   &#34;42 |     const x: u32 = &#34;hello&#34;;&#34;                               │
│   &#34; |                   ^^^^^^^ expected &#39;u32&#39;, found string&#34;     │
│                                                                      │
│ To produce good errors, ZIR must remember where each instruction   │
│ came from in the source code!                                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">How Locations are Stored
    <div id="how-locations-are-stored" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-locations-are-stored" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ SOURCE LOCATION IN ZIR                                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Each ZIR instruction can reference the AST node it came from:      │
│                                                                      │
│   ZIR Instruction {                                                 │
│       tag: .add,                                                    │
│       data: {                                                       │
│           src_node: 47,    // ← &#34;I came from AST node 47&#34;          │
│           lhs: %3,                                                  │
│           rhs: %5,                                                  │
│       }                                                              │
│   }                                                                  │
│                                                                      │
│ AST node 47 knows its token, and tokens know their position:       │
│                                                                      │
│   AST Node 47 {                                                     │
│       tag: .add,                                                    │
│       main_token: 123,     // ← The &#34;+&#34; token                      │
│   }                                                                  │
│                                                                      │
│   Token 123 {                                                       │
│       tag: .plus,                                                   │
│       start: 1547,         // ← Byte position in source file       │
│   }                                                                  │
│                                                                      │
│ Chain: ZIR instruction → AST node → Token → Source position        │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Part 8: The String Table
    <div id="part-8-the-string-table" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-8-the-string-table" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">Why a String Table?
    <div id="why-a-string-table" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-a-string-table" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Identifiers and strings appear many times. Instead of copying them, we store them once:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ STRING TABLE OPTIMIZATION                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Code with repeated identifiers:                                     │
│                                                                      │
│   fn calculate(value: i32) i32 {                                   │
│       const temp = value * 2;                                      │
│       return temp + value;                                         │
│   }                                                                  │
│                                                                      │
│ WITHOUT string table (wasteful):                                    │
│                                                                      │
│   Instruction 1: { name: &#34;calculate&#34;, ... }   // 9 bytes           │
│   Instruction 2: { name: &#34;value&#34;, ... }       // 5 bytes           │
│   Instruction 3: { name: &#34;i32&#34;, ... }         // 3 bytes           │
│   Instruction 4: { name: &#34;i32&#34;, ... }         // 3 bytes DUPLICATE│
│   Instruction 5: { name: &#34;temp&#34;, ... }        // 4 bytes           │
│   Instruction 6: { name: &#34;value&#34;, ... }       // 5 bytes DUPLICATE│
│   Instruction 7: { name: &#34;temp&#34;, ... }        // 4 bytes DUPLICATE│
│   Instruction 8: { name: &#34;value&#34;, ... }       // 5 bytes DUPLICATE│
│                                                                      │
│ WITH string table (efficient):                                      │
│                                                                      │
│   String Table:                                                     │
│   ┌─────┬─────────────────────────────────────┐                    │
│   │  0  │  \0                                 │ (empty string)     │
│   │  1  │  c a l c u l a t e \0              │                     │
│   │ 11  │  v a l u e \0                      │                     │
│   │ 17  │  i 3 2 \0                          │                     │
│   │ 21  │  t e m p \0                        │                     │
│   └─────┴─────────────────────────────────────┘                    │
│                                                                      │
│   Instructions (just store index):                                  │
│   Instruction 1: { name_index: 1, ... }   // &#34;calculate&#34;           │
│   Instruction 2: { name_index: 11, ... }  // &#34;value&#34;               │
│   Instruction 3: { name_index: 17, ... }  // &#34;i32&#34;                 │
│   Instruction 4: { name_index: 17, ... }  // &#34;i32&#34; (same index!)  │
│   Instruction 5: { name_index: 21, ... }  // &#34;temp&#34;                │
│   Instruction 6: { name_index: 11, ... }  // &#34;value&#34; (same index!)│
│   ...                                                               │
│                                                                      │
│ Memory saved by not duplicating strings!                            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Part 9: Putting It All Together
    <div id="part-9-putting-it-all-together" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-9-putting-it-all-together" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">Complete Example: Full Function
    <div id="complete-example-full-function" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#complete-example-full-function" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Let&rsquo;s trace a complete function through AstGen:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">fn</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ COMPLETE ZIR OUTPUT FOR max() FUNCTION                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ // File-level declaration                                           │
│ %0 = declaration {                                                  │
│     name: &#34;max&#34;,                                                    │
│     type: function,                                                 │
│ }                                                                    │
│                                                                      │
│ // Function body                                                    │
│ %1 = func {                                                         │
│     params: [                                                       │
│         { name: &#34;a&#34;, type_expr: &#34;i32&#34; },                           │
│         { name: &#34;b&#34;, type_expr: &#34;i32&#34; },                           │
│     ],                                                               │
│     return_type_expr: &#34;i32&#34;,                                        │
│     body: %2,                                                       │
│ }                                                                    │
│                                                                      │
│ // The actual body block                                            │
│ %2 = block {                                                        │
│     // Get parameters                                               │
│     %3 = param(0)              // a                                │
│     %4 = param(1)              // b                                │
│                                                                      │
│     // Evaluate condition: a &gt; b                                   │
│     %5 = cmp_gt(%3, %4)                                            │
│                                                                      │
│     // Conditional branch                                           │
│     %6 = condbr(%5, then_body: %7, else_body: %8)                  │
│                                                                      │
│     // Then branch: return a                                        │
│     %7 = block {                                                    │
│         %9 = ret(%3)           // return a                         │
│     }                                                                │
│                                                                      │
│     // Else branch: return b                                        │
│     %8 = block {                                                    │
│         %10 = ret(%4)          // return b                         │
│     }                                                                │
│ }                                                                    │
│                                                                      │
│ ─────────────────────────────────────────────────────────────────── │
│                                                                      │
│ WHAT SEMA WILL DO WITH THIS:                                        │
│                                                                      │
│ 1. See param(0), param(1) → look up that they&#39;re i32               │
│ 2. See cmp_gt → verify both operands are comparable                │
│ 3. See ret(%3) → verify i32 matches return type                    │
│ 4. See ret(%4) → verify i32 matches return type                    │
│ 5. If all checks pass → generate typed AIR                         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Part 10: The Big Picture
    <div id="part-10-the-big-picture" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#part-10-the-big-picture" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">Where ZIR Fits
    <div id="where-zir-fits" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#where-zir-fits" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ THE COMPLETE COMPILATION PIPELINE                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                     SOURCE CODE                              │  │
│   │         fn add(a: u32, b: u32) u32 { return a+b; }          │  │
│   └────────────────────────┬────────────────────────────────────┘  │
│                            │                                        │
│                            ▼                                        │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                      TOKENIZER                               │  │
│   │  Breaks into: [fn] [add] [(] [a] [:] [u32] ...              │  │
│   └────────────────────────┬────────────────────────────────────┘  │
│                            │                                        │
│                            ▼                                        │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                        PARSER                                │  │
│   │  Builds tree structure (AST)                                 │  │
│   │  Knows: syntax structure, operator precedence                │  │
│   │  Doesn&#39;t know: types, validity                              │  │
│   └────────────────────────┬────────────────────────────────────┘  │
│                            │                                        │
│                            ▼                                        │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                       ASTGEN                                 │  │
│   │  Converts tree → linear instructions (ZIR)                  │  │
│   │  Knows: execution order, instruction sequence               │  │
│   │  Doesn&#39;t know: types, sizes, validity    ◄─── YOU ARE HERE │  │
│   └────────────────────────┬────────────────────────────────────┘  │
│                            │                                        │
│                            ▼                                        │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                        SEMA                                  │  │
│   │  Type checks and produces typed AIR                         │  │
│   │  Knows: types, sizes, validity                              │  │
│   │  Catches: type errors, undefined variables                  │  │
│   └────────────────────────┬────────────────────────────────────┘  │
│                            │                                        │
│                            ▼                                        │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                      CODEGEN                                 │  │
│   │  Generates actual machine code                              │  │
│   │  Knows: CPU instructions, registers, memory layout          │  │
│   └────────────────────────┬────────────────────────────────────┘  │
│                            │                                        │
│                            ▼                                        │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                    MACHINE CODE                              │  │
│   │           mov rax, rdi                                      │  │
│   │           add rax, rsi                                      │  │
│   │           ret                                               │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">The Scope System
    <div id="the-scope-system" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-scope-system" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>AstGen uses a sophisticated scope system to track identifiers. There are seven scope types:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ ASTGEN SCOPE TYPES                                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. Scope.Top           File-level scope (the root)                 │
│                                                                      │
│ 2. GenZir              Block-level state tracking                  │
│                        Tracks current block&#39;s instructions          │
│                                                                      │
│ 3. Scope.Namespace     Unordered declaration sets                  │
│                        For structs, enums, etc.                     │
│                                                                      │
│ 4. Scope.LocalVal      Individual identifier bindings              │
│    Scope.LocalPtr      (value vs pointer semantics)                │
│                                                                      │
│ 5. Scope.Defer         Defer/errdefer tracking                     │
│                        Knows what to run on scope exit             │
│                                                                      │
│ When you reference a variable, AstGen walks UP through scopes      │
│ until it finds the definition - this is how shadowing works.       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">String Interning
    <div id="string-interning" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#string-interning" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>All strings in ZIR are interned into a single <code>string_bytes</code> array and referenced by offset:</p>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ STRING INTERNING                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Instead of:                                                          │
│   instruction1 { name: &#34;add&#34; }      ← 3 bytes                       │
│   instruction2 { name: &#34;add&#34; }      ← 3 more bytes (duplicate!)     │
│   instruction3 { name: &#34;multiply&#34; } ← 8 bytes                       │
│                                                                      │
│ ZIR stores:                                                          │
│   string_bytes: &#34;add\0multiply\0&#34;   ← All strings together          │
│                  ↑    ↑                                              │
│                  0    4                                              │
│                                                                      │
│   instruction1 { name_offset: 0 }   ← Just an integer               │
│   instruction2 { name_offset: 0 }   ← Same offset = same string     │
│   instruction3 { name_offset: 4 }   ← Points to &#34;multiply&#34;          │
│                                                                      │
│ Benefits:                                                            │
│   • Deduplication is automatic                                      │
│   • Comparison is just integer equality                             │
│   • After ZIR is built, the AST and source can be freed            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Summary: What ZIR Achieves
    <div id="summary-what-zir-achieves" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#summary-what-zir-achieves" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌─────────────────────────────────────────────────────────────────────┐
│ ZIR KEY POINTS                                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. LINEARIZES THE AST                                               │
│    Tree structure → Sequential instructions                         │
│    Easier to process, closer to how CPUs work                      │
│                                                                      │
│ 2. UNTYPED BY DESIGN                                                │
│    No type information embedded                                     │
│    Enables caching, generics, lazy analysis                        │
│                                                                      │
│ 3. PRESERVES SOURCE LOCATIONS                                       │
│    Every instruction knows where it came from                       │
│    Enables precise error messages                                   │
│                                                                      │
│ 4. ONE PER SOURCE FILE                                              │
│    Each .zig file gets its own ZIR                                 │
│    Can be cached to disk for faster rebuilds                       │
│                                                                      │
│ 5. REFERENCE-BASED                                                  │
│    Instructions refer to each other by number (%1, %2, ...)        │
│    Creates a directed graph of dependencies                        │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Try It Yourself
    <div id="try-it-yourself" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#try-it-yourself" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Dump the ZIR for any Zig file to see how your code is represented:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Dump ZIR for a file</span>
</span></span><span class="line"><span class="cl">zig ast-check -t your_file.zig
</span></span></code></pre></td></tr></table>
</div>
</div><p>This is invaluable for understanding how Zig transforms your high-level code into intermediate representation.</p>
<hr>

<h2 class="relative group">Further Reading
    <div id="further-reading" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#further-reading" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>For deeper exploration of ZIR and AstGen:</p>
<ul>
<li>
<p><strong><a
  href="https://mitchellh.com/zig/astgen"
    target="_blank"
  >Zig AstGen: AST =&gt; ZIR</a></strong> by Mitchell Hashimoto - Comprehensive walkthrough of how AST nodes become ZIR instructions.</p>
</li>
<li>
<p><strong><a
  href="https://github.com/ziglang/zig/wiki/Glossary"
    target="_blank"
  >Zig GitHub Wiki Glossary</a></strong> - Official definitions including ZIR&rsquo;s ~400 instruction types.</p>
</li>
<li>
<p><strong>Source Code</strong>: <a
  href="https://github.com/ziglang/zig/blob/master/src/AstGen.zig"
    target="_blank"
  ><code>src/AstGen.zig</code></a> and <a
  href="https://github.com/ziglang/zig/blob/master/lib/std/zig/Zir.zig"
    target="_blank"
  ><code>lib/std/zig/Zir.zig</code></a> - The implementations.</p>
</li>
</ul>
<hr>

<h2 class="relative group">Conclusion
    <div id="conclusion" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#conclusion" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>ZIR is the bridge between the human-readable AST and the type-checked AIR. By keeping ZIR untyped, Zig enables:</p>
<ul>
<li><strong>Caching</strong>: Save ZIR to disk, skip parsing on rebuild</li>
<li><strong>Generics</strong>: Same ZIR instantiated with different types</li>
<li><strong>Lazy Analysis</strong>: Only type-check what&rsquo;s actually used</li>
<li><strong>Incremental Compilation</strong>: Change one file, don&rsquo;t re-analyze everything</li>
</ul>
<p>In the next article, we&rsquo;ll dive into <strong>Sema</strong> (Semantic Analysis), where ZIR is transformed into typed AIR and the real type checking happens.</p>
<hr>
<p><strong>Previous</strong>: <a
  href="./03-parser-ast.md">Part 3: Parser and AST</a>
<strong>Next</strong>: <a
  href="./05-sema.md">Part 5: Semantic Analysis</a></p>
<p><strong>Series Index</strong>:</p>
<ol>
<li><a
  href="./01-bootstrap-process.md">Bootstrap Process</a></li>
<li><a
  href="./02-tokenizer.md">Tokenizer</a></li>
<li><a
  href="./03-parser-ast.md">Parser and AST</a></li>
<li><strong>ZIR Generation</strong> (this article)</li>
<li><a
  href="./05-sema.md">Semantic Analysis</a></li>
<li><a
  href="./06-air-codegen.md">AIR and Code Generation</a></li>
<li><a
  href="./07-linking.md">Linking</a></li>
</ol>

          
          
          
        </div>
        
        

        

        

      </div>

      
      
        
        
          
          
        
        
        
        <script
          type="text/javascript"
          src="/js/page.min.54b6f4371722649edbe871e431d8670d670878c22be8f36e229fe53cc9b786fe25a834def5e6de621f7a3e37b72bc8cd73839aa5ed907ed6cbd45cd3e1b0fa20.js"
          integrity="sha512-VLb0NxciZJ7b6HHkMdhnDWcIeMIr6PNuIp/lPMm3hv4lqDTe9ebeYh96Pje3K8jNc4Oape2QftbL1FzT4bD6IA=="
          data-oid="views_drafts/04-zir-generation.md"
          data-oid-likes="likes_drafts/04-zir-generation.md"></script>
      
    </section>

    
    <footer class="pt-8 max-w-prose print:hidden">
      
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600">
      <div class="flex justify-between pt-3">
        <span class="flex flex-col">
          
            <a
              class="flex text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
              href="/drafts/05-sema/">
              <span class="leading-6">
                <span class="inline-block rtl:rotate-180">&larr;</span>&ensp;Zig Compiler Internals Part 5: Semantic Analysis
              </span>
            </a>
            
              <span class="ms-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                <time datetime="2025-12-17T00:00:00&#43;00:00">December 17, 2025</time>
              </span>
            
          
        </span>
        <span class="flex flex-col items-end">
          
            <a
              class="flex text-right text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
              href="/drafts/03-parser-ast/">
              <span class="leading-6">
                Zig Compiler Internals Part 3: Parser and AST&ensp;<span class="inline-block rtl:rotate-180">&rarr;</span>
              </span>
            </a>
            
              <span class="me-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                <time datetime="2025-12-17T00:00:00&#43;00:00">December 17, 2025</time>
              </span>
            
          
        </span>
      </div>
    </div>
  


      
    </footer>
  </article>

        


  






<div
  id="scroll-to-top"
  class="fixed bottom-6 end-6 z-50 transform translate-y-4 opacity-0 duration-200">
  <a
    href="#the-top"
    class="pointer-events-auto flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="Scroll to top"
    title="Scroll to top">
    &uarr;
  </a>
</div>

      </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
  
  <div class="flex items-center justify-between">
    
    
      <p class="text-sm text-neutral-500 dark:text-neutral-400">
          &copy;
          2025
          Yohai
      </p>
    

    
    
      <p class="text-xs text-neutral-500 dark:text-neutral-400">
        
        
        Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
          href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
          href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a>
      </p>
    
  </div>
  
    <script>
      mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
        margin: 24,
        background: "rgba(0,0,0,0.5)",
        scrollOffset: 0,
      });
    </script>
  
  
  
  <script
    type="text/javascript"
    src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js"
    integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh] z-500"
  data-url="http://localhost:1313/">
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800">
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="Search"
          tabindex="0">
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="Close (Esc)">
        <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>
</span>
      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

    </div>
  </body>
  
</html>
