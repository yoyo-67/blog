<!doctype html>
<html
  lang="en-us"
  dir="ltr"
  class="scroll-smooth"
  data-default-appearance="dark"
  data-auto-appearance="true"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  
    <meta http-equiv="content-language" content="en-us">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color">

  
  
    <title>How to Design a Grammar for Your Programming Language &middot; Yohai&#39;s Blog</title>
    <meta name="title" content="How to Design a Grammar for Your Programming Language &middot; Yohai&#39;s Blog">
  

  
  
  
  
  
  <link rel="canonical" href="http://localhost:1313/drafts/how-to-design-a-grammar/">
  

  
  
    <meta name="author" content="Yohai">
  
  

  
  <meta property="og:url" content="http://localhost:1313/drafts/how-to-design-a-grammar/">
  <meta property="og:site_name" content="Yohai&#39;s Blog">
  <meta property="og:title" content="How to Design a Grammar for Your Programming Language">
  <meta property="og:description" content="How to Design a Grammar for Your Programming Language # From tokens to trees: the missing guide
Introduction # You’ve built a lexer. It takes source code and spits out tokens:
Source: 1 &#43; 2 * 3 Tokens: [NUMBER(1), PLUS, NUMBER(2), STAR, NUMBER(3)] Now what?
If you try to process these tokens one by one, you’ll quickly run into problems. How do you know that * should happen before &#43;? How do you handle parentheses? How do you parse x = 1 &#43; 2 where the = needs to wrap the whole right side?">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="drafts">
    <meta property="article:published_time" content="2025-12-20T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-12-20T00:00:00+00:00">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="How to Design a Grammar for Your Programming Language">
  <meta name="twitter:description" content="How to Design a Grammar for Your Programming Language # From tokens to trees: the missing guide
Introduction # You’ve built a lexer. It takes source code and spits out tokens:
Source: 1 &#43; 2 * 3 Tokens: [NUMBER(1), PLUS, NUMBER(2), STAR, NUMBER(3)] Now what?
If you try to process these tokens one by one, you’ll quickly run into problems. How do you know that * should happen before &#43;? How do you handle parentheses? How do you parse x = 1 &#43; 2 where the = needs to wrap the whole right side?">

  
  
  
  
    
      
    
  
    
      
    
  
    
      
    
  
  
    
  

  
  
  
  
  
  

  

  
  
  
  
  
  
  
  
    
  
  
  <link
    type="text/css"
    rel="stylesheet"
    href="/css/main.bundle.min.0975a8c7c266a0697f94839b45e1574c449de253527d44ed516d5c5c3c820c9389d7d86576faae12267b129f8749ecbf7581cddb636aba7690aa633b95aaa87d.css"
    integrity="sha512-CXWox8JmoGl/lIObReFXTESd4lNSfUTtUW1cXDyCDJOJ19hldvquEiZ7Ep&#43;HSey/dYHN22NqunaQqmM7laqofQ==">

  
  
  <script
    type="text/javascript"
    src="/js/appearance.min.6f41174b3a05b680820fe08cadbfa5fb7a7ca347b76a0955cdc68b9d8aca1ce24f0547e138cea33bcc7904d551a90afcb1cc7f2d9fe8557075d501419046c08c.js"
    integrity="sha512-b0EXSzoFtoCCD&#43;CMrb&#43;l&#43;3p8o0e3aglVzcaLnYrKHOJPBUfhOM6jO8x5BNVRqQr8scx/LZ/oVXB11QFBkEbAjA=="></script>
  
  
  
  
  
  
    
    <script src="/lib/zoom/zoom.min.umd.a527109b68c082a70f3697716dd72a9d5aa8b545cf800cecbbc7399f2ca6f6e0ce3e431f2062b48bbfa47c9ea42822714060bef309be073f49b9c0e30d318d7b.js" integrity="sha512-pScQm2jAgqcPNpdxbdcqnVqotUXPgAzsu8c5nyym9uDOPkMfIGK0i7&#43;kfJ6kKCJxQGC&#43;8wm&#43;Bz9JucDjDTGNew=="></script>
  

  
  
  
    
  
  
    
  
  
    
  
  
  
  
  
  
    
    <script
      defer
      type="text/javascript"
      id="script-bundle"
      src="/js/main.bundle.min.9cc802d09f28c6af56ceee7bc6e320a39251fdae98243f2a9942f221ac57a9f49c51609699a91794a7b2580ee1deaa8e4d794a68ffa94aa317c66e893ce51e02.js"
      integrity="sha512-nMgC0J8oxq9Wzu57xuMgo5JR/a6YJD8qmULyIaxXqfScUWCWmakXlKeyWA7h3qqOTXlKaP&#43;pSqMXxm6JPOUeAg=="
      data-copy="Copy"
      data-copied="Copied"></script>
  

  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>


























  

  

  

  

  





  
  
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
  

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Drafts",
    "name": "How to Design a Grammar for Your Programming Language",
    "headline": "How to Design a Grammar for Your Programming Language",
    
    "abstract": "\u003ch1 class=\u0022relative group\u0022\u003eHow to Design a Grammar for Your Programming Language\n    \u003cdiv id=\u0022how-to-design-a-grammar-for-your-programming-language\u0022 class=\u0022anchor\u0022\u003e\u003c\/div\u003e\n    \n    \u003cspan\n        class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\u0022\u003e\n        \u003ca class=\u0022text-primary-300 dark:text-neutral-700 !no-underline\u0022 href=\u0022#how-to-design-a-grammar-for-your-programming-language\u0022 aria-label=\u0022Anchor\u0022\u003e#\u003c\/a\u003e\n    \u003c\/span\u003e\n    \n\u003c\/h1\u003e\n\u003cp\u003e\u003cem\u003eFrom tokens to trees: the missing guide\u003c\/em\u003e\u003c\/p\u003e\n\u003chr\u003e\n\n\u003ch2 class=\u0022relative group\u0022\u003eIntroduction\n    \u003cdiv id=\u0022introduction\u0022 class=\u0022anchor\u0022\u003e\u003c\/div\u003e\n    \n    \u003cspan\n        class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\u0022\u003e\n        \u003ca class=\u0022text-primary-300 dark:text-neutral-700 !no-underline\u0022 href=\u0022#introduction\u0022 aria-label=\u0022Anchor\u0022\u003e#\u003c\/a\u003e\n    \u003c\/span\u003e\n    \n\u003c\/h2\u003e\n\u003cp\u003eYou\u0026rsquo;ve built a lexer. It takes source code and spits out tokens:\u003c\/p\u003e\n\u003cpre tabindex=\u00220\u0022\u003e\u003ccode\u003eSource: 1 \u002b 2 * 3\nTokens: [NUMBER(1), PLUS, NUMBER(2), STAR, NUMBER(3)]\n\u003c\/code\u003e\u003c\/pre\u003e\u003cp\u003eNow what?\u003c\/p\u003e\n\u003cp\u003eIf you try to process these tokens one by one, you\u0026rsquo;ll quickly run into problems. How do you know that \u003ccode\u003e*\u003c\/code\u003e should happen before \u003ccode\u003e\u002b\u003c\/code\u003e? How do you handle parentheses? How do you parse \u003ccode\u003ex = 1 \u002b 2\u003c\/code\u003e where the \u003ccode\u003e=\u003c\/code\u003e needs to wrap the whole right side?\u003c\/p\u003e",
    "inLanguage": "en-us",
    "url" : "http://localhost:1313/drafts/how-to-design-a-grammar/",
    "author" : {
      "@type": "Person",
      "name": "Yohai"
    },
    "copyrightYear": "2025",
    "dateCreated": "2025-12-20T00:00:00\u002b00:00",
    "datePublished": "2025-12-20T00:00:00\u002b00:00",
    
    "dateModified": "2025-12-20T00:00:00\u002b00:00",
    
    
    
    "mainEntityOfPage": "true",
    "wordCount": "11491"
  }]
  </script>



  
  

  
  

  
  

  
  

  
  
</head>


















  
  
  <body class="flex flex-col h-screen m-auto leading-7 max-w-7xl px-6 sm:px-14 md:px-24 lg:px-32 text-lg bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
    <div id="the-top" class="absolute flex self-center">
      <a
        class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
        href="#main-content">
        <span class="font-bold text-primary-600 pe-2 dark:text-primary-400">&darr;</span>
        Skip to main content
      </a>
    </div>
    
    
      













<div
  class="main-menu flex items-center justify-between py-6 md:justify-start gap-x-3 pt-[2px] pr-2 md:pr-4 pb-[3px] pl-0">
  
  

  <div class="flex flex-1 items-center justify-between">
    <nav class="flex space-x-3">
      
        <a href="/" class="text-base font-medium">
          Yohai&rsquo;s Blog
        </a>
      
    </nav>
    
  <nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12">
    
      
        
  <a
  href="/posts/"
  
  class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
  aria-label="Posts"
  title="Posts">
  
  
    <p class="text-base font-medium">
      Posts
    </p>
  
</a>



      
        
  <a
  href="/drafts/"
  
  class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
  aria-label="Drafts"
  title="Drafts">
  
  
    <p class="text-base font-medium">
      Drafts
    </p>
  
</a>



      
        
  <a
  href="/tags/"
  
  class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
  aria-label="Tags"
  title="Tags">
  
  
    <p class="text-base font-medium">
      Tags
    </p>
  
</a>



      
    

    

    

    
      <button
        id="search-button"
        aria-label="Search"
        class="text-base hover:text-primary-600 dark:hover:text-primary-400"
        title="Search (/)">
        <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
      </button>
    

    
      <div class=" flex items-center">
        <button
          id="appearance-switcher"
          aria-label="Dark mode switcher"
          type="button"
          class="text-base hover:text-primary-600 dark:hover:text-primary-400">
          <div class="flex items-center justify-center dark:hidden">
            <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>
</span>
          </div>
          <div class="items-center justify-center hidden dark:flex">
            <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>
</span>
          </div>
        </button>
      </div>
    
  </nav>

    
  <div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12">
    <span></span>

    

    

    
      <button
        id="search-button-mobile"
        aria-label="Search"
        class="text-base hover:text-primary-600 dark:hover:text-primary-400"
        title="Search (/)">
        <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
      </button>
    

    
      <button
        id="appearance-switcher-mobile"
        aria-label="Dark mode switcher"
        type="button"
        class="text-base hover:text-primary-600 dark:hover:text-primary-400 me-1">
        <div class="flex items-center justify-center dark:hidden">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>
</span>
        </div>
        <div class="items-center justify-center hidden dark:flex">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>
</span>
        </div>
      </button>
    
  </div>

  </div>
  
  <div class="-my-2 md:hidden">
    <div id="menu-button" class="block">
      
        <div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>
</span>
        </div>
        <div
          id="menu-wrapper"
          class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50 pt-[5px]">
          <ul
            class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none text-end max-w-7xl">
            <li id="menu-close-button">
              <span
                class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400">
                <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>
</span>
              </span>
            </li>

            
              
  <li class="mt-1">
  <a
    href="/posts/"
    
    class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
    aria-label="Posts"
    title="Posts">
    
    
      <p class="text-bg font-bg">
        Posts
      </p>
    
  </a>
</li>



            
              
  <li class="mt-1">
  <a
    href="/drafts/"
    
    class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
    aria-label="Drafts"
    title="Drafts">
    
    
      <p class="text-bg font-bg">
        Drafts
      </p>
    
  </a>
</li>



            
              
  <li class="mt-1">
  <a
    href="/tags/"
    
    class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"
    aria-label="Tags"
    title="Tags">
    
    
      <p class="text-bg font-bg">
        Tags
      </p>
    
  </a>
</li>



            

          </ul>
          
        </div>
      
    </div>
  </div>

</div>





    
    <div class="relative flex flex-col grow">
      <main id="main-content" class="grow">
        
  
  <article>
    
    

    
    <header id="single_header" class="mt-5 max-w-prose">
      
        <ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden">
  
  
    
  
    
  
  <li class="hidden">
    <a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href="/"
      >Yohai&#39;s Blog</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  <li class="inline">
    <a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href="/drafts/"
      >Drafts</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  <li class="hidden">
    <a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href="/drafts/how-to-design-a-grammar/"
      >How to Design a Grammar for Your Programming Language</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

</ol>


      
      <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
        How to Design a Grammar for Your Programming Language
      </h1>
      <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
        





  
  



  

  
  
  
    
  

  

  
    
  

  

  
    
  

  
    
  

  

  

  

  

  


  <div class="flex flex-row flex-wrap items-center">
    
    
      <time datetime="2025-12-20T00:00:00&#43;00:00">December 20, 2025</time><span class="px-2 text-primary-500">&middot;</span><span>11491 words</span><span class="px-2 text-primary-500">&middot;</span><span title="Reading time">54 mins</span>
    

    
    
  </div>

  

  
  

  
  



      </div>
      
        
  
  
  
  
  
  

  

  
    
    
<div class="flex author">
  
  <div class="place-self-center">
    
      <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
        Author
      </div>
      <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
        Yohai
      </div>
    
    
    <div class="text-2xl sm:text-lg">
</div>
  </div>
</div>

  

  

  
    <div class="mb-5"></div>
  

      
    </header>

    
    <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
      
      
      
      
      
        <div class="order-first lg:ml-auto px-0 lg:order-last lg:ps-8 lg:max-w-2xs">
          <div class="toc ps-5 print:hidden lg:sticky lg:top-10">
            
              <details
  open
  id="TOCView"
  class="toc-right mt-0 overflow-y-auto overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg -ms-5 ps-5 pe-2 hidden lg:block">
  <summary
    class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="min-w-[220px] py-2 border-dotted border-s-1 -ms-5 ps-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#what-is-a-grammar">What is a Grammar?</a></li>
    <li><a href="#the-problem-why-tokens-arent-enough">The Problem: Why Tokens Aren&rsquo;t Enough</a>
      <ul>
        <li><a href="#flat-tokens-dont-show-structure">Flat Tokens Don&rsquo;t Show Structure</a></li>
        <li><a href="#the-solution-build-a-tree">The Solution: Build a Tree</a></li>
        <li><a href="#the-parsers-job">The Parser&rsquo;s Job</a></li>
      </ul>
    </li>
    <li><a href="#your-first-grammar-rule">Your First Grammar Rule</a>
      <ul>
        <li><a href="#the-rule-in-english">The Rule in English</a></li>
        <li><a href="#the-rule-in-grammar-notation">The Rule in Grammar Notation</a></li>
        <li><a href="#how-parsing-works-with-this-rule">How Parsing Works with This Rule</a></li>
        <li><a href="#visual-trace">Visual Trace</a></li>
      </ul>
    </li>
    <li><a href="#problem-what-about-1--2--3">Problem: What About <code>1 + 2 + 3</code>?</a></li>
    <li><a href="#adding-repetition">Adding Repetition</a>
      <ul>
        <li><a href="#the--operator">The <code>*</code> Operator</a></li>
        <li><a href="#how-it-parses">How It Parses</a></li>
        <li><a href="#the-pattern-use-a-loop">The Pattern: Use a Loop</a></li>
        <li><a href="#step-by-step-trace-of-1--2--3">Step-by-Step Trace of <code>1 + 2 + 3</code></a></li>
        <li><a href="#why-left-associative">Why Left-Associative?</a></li>
      </ul>
    </li>
    <li><a href="#the-precedence-problem">The Precedence Problem</a>
      <ul>
        <li><a href="#what-goes-wrong">What Goes Wrong?</a></li>
        <li><a href="#visualizing-the-problem">Visualizing the Problem</a></li>
        <li><a href="#the-key-insight-nesting--precedence">The Key Insight: Nesting = Precedence</a></li>
      </ul>
    </li>
    <li><a href="#solving-precedence-with-nesting">Solving Precedence with Nesting</a>
      <ul>
        <li><a href="#the-two-level-grammar">The Two-Level Grammar</a></li>
        <li><a href="#how-to-read-these-rules">How to Read These Rules</a></li>
        <li><a href="#think-of-it-like-boxes">Think of It Like Boxes</a></li>
        <li><a href="#why-this-gives-correct-precedence">Why This Gives Correct Precedence</a></li>
        <li><a href="#simple-summary">Simple Summary</a></li>
        <li><a href="#why-this-works-step-by-step">Why This Works: Step by Step</a></li>
        <li><a href="#compare-one-rule-vs-two-rules">Compare: One Rule vs Two Rules</a></li>
        <li><a href="#the-golden-rule">The Golden Rule</a></li>
        <li><a href="#detailed-trace-of-1--2--3">Detailed Trace of <code>1 + 2 * 3</code></a></li>
        <li><a href="#the-call-stack-is-the-tree">The Call Stack IS the Tree</a></li>
      </ul>
    </li>
    <li><a href="#adding-unary-operators">Adding Unary Operators</a>
      <ul>
        <li><a href="#the-grammar-rule">The Grammar Rule</a></li>
        <li><a href="#why-unary-is-between-term-and-number">Why Unary is Between Term and Number</a></li>
        <li><a href="#trace-of--1--2">Trace of <code>-1 + 2</code></a></li>
      </ul>
    </li>
    <li><a href="#adding-parentheses">Adding Parentheses</a>
      <ul>
        <li><a href="#the-grammar-rule-1">The Grammar Rule</a></li>
        <li><a href="#trace-of-1--2--3">Trace of <code>(1 + 2) * 3</code></a></li>
      </ul>
    </li>
    <li><a href="#the-complete-expression-grammar">The Complete Expression Grammar</a>
      <ul>
        <li><a href="#visual-summary">Visual Summary</a></li>
        <li><a href="#how-each-rule-maps-to-precedence">How Each Rule Maps to Precedence</a></li>
      </ul>
    </li>
    <li><a href="#from-expressions-to-statements">From Expressions to Statements</a>
      <ul>
        <li><a href="#whats-a-statement">What&rsquo;s a Statement?</a></li>
        <li><a href="#statement-grammar-rules">Statement Grammar Rules</a></li>
        <li><a href="#trace-of-const-x--1--2">Trace of <code>const x = 1 + 2;</code></a></li>
        <li><a href="#trace-of-return-x--1">Trace of <code>return x + 1;</code></a></li>
      </ul>
    </li>
    <li><a href="#adding-blocks">Adding Blocks</a>
      <ul>
        <li><a href="#the-grammar-rule-2">The Grammar Rule</a></li>
        <li><a href="#trace-of--const-x--5-return-x-">Trace of <code>{ const x = 5; return x; }</code></a></li>
      </ul>
    </li>
    <li><a href="#adding-functions">Adding Functions</a>
      <ul>
        <li><a href="#the-grammar-rules">The Grammar Rules</a></li>
        <li><a href="#the--operator-1">The <code>?</code> Operator</a></li>
        <li><a href="#trace-of-fn-adda-i32-b-i32--return-a--b-">Trace of <code>fn add(a: i32, b: i32) { return a + b; }</code></a></li>
      </ul>
    </li>
    <li><a href="#the-complete-grammar">The Complete Grammar</a>
      <ul>
        <li><a href="#structure-diagram">Structure Diagram</a></li>
      </ul>
    </li>
    <li><a href="#grammar-notation-reference">Grammar Notation Reference</a>
      <ul>
        <li><a href="#examples-of-each">Examples of Each</a></li>
      </ul>
    </li>
    <li><a href="#from-grammar-to-code">From Grammar to Code</a>
      <ul>
        <li><a href="#the-template">The Template</a></li>
        <li><a href="#example-expression--term-----term">Example: expression → term ((&quot;+&quot; | &ldquo;-&rdquo;) term)*</a></li>
        <li><a href="#example-unary----unary--primary">Example: unary → &ldquo;-&rdquo; unary | primary</a></li>
        <li><a href="#example-block---statement-">Example: block → &ldquo;{&rdquo; statement* &ldquo;}&rdquo;</a></li>
        <li><a href="#example-function--fn-identifier--parameters--block">Example: function → &ldquo;fn&rdquo; IDENTIFIER &ldquo;(&rdquo; parameters? &ldquo;)&rdquo; block</a></li>
        <li><a href="#the-complete-mapping">The Complete Mapping</a></li>
      </ul>
    </li>
    <li><a href="#the-key-insight">The Key Insight</a></li>
    <li><a href="#extending-the-grammar">Extending the Grammar</a>
      <ul>
        <li><a href="#adding-if-statements">Adding If Statements</a></li>
        <li><a href="#adding-while-loops">Adding While Loops</a></li>
        <li><a href="#adding-more-operators">Adding More Operators</a></li>
        <li><a href="#adding-function-calls">Adding Function Calls</a></li>
      </ul>
    </li>
    <li><a href="#the-grammar-design-process">The Grammar Design Process</a></li>
    <li><a href="#common-patterns">Common Patterns</a>
      <ul>
        <li><a href="#binary-operators-left-associative">Binary Operators (Left-Associative)</a></li>
        <li><a href="#unary-operators-prefix">Unary Operators (Prefix)</a></li>
        <li><a href="#optional-parts">Optional Parts</a></li>
        <li><a href="#lists-with-separators">Lists with Separators</a></li>
        <li><a href="#blocks-of-things">Blocks of Things</a></li>
      </ul>
    </li>
    <li><a href="#complex-example-parsing-a-complete-program">Complex Example: Parsing a Complete Program</a>
      <ul>
        <li><a href="#the-token-stream">The Token Stream</a></li>
        <li><a href="#full-parse-trace">Full Parse Trace</a></li>
        <li><a href="#the-final-ast">The Final AST</a></li>
      </ul>
    </li>
    <li><a href="#right-associativity-assignment-and-exponentiation">Right-Associativity: Assignment and Exponentiation</a>
      <ul>
        <li><a href="#how-to-achieve-right-associativity">How to Achieve Right-Associativity</a></li>
        <li><a href="#why-does-recursion-give-right-associativity">Why Does Recursion Give Right-Associativity?</a></li>
        <li><a href="#exponentiation-example">Exponentiation Example</a></li>
      </ul>
    </li>
    <li><a href="#handling-errors-gracefully">Handling Errors Gracefully</a>
      <ul>
        <li><a href="#types-of-parse-errors">Types of Parse Errors</a></li>
        <li><a href="#the-expect-pattern">The <code>expect</code> Pattern</a></li>
        <li><a href="#error-recovery-synchronization">Error Recovery: Synchronization</a></li>
        <li><a href="#example-multiple-errors">Example: Multiple Errors</a></li>
      </ul>
    </li>
    <li><a href="#lookahead-when-one-token-isnt-enough">Lookahead: When One Token Isn&rsquo;t Enough</a>
      <ul>
        <li><a href="#the-problem">The Problem</a></li>
        <li><a href="#solution-peek-ahead">Solution: Peek Ahead</a></li>
        <li><a href="#when-lookahead-gets-complicated">When Lookahead Gets Complicated</a></li>
      </ul>
    </li>
    <li><a href="#putting-it-all-together-a-complete-parser">Putting It All Together: A Complete Parser</a></li>
    <li><a href="#common-mistakes-to-avoid">Common Mistakes to Avoid</a></li>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#whats-next">What&rsquo;s Next</a></li>
    <li><a href="#quick-reference">Quick Reference</a>
      <ul>
        <li><a href="#our-complete-grammar">Our Complete Grammar</a></li>
        <li><a href="#notation-reference">Notation Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</details>
<details class="toc-inside mt-0 overflow-hidden rounded-lg -ms-5 ps-5 lg:hidden">
  <summary
    class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="py-2 border-dotted border-neutral-300 border-s-1 -ms-5 ps-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#what-is-a-grammar">What is a Grammar?</a></li>
    <li><a href="#the-problem-why-tokens-arent-enough">The Problem: Why Tokens Aren&rsquo;t Enough</a>
      <ul>
        <li><a href="#flat-tokens-dont-show-structure">Flat Tokens Don&rsquo;t Show Structure</a></li>
        <li><a href="#the-solution-build-a-tree">The Solution: Build a Tree</a></li>
        <li><a href="#the-parsers-job">The Parser&rsquo;s Job</a></li>
      </ul>
    </li>
    <li><a href="#your-first-grammar-rule">Your First Grammar Rule</a>
      <ul>
        <li><a href="#the-rule-in-english">The Rule in English</a></li>
        <li><a href="#the-rule-in-grammar-notation">The Rule in Grammar Notation</a></li>
        <li><a href="#how-parsing-works-with-this-rule">How Parsing Works with This Rule</a></li>
        <li><a href="#visual-trace">Visual Trace</a></li>
      </ul>
    </li>
    <li><a href="#problem-what-about-1--2--3">Problem: What About <code>1 + 2 + 3</code>?</a></li>
    <li><a href="#adding-repetition">Adding Repetition</a>
      <ul>
        <li><a href="#the--operator">The <code>*</code> Operator</a></li>
        <li><a href="#how-it-parses">How It Parses</a></li>
        <li><a href="#the-pattern-use-a-loop">The Pattern: Use a Loop</a></li>
        <li><a href="#step-by-step-trace-of-1--2--3">Step-by-Step Trace of <code>1 + 2 + 3</code></a></li>
        <li><a href="#why-left-associative">Why Left-Associative?</a></li>
      </ul>
    </li>
    <li><a href="#the-precedence-problem">The Precedence Problem</a>
      <ul>
        <li><a href="#what-goes-wrong">What Goes Wrong?</a></li>
        <li><a href="#visualizing-the-problem">Visualizing the Problem</a></li>
        <li><a href="#the-key-insight-nesting--precedence">The Key Insight: Nesting = Precedence</a></li>
      </ul>
    </li>
    <li><a href="#solving-precedence-with-nesting">Solving Precedence with Nesting</a>
      <ul>
        <li><a href="#the-two-level-grammar">The Two-Level Grammar</a></li>
        <li><a href="#how-to-read-these-rules">How to Read These Rules</a></li>
        <li><a href="#think-of-it-like-boxes">Think of It Like Boxes</a></li>
        <li><a href="#why-this-gives-correct-precedence">Why This Gives Correct Precedence</a></li>
        <li><a href="#simple-summary">Simple Summary</a></li>
        <li><a href="#why-this-works-step-by-step">Why This Works: Step by Step</a></li>
        <li><a href="#compare-one-rule-vs-two-rules">Compare: One Rule vs Two Rules</a></li>
        <li><a href="#the-golden-rule">The Golden Rule</a></li>
        <li><a href="#detailed-trace-of-1--2--3">Detailed Trace of <code>1 + 2 * 3</code></a></li>
        <li><a href="#the-call-stack-is-the-tree">The Call Stack IS the Tree</a></li>
      </ul>
    </li>
    <li><a href="#adding-unary-operators">Adding Unary Operators</a>
      <ul>
        <li><a href="#the-grammar-rule">The Grammar Rule</a></li>
        <li><a href="#why-unary-is-between-term-and-number">Why Unary is Between Term and Number</a></li>
        <li><a href="#trace-of--1--2">Trace of <code>-1 + 2</code></a></li>
      </ul>
    </li>
    <li><a href="#adding-parentheses">Adding Parentheses</a>
      <ul>
        <li><a href="#the-grammar-rule-1">The Grammar Rule</a></li>
        <li><a href="#trace-of-1--2--3">Trace of <code>(1 + 2) * 3</code></a></li>
      </ul>
    </li>
    <li><a href="#the-complete-expression-grammar">The Complete Expression Grammar</a>
      <ul>
        <li><a href="#visual-summary">Visual Summary</a></li>
        <li><a href="#how-each-rule-maps-to-precedence">How Each Rule Maps to Precedence</a></li>
      </ul>
    </li>
    <li><a href="#from-expressions-to-statements">From Expressions to Statements</a>
      <ul>
        <li><a href="#whats-a-statement">What&rsquo;s a Statement?</a></li>
        <li><a href="#statement-grammar-rules">Statement Grammar Rules</a></li>
        <li><a href="#trace-of-const-x--1--2">Trace of <code>const x = 1 + 2;</code></a></li>
        <li><a href="#trace-of-return-x--1">Trace of <code>return x + 1;</code></a></li>
      </ul>
    </li>
    <li><a href="#adding-blocks">Adding Blocks</a>
      <ul>
        <li><a href="#the-grammar-rule-2">The Grammar Rule</a></li>
        <li><a href="#trace-of--const-x--5-return-x-">Trace of <code>{ const x = 5; return x; }</code></a></li>
      </ul>
    </li>
    <li><a href="#adding-functions">Adding Functions</a>
      <ul>
        <li><a href="#the-grammar-rules">The Grammar Rules</a></li>
        <li><a href="#the--operator-1">The <code>?</code> Operator</a></li>
        <li><a href="#trace-of-fn-adda-i32-b-i32--return-a--b-">Trace of <code>fn add(a: i32, b: i32) { return a + b; }</code></a></li>
      </ul>
    </li>
    <li><a href="#the-complete-grammar">The Complete Grammar</a>
      <ul>
        <li><a href="#structure-diagram">Structure Diagram</a></li>
      </ul>
    </li>
    <li><a href="#grammar-notation-reference">Grammar Notation Reference</a>
      <ul>
        <li><a href="#examples-of-each">Examples of Each</a></li>
      </ul>
    </li>
    <li><a href="#from-grammar-to-code">From Grammar to Code</a>
      <ul>
        <li><a href="#the-template">The Template</a></li>
        <li><a href="#example-expression--term-----term">Example: expression → term ((&quot;+&quot; | &ldquo;-&rdquo;) term)*</a></li>
        <li><a href="#example-unary----unary--primary">Example: unary → &ldquo;-&rdquo; unary | primary</a></li>
        <li><a href="#example-block---statement-">Example: block → &ldquo;{&rdquo; statement* &ldquo;}&rdquo;</a></li>
        <li><a href="#example-function--fn-identifier--parameters--block">Example: function → &ldquo;fn&rdquo; IDENTIFIER &ldquo;(&rdquo; parameters? &ldquo;)&rdquo; block</a></li>
        <li><a href="#the-complete-mapping">The Complete Mapping</a></li>
      </ul>
    </li>
    <li><a href="#the-key-insight">The Key Insight</a></li>
    <li><a href="#extending-the-grammar">Extending the Grammar</a>
      <ul>
        <li><a href="#adding-if-statements">Adding If Statements</a></li>
        <li><a href="#adding-while-loops">Adding While Loops</a></li>
        <li><a href="#adding-more-operators">Adding More Operators</a></li>
        <li><a href="#adding-function-calls">Adding Function Calls</a></li>
      </ul>
    </li>
    <li><a href="#the-grammar-design-process">The Grammar Design Process</a></li>
    <li><a href="#common-patterns">Common Patterns</a>
      <ul>
        <li><a href="#binary-operators-left-associative">Binary Operators (Left-Associative)</a></li>
        <li><a href="#unary-operators-prefix">Unary Operators (Prefix)</a></li>
        <li><a href="#optional-parts">Optional Parts</a></li>
        <li><a href="#lists-with-separators">Lists with Separators</a></li>
        <li><a href="#blocks-of-things">Blocks of Things</a></li>
      </ul>
    </li>
    <li><a href="#complex-example-parsing-a-complete-program">Complex Example: Parsing a Complete Program</a>
      <ul>
        <li><a href="#the-token-stream">The Token Stream</a></li>
        <li><a href="#full-parse-trace">Full Parse Trace</a></li>
        <li><a href="#the-final-ast">The Final AST</a></li>
      </ul>
    </li>
    <li><a href="#right-associativity-assignment-and-exponentiation">Right-Associativity: Assignment and Exponentiation</a>
      <ul>
        <li><a href="#how-to-achieve-right-associativity">How to Achieve Right-Associativity</a></li>
        <li><a href="#why-does-recursion-give-right-associativity">Why Does Recursion Give Right-Associativity?</a></li>
        <li><a href="#exponentiation-example">Exponentiation Example</a></li>
      </ul>
    </li>
    <li><a href="#handling-errors-gracefully">Handling Errors Gracefully</a>
      <ul>
        <li><a href="#types-of-parse-errors">Types of Parse Errors</a></li>
        <li><a href="#the-expect-pattern">The <code>expect</code> Pattern</a></li>
        <li><a href="#error-recovery-synchronization">Error Recovery: Synchronization</a></li>
        <li><a href="#example-multiple-errors">Example: Multiple Errors</a></li>
      </ul>
    </li>
    <li><a href="#lookahead-when-one-token-isnt-enough">Lookahead: When One Token Isn&rsquo;t Enough</a>
      <ul>
        <li><a href="#the-problem">The Problem</a></li>
        <li><a href="#solution-peek-ahead">Solution: Peek Ahead</a></li>
        <li><a href="#when-lookahead-gets-complicated">When Lookahead Gets Complicated</a></li>
      </ul>
    </li>
    <li><a href="#putting-it-all-together-a-complete-parser">Putting It All Together: A Complete Parser</a></li>
    <li><a href="#common-mistakes-to-avoid">Common Mistakes to Avoid</a></li>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#whats-next">What&rsquo;s Next</a></li>
    <li><a href="#quick-reference">Quick Reference</a>
      <ul>
        <li><a href="#our-complete-grammar">Our Complete Grammar</a></li>
        <li><a href="#notation-reference">Notation Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</details>



            
          </div>
        </div>
      


      <div class="min-w-0 min-h-0 max-w-fit">
        

        <div class="article-content max-w-prose mb-20">
          
<h1 class="relative group">How to Design a Grammar for Your Programming Language
    <div id="how-to-design-a-grammar-for-your-programming-language" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-to-design-a-grammar-for-your-programming-language" aria-label="Anchor">#</a>
    </span>
    
</h1>
<p><em>From tokens to trees: the missing guide</em></p>
<hr>

<h2 class="relative group">Introduction
    <div id="introduction" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#introduction" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>You&rsquo;ve built a lexer. It takes source code and spits out tokens:</p>
<pre tabindex="0"><code>Source: 1 + 2 * 3
Tokens: [NUMBER(1), PLUS, NUMBER(2), STAR, NUMBER(3)]
</code></pre><p>Now what?</p>
<p>If you try to process these tokens one by one, you&rsquo;ll quickly run into problems. How do you know that <code>*</code> should happen before <code>+</code>? How do you handle parentheses? How do you parse <code>x = 1 + 2</code> where the <code>=</code> needs to wrap the whole right side?</p>
<p>The answer is a <strong>grammar</strong> - a set of rules that describe what valid programs look like. This article will teach you how to design one from scratch.</p>
<hr>

<h2 class="relative group">What is a Grammar?
    <div id="what-is-a-grammar" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#what-is-a-grammar" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>A grammar is a recipe for building valid programs. Just like a cooking recipe says &ldquo;add flour, then eggs, then mix&rdquo;, a grammar says &ldquo;a function is: the word &lsquo;fn&rsquo;, then a name, then parameters, then a body&rdquo;.</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                            WHAT IS A GRAMMAR?                                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   A grammar is a set of RULES that describe:                                │
│                                                                              │
│   1. What pieces your language has (expressions, statements, functions)     │
│   2. How those pieces can be combined                                       │
│   3. What order things must appear in                                       │
│                                                                              │
│   Example rule:                                                             │
│                                                                              │
│       function → &#34;fn&#34; NAME &#34;(&#34; params &#34;)&#34; block                             │
│                                                                              │
│   This says: a function is the word &#34;fn&#34;, followed by a name,               │
│   followed by params in parentheses, followed by a block.                   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">The Problem: Why Tokens Aren&rsquo;t Enough
    <div id="the-problem-why-tokens-arent-enough" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-problem-why-tokens-arent-enough" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">Flat Tokens Don&rsquo;t Show Structure
    <div id="flat-tokens-dont-show-structure" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#flat-tokens-dont-show-structure" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>When you look at tokens, they&rsquo;re just a flat list:</p>
<pre tabindex="0"><code>Source: const x = 1 + 2;

Tokens:
  [0] CONST
  [1] IDENTIFIER &#34;x&#34;
  [2] EQUAL
  [3] NUMBER 1
  [4] PLUS
  [5] NUMBER 2
  [6] SEMICOLON
</code></pre><p>But this list doesn&rsquo;t tell you:</p>
<ul>
<li>What belongs to what?</li>
<li>Does <code>=</code> apply to just <code>1</code> or to <code>1 + 2</code>?</li>
<li>Is <code>+</code> the &ldquo;main&rdquo; operation or is <code>=</code>?</li>
</ul>

<h3 class="relative group">The Solution: Build a Tree
    <div id="the-solution-build-a-tree" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-solution-build-a-tree" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>We need a <strong>tree</strong> that shows structure:</p>
<pre tabindex="0"><code>Token List (flat):               Tree (hierarchical):

[CONST][x][=][1][+][2][;]              VarDecl
                                      /   |   \
                                   &#34;x&#34;   =    Add
                                             /   \
                                            1     2
</code></pre><p>Now we can see:</p>
<ul>
<li><code>x</code> is the variable name</li>
<li>The value being assigned is <code>1 + 2</code> (the whole Add node)</li>
<li><code>1</code> and <code>2</code> are children of <code>Add</code></li>
</ul>

<h3 class="relative group">The Parser&rsquo;s Job
    <div id="the-parsers-job" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-parsers-job" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The parser reads tokens left-to-right and builds this tree. But it needs to know the rules - that&rsquo;s what the grammar provides.</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                           THE PARSER&#39;S JOB                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Input:   Flat list of tokens                                              │
│   Output:  Hierarchical tree (AST)                                          │
│   Guide:   Grammar rules                                                    │
│                                                                              │
│   Tokens ──────────► Parser ──────────► Tree                                │
│                         ▲                                                    │
│                         │                                                    │
│                      Grammar                                                 │
│                      (rules)                                                 │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Your First Grammar Rule
    <div id="your-first-grammar-rule" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#your-first-grammar-rule" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Let&rsquo;s start with the simplest possible expression: <code>1 + 2</code>.</p>

<h3 class="relative group">The Rule in English
    <div id="the-rule-in-english" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-rule-in-english" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>&ldquo;An expression is a number, then a plus sign, then a number.&rdquo;</p>

<h3 class="relative group">The Rule in Grammar Notation
    <div id="the-rule-in-grammar-notation" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-rule-in-grammar-notation" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>expression → NUMBER &#34;+&#34; NUMBER
</code></pre><p>Let&rsquo;s break this down:</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                        ANATOMY OF A GRAMMAR RULE                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   expression → NUMBER &#34;+&#34; NUMBER                                            │
│   ──────────   ────────────────────                                          │
│       │                │                                                     │
│       │                └─── Right side: what it&#39;s made of                   │
│       │                                                                      │
│       └─── Left side: the thing we&#39;re defining                              │
│                                                                              │
│                                                                              │
│   The arrow → means &#34;is defined as&#34; or &#34;is made of&#34;                         │
│                                                                              │
│   NUMBER (all caps) = a token from the lexer                                │
│   &#34;+&#34;               = the literal plus character                            │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">How Parsing Works with This Rule
    <div id="how-parsing-works-with-this-rule" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-parsing-works-with-this-rule" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Input: 1 + 2
Tokens: [NUMBER(1), PLUS, NUMBER(2)]

Parser (following rule: expression → NUMBER &#34;+&#34; NUMBER):

Step 1: See NUMBER(1)? Yes! ✓ Consume it.
        Remaining: [PLUS, NUMBER(2)]

Step 2: See &#34;+&#34;? Yes! ✓ Consume it.
        Remaining: [NUMBER(2)]

Step 3: See NUMBER(2)? Yes! ✓ Consume it.
        Remaining: []

Step 4: Build the tree:
                Add
               /   \
              1     2

Done!
</code></pre>
<h3 class="relative group">Visual Trace
    <div id="visual-trace" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visual-trace" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    PARSING &#34;1 + 2&#34; STEP BY STEP                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens:  [NUMBER(1)] [PLUS] [NUMBER(2)]                                   │
│                 ▲                                                            │
│                 │                                                            │
│            ─────┴───── cursor starts here                                   │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│   Rule: expression → NUMBER &#34;+&#34; NUMBER                                      │
│                       ^^^^^                                                  │
│                       expect NUMBER                                          │
│                                                                              │
│   Current token: NUMBER(1) ✓ matches!                                       │
│   Action: consume, save value 1                                             │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens:  [NUMBER(1)] [PLUS] [NUMBER(2)]                                   │
│                           ▲                                                  │
│                           │                                                  │
│                ───────────┴───── cursor moved                               │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│   Rule: expression → NUMBER &#34;+&#34; NUMBER                                      │
│                              ^^^                                             │
│                              expect &#34;+&#34;                                      │
│                                                                              │
│   Current token: PLUS ✓ matches!                                            │
│   Action: consume                                                           │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens:  [NUMBER(1)] [PLUS] [NUMBER(2)]                                   │
│                                    ▲                                         │
│                                    │                                         │
│                       ─────────────┴───── cursor moved                      │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│   Rule: expression → NUMBER &#34;+&#34; NUMBER                                      │
│                                  ^^^^^^                                      │
│                                  expect NUMBER                               │
│                                                                              │
│   Current token: NUMBER(2) ✓ matches!                                       │
│   Action: consume, save value 2                                             │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│   All parts matched! Build node:                                            │
│                                                                              │
│               Add                                                            │
│              /   \                                                           │
│             1     2                                                          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Problem: What About <code>1 + 2 + 3</code>?
    <div id="problem-what-about-1--2--3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#problem-what-about-1--2--3" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Our current rule only handles exactly TWO numbers:</p>
<pre tabindex="0"><code>expression → NUMBER &#34;+&#34; NUMBER
</code></pre><p>It can parse:</p>
<ul>
<li>✓ <code>1 + 2</code></li>
<li>✗ <code>1 + 2 + 3</code>    (three numbers!)</li>
<li>✗ <code>1 + 2 + 3 + 4</code> (four numbers!)</li>
<li>✗ <code>42</code>           (one number!)</li>
</ul>
<p>We need a way to say &ldquo;one or more&rdquo; or &ldquo;zero or more&rdquo;.</p>
<hr>

<h2 class="relative group">Adding Repetition
    <div id="adding-repetition" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#adding-repetition" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">The <code>*</code> Operator
    <div id="the--operator" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the--operator" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>In grammar notation, <code>*</code> means &ldquo;zero or more&rdquo;:</p>
<pre tabindex="0"><code>expression → NUMBER (&#34;+&#34; NUMBER)*
</code></pre><p>This reads as: &ldquo;A number, followed by zero or more occurrences of (plus, number).&rdquo;</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                         THE * OPERATOR                                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   expression → NUMBER (&#34;+&#34; NUMBER)*                                         │
│                       ─────────────                                          │
│                             │                                                │
│                             └─── This whole group can repeat 0+ times       │
│                                                                              │
│   Matches:                                                                   │
│                                                                              │
│     &#34;42&#34;           NUMBER, then 0 repeats           ✓                       │
│     &#34;1 + 2&#34;        NUMBER, then 1 repeat            ✓                       │
│     &#34;1 + 2 + 3&#34;    NUMBER, then 2 repeats           ✓                       │
│     &#34;1 + 2 + 3 + 4&#34; NUMBER, then 3 repeats          ✓                       │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">How It Parses
    <div id="how-it-parses" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-it-parses" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>expression → NUMBER (&#34;+&#34; NUMBER)*

Parsing &#34;1 + 2 + 3&#34;:

Step 1: Parse NUMBER → 1
        left = 1

Step 2: See &#34;+&#34;? Yes! Enter the (*) loop.
        Parse NUMBER → 2
        left = Add(1, 2)

Step 3: See &#34;+&#34;? Yes! Still in loop.
        Parse NUMBER → 3
        left = Add(Add(1, 2), 3)

Step 4: See &#34;+&#34;? No. Exit loop.
        Return left

Result:
        Add
       /   \
     Add    3
    /   \
   1     2
</code></pre>
<h3 class="relative group">The Pattern: Use a Loop
    <div id="the-pattern-use-a-loop" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-pattern-use-a-loop" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>In code, the <code>*</code> becomes a while loop:</p>
<pre tabindex="0"><code>fn parseExpression():
    left = parseNumber()           // First NUMBER

    while see(PLUS):               // (&#34;+&#34; NUMBER)*
        consume(PLUS)
        right = parseNumber()
        left = AddNode(left, right)

    return left
</code></pre>
<h3 class="relative group">Step-by-Step Trace of <code>1 + 2 + 3</code>
    <div id="step-by-step-trace-of-1--2--3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#step-by-step-trace-of-1--2--3" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    PARSING &#34;1 + 2 + 3&#34; WITH REPETITION                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens: [1] [+] [2] [+] [3]                                               │
│            ▲                                                                 │
│                                                                              │
│   Step 1: Parse first NUMBER                                                │
│           left = 1                                                          │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens: [1] [+] [2] [+] [3]                                               │
│               ▲                                                              │
│                                                                              │
│   Step 2: See &#34;+&#34;? YES → enter loop                                         │
│           consume &#34;+&#34;                                                        │
│           parse NUMBER → 2                                                  │
│           left = Add(1, 2)                                                  │
│                                                                              │
│           Current tree:                                                      │
│                  Add                                                         │
│                 /   \                                                        │
│                1     2                                                       │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens: [1] [+] [2] [+] [3]                                               │
│                       ▲                                                      │
│                                                                              │
│   Step 3: See &#34;+&#34;? YES → continue loop                                      │
│           consume &#34;+&#34;                                                        │
│           parse NUMBER → 3                                                  │
│           left = Add(Add(1, 2), 3)                                          │
│                                                                              │
│           Current tree:                                                      │
│                  Add                                                         │
│                 /   \                                                        │
│               Add    3                                                       │
│              /   \                                                           │
│             1     2                                                          │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens: [1] [+] [2] [+] [3]                                               │
│                            ▲                                                 │
│                             (end of tokens)                                  │
│                                                                              │
│   Step 4: See &#34;+&#34;? NO → exit loop                                           │
│           return left                                                        │
│                                                                              │
│           Final tree:                                                        │
│                  Add                                                         │
│                 /   \                                                        │
│               Add    3                                                       │
│              /   \                                                           │
│             1     2                                                          │
│                                                                              │
│           This represents: (1 + 2) + 3                                      │
│           Left-associative! ✓                                               │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Why Left-Associative?
    <div id="why-left-associative" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-left-associative" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Notice the tree shape: <code>(1 + 2) + 3</code>, not <code>1 + (2 + 3)</code>.</p>
<p>This is called <strong>left-associative</strong> - we group from the left. This is what we want for subtraction:</p>
<pre tabindex="0"><code>8 - 5 - 2

Left-associative:  (8 - 5) - 2 = 3 - 2 = 1  ✓ Correct!
Right-associative: 8 - (5 - 2) = 8 - 3 = 5  ✗ Wrong!
</code></pre><p>The loop pattern naturally produces left-associativity because we keep updating <code>left</code>.</p>
<hr>

<h2 class="relative group">The Precedence Problem
    <div id="the-precedence-problem" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-precedence-problem" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Let&rsquo;s add multiplication to our grammar:</p>
<pre tabindex="0"><code>expression → NUMBER ((&#34;+&#34; | &#34;*&#34;) NUMBER)*
</code></pre><p>The <code>|</code> means &ldquo;or&rdquo;. So now we can have <code>+</code> or <code>*</code> between numbers.</p>

<h3 class="relative group">What Goes Wrong?
    <div id="what-goes-wrong" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#what-goes-wrong" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Input: 1 + 2 * 3

Our grammar parses left-to-right:
1. left = 1
2. See &#34;+&#34;, parse 2 → left = Add(1, 2)
3. See &#34;*&#34;, parse 3 → left = Mul(Add(1, 2), 3)

Result tree:
        Mul
       /   \
     Add    3
    /   \
   1     2

This means: (1 + 2) * 3 = 9
But math says: 1 + (2 * 3) = 7  ← Different answer!
</code></pre>
<h3 class="relative group">Visualizing the Problem
    <div id="visualizing-the-problem" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visualizing-the-problem" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                         THE PRECEDENCE PROBLEM                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Input: 1 + 2 * 3                                                          │
│                                                                              │
│   WRONG (our current grammar):         CORRECT (what math expects):         │
│                                                                              │
│           Mul                                   Add                          │
│          /   \                                 /   \                         │
│        Add    3                               1    Mul                       │
│       /   \                                       /   \                      │
│      1     2                                     2     3                     │
│                                                                              │
│   Evaluation:                           Evaluation:                          │
│   (1 + 2) * 3                           1 + (2 * 3)                          │
│   = 3 * 3                               = 1 + 6                              │
│   = 9                                   = 7                                  │
│                                                                              │
│                                                                              │
│   The problem: * should bind TIGHTER than +                                 │
│   But our grammar treats them the same!                                     │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">The Key Insight: Nesting = Precedence
    <div id="the-key-insight-nesting--precedence" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-key-insight-nesting--precedence" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Here&rsquo;s the crucial insight:</p>
<p><strong>In a tree, deeper nodes are evaluated first.</strong></p>
<pre tabindex="0"><code>        Add              ← evaluated LAST (outer)
       /   \
      1    Mul           ← evaluated FIRST (inner)
          /   \
         2     3

Evaluation order:
1. First: 2 * 3 = 6 (inner node)
2. Then:  1 + 6 = 7 (outer node)
</code></pre><p>So to make <code>*</code> happen before <code>+</code>, we need <code>*</code> nodes to be <strong>nested inside</strong> <code>+</code> nodes.</p>
<hr>

<h2 class="relative group">Solving Precedence with Nesting
    <div id="solving-precedence-with-nesting" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#solving-precedence-with-nesting" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>The solution: <strong>split into multiple rules</strong>, one for each precedence level.</p>

<h3 class="relative group">The Two-Level Grammar
    <div id="the-two-level-grammar" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-two-level-grammar" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>expression → term ((&#34;+&#34; | &#34;-&#34;) term)*
term       → NUMBER ((&#34;*&#34; | &#34;/&#34;) NUMBER)*
</code></pre><p>Wait, what? Let&rsquo;s break this down carefully.</p>

<h3 class="relative group">How to Read These Rules
    <div id="how-to-read-these-rules" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-to-read-these-rules" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>expression → term ((&#34;+&#34; | &#34;-&#34;) term)*
</code></pre><p>This says:</p>
<ul>
<li>First, get a <code>term</code> (whatever that is - we&rsquo;ll define it below)</li>
<li>Then, zero or more times: get a <code>+</code> or <code>-</code>, then another <code>term</code></li>
</ul>
<pre tabindex="0"><code>term → NUMBER ((&#34;*&#34; | &#34;/&#34;) NUMBER)*
</code></pre><p>This says:</p>
<ul>
<li>First, get a <code>NUMBER</code></li>
<li>Then, zero or more times: get a <code>*</code> or <code>/</code>, then another <code>NUMBER</code></li>
</ul>
<p><strong>Key insight: <code>expression</code> doesn&rsquo;t see numbers directly. It sees <code>term</code>s.</strong></p>

<h3 class="relative group">Think of It Like Boxes
    <div id="think-of-it-like-boxes" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#think-of-it-like-boxes" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>expression deals with BOXES connected by + or -:

┌─────┐     ┌─────┐     ┌─────┐
│term │  +  │term │  +  │term │  ...
└─────┘     └─────┘     └─────┘

Each box (term) can contain multiplication INSIDE:

┌─────────────────┐
│ 2 * 3 * 4       │  ← this whole thing is ONE term
└─────────────────┘

So &#34;1 + 2 * 3 + 4&#34; becomes:

┌─────┐     ┌─────────┐     ┌─────┐
│  1  │  +  │  2 * 3  │  +  │  4  │
└─────┘     └─────────┘     └─────┘
   │             │             │
  term         term          term

expression only sees 3 terms connected by +
The * is HIDDEN inside the middle term!
</code></pre>
<h3 class="relative group">Why This Gives Correct Precedence
    <div id="why-this-gives-correct-precedence" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-this-gives-correct-precedence" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Think of it like school math order of operations:</p>
<ol>
<li><strong>First</strong> do multiplication/division (that&rsquo;s what <code>term</code> does)</li>
<li><strong>Then</strong> do addition/subtraction (that&rsquo;s what <code>expression</code> does)</li>
</ol>
<p>The grammar enforces this by making <code>expression</code> call <code>term</code> first. By the time <code>expression</code> gets to do its work, all the <code>*</code> and <code>/</code> are already done.</p>

<h3 class="relative group">Simple Summary
    <div id="simple-summary" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#simple-summary" aria-label="Anchor">#</a>
    </span>
    
</h3>
<ul>
<li>An <strong>expression</strong> is terms combined with <code>+</code> or <code>-</code></li>
<li>A <strong>term</strong> is numbers combined with <code>*</code> or <code>/</code></li>
</ul>

<h3 class="relative group">Why This Works: Step by Step
    <div id="why-this-works-step-by-step" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-this-works-step-by-step" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Let&rsquo;s trace <code>1 + 2 * 3</code> in detail:</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    THE MAGIC OF TWO-LEVEL GRAMMAR                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   expression() starts:                                                       │
│       &#34;I need a term first&#34;                                                 │
│       │                                                                      │
│       ▼                                                                      │
│   term():                                                                    │
│       get NUMBER → 1                                                        │
│       see &#34;*&#34; or &#34;/&#34;? NO (I see &#34;+&#34;)                                        │
│       return 1                                                              │
│       │                                                                      │
│       ▼                                                                      │
│   expression() continues:                                                    │
│       left = 1                                                              │
│       see &#34;+&#34; or &#34;-&#34;? YES, see &#34;+&#34;                                          │
│       consume &#34;+&#34;                                                           │
│       &#34;I need another term&#34;                                                 │
│       │                                                                      │
│       ▼                                                                      │
│   term():                     ◄─── HERE&#39;S THE MAGIC                         │
│       get NUMBER → 2                                                        │
│       see &#34;*&#34; or &#34;/&#34;? YES! see &#34;*&#34;     ◄─── term handles the *             │
│       consume &#34;*&#34;                                                           │
│       get NUMBER → 3                                                        │
│       left = 2 * 3 = Mul(2, 3)                                             │
│       see &#34;*&#34; or &#34;/&#34;? NO                                                    │
│       return Mul(2, 3)        ◄─── returns the WHOLE multiplication        │
│       │                                                                      │
│       ▼                                                                      │
│   expression() continues:                                                    │
│       right = Mul(2, 3)       ◄─── expression gets (2*3) as one unit       │
│       left = Add(1, Mul(2, 3))                                             │
│       see &#34;+&#34; or &#34;-&#34;? NO                                                    │
│       return Add(1, Mul(2, 3))                                             │
│                                                                              │
│   Result: 1 + (2 * 3) = 7  ✓                                                │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><p><strong>The key moment</strong>: when <code>expression</code> asks for its second <code>term</code>, the <code>term</code> function sees the <code>*</code> and handles it internally. By the time <code>term</code> returns, the multiplication is already done!</p>

<h3 class="relative group">Compare: One Rule vs Two Rules
    <div id="compare-one-rule-vs-two-rules" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#compare-one-rule-vs-two-rules" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>ONE RULE (wrong):                TWO RULES (correct):
─────────────────               ──────────────────────

expression →                    expression →
  NUMBER ((+|*) NUMBER)*          term ((+|-) term)*

                                term →
                                  NUMBER ((*|/) NUMBER)*


Parsing &#34;1 + 2 * 3&#34;:            Parsing &#34;1 + 2 * 3&#34;:
─────────────────               ──────────────────────

1. left = 1                     1. expression calls term
2. see +                           term returns 1
3. left = 1 + 2                 2. expression sees +
4. see *                        3. expression calls term
5. left = (1+2) * 3                term gets 2
                                   term sees * ← HANDLES IT!
   = 9  WRONG!                     term gets 3
                                   term returns (2*3)
                                4. expression builds 1 + (2*3)

                                   = 7  CORRECT!
</code></pre>
<h3 class="relative group">The Golden Rule
    <div id="the-golden-rule" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-golden-rule" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p><strong>The function that gets called FIRST handles the operators that should happen FIRST (higher precedence).</strong></p>
<pre tabindex="0"><code>expression calls term
term handles * and /
Therefore * and / happen before + and -
</code></pre><pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                     HOW NESTING CREATES PRECEDENCE                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Grammar:                                                                   │
│     expression → term ((&#34;+&#34; | &#34;-&#34;) term)*    ← LOW precedence (outer)       │
│     term       → NUMBER ((&#34;*&#34; | &#34;/&#34;) NUMBER)*  ← HIGH precedence (inner)    │
│                                                                              │
│   Rule of thumb:                                                             │
│     - Rules that call OTHER rules have LOWER precedence                     │
│     - Rules that are CALLED have HIGHER precedence                          │
│     - Called first = evaluated first = higher precedence                    │
│                                                                              │
│   Call chain:                                                                │
│     expression calls term                                                    │
│     term calls (numbers directly)                                           │
│                                                                              │
│   So: term is &#34;inside&#34; expression                                           │
│   So: * is &#34;inside&#34; +                                                       │
│   So: * happens first!                                                      │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Detailed Trace of <code>1 + 2 * 3</code>
    <div id="detailed-trace-of-1--2--3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#detailed-trace-of-1--2--3" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Let&rsquo;s trace through exactly how this works:</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    PARSING &#34;1 + 2 * 3&#34; WITH PRECEDENCE                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Grammar:                                                                   │
│     expression → term ((&#34;+&#34; | &#34;-&#34;) term)*                                   │
│     term       → NUMBER ((&#34;*&#34; | &#34;/&#34;) NUMBER)*                               │
│                                                                              │
│   Tokens: [1] [+] [2] [*] [3]                                               │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│   expression() called:                                                       │
│                                                                              │
│   Step 1: Call term() for left side                                         │
│           │                                                                  │
│           ▼                                                                  │
│       term():                                                                │
│           Parse NUMBER → 1                                                  │
│           See &#34;*&#34; or &#34;/&#34;? No (see &#34;+&#34;)                                      │
│           Return 1                                                          │
│           │                                                                  │
│           ▼                                                                  │
│       left = 1                                                              │
│                                                                              │
│   Tokens: [1] [+] [2] [*] [3]                                               │
│               ▲                                                              │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│   expression() continues:                                                    │
│                                                                              │
│   Step 2: See &#34;+&#34; or &#34;-&#34;? Yes, see &#34;+&#34;                                      │
│           Consume &#34;+&#34;                                                        │
│           Call term() for right side                                        │
│           │                                                                  │
│           ▼                                                                  │
│       term():                                                                │
│           Parse NUMBER → 2                                                  │
│           See &#34;*&#34; or &#34;/&#34;? YES! See &#34;*&#34;                                      │
│           Consume &#34;*&#34;                                                        │
│           Parse NUMBER → 3                                                  │
│           left = Mul(2, 3)                                                  │
│           See &#34;*&#34; or &#34;/&#34;? No                                                │
│           Return Mul(2, 3)          ← MULTIPLICATION HANDLED INSIDE TERM!  │
│           │                                                                  │
│           ▼                                                                  │
│       right = Mul(2, 3)                                                     │
│       left = Add(1, Mul(2, 3))                                              │
│                                                                              │
│   Tokens: [1] [+] [2] [*] [3]                                               │
│                            ▲                                                 │
│                             (end)                                            │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│   expression() continues:                                                    │
│                                                                              │
│   Step 3: See &#34;+&#34; or &#34;-&#34;? No (end of tokens)                                │
│           Return left                                                        │
│                                                                              │
│   Final tree:                                                                │
│              Add                                                             │
│             /   \                                                            │
│            1    Mul                                                          │
│                /   \                                                         │
│               2     3                                                        │
│                                                                              │
│   Evaluation: 1 + (2 * 3) = 1 + 6 = 7  ✓ Correct!                           │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">The Call Stack IS the Tree
    <div id="the-call-stack-is-the-tree" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-call-stack-is-the-tree" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Here&rsquo;s the beautiful insight: <strong>the parser&rsquo;s call stack mirrors the tree structure</strong>.</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                     CALL STACK = TREE STRUCTURE                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   When parsing &#34;1 + 2 * 3&#34;:                                                 │
│                                                                              │
│   Call Stack (grows down):          Tree (grows down):                      │
│   ────────────────────────          ────────────────────                    │
│                                                                              │
│   expression()                      Add (root)                              │
│       │                            /   \                                     │
│       ├── term() → 1              1     Mul                                 │
│       │                                /   \                                 │
│       └── term() ──────────────────►  2     3                               │
│               │                                                              │
│               ├── sees 2                                                     │
│               ├── sees *                                                     │
│               └── sees 3                                                     │
│                   builds Mul(2,3)                                           │
│                                                                              │
│   The nesting in the call stack                                             │
│   becomes nesting in the tree!                                              │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Adding Unary Operators
    <div id="adding-unary-operators" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#adding-unary-operators" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>What about <code>-5</code> or <code>-x</code>? These are <strong>unary operators</strong> - they take one operand.</p>

<h3 class="relative group">The Grammar Rule
    <div id="the-grammar-rule" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-grammar-rule" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>expression → term ((&#34;+&#34; | &#34;-&#34;) term)*
term       → unary ((&#34;*&#34; | &#34;/&#34;) unary)*
unary      → &#34;-&#34; unary | NUMBER
</code></pre><p>The new <code>unary</code> rule says:</p>
<ul>
<li>A unary is either: minus followed by another unary, OR just a number</li>
<li>The recursive <code>&quot;-&quot; unary</code> allows <code>--5</code> (double negative)</li>
</ul>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                         UNARY OPERATOR RULE                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   unary → &#34;-&#34; unary | NUMBER                                                │
│                                                                              │
│   The &#34;|&#34; means OR. So a unary is either:                                   │
│     1. A minus sign followed by another unary, OR                           │
│     2. Just a number                                                        │
│                                                                              │
│   Examples:                                                                  │
│                                                                              │
│     &#34;5&#34;   →  NUMBER                                                         │
│                 └─ unary (the number case)                                  │
│                                                                              │
│     &#34;-5&#34;  →  &#34;-&#34; unary                                                      │
│                   └─ NUMBER                                                 │
│                        └─ unary (the number case)                           │
│                                                                              │
│     &#34;--5&#34; →  &#34;-&#34; unary                                                      │
│                   └─ &#34;-&#34; unary                                              │
│                          └─ NUMBER                                          │
│                               └─ unary (the number case)                    │
│                                                                              │
│   The recursion allows any number of minus signs!                           │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Why Unary is Between Term and Number
    <div id="why-unary-is-between-term-and-number" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-unary-is-between-term-and-number" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Precedence order (highest to lowest):</p>
<ol>
<li>Unary minus: <code>-x</code> (happens first)</li>
<li>Multiplication/Division: <code>*</code> <code>/</code></li>
<li>Addition/Subtraction: <code>+</code> <code>-</code></li>
</ol>
<p>So the call chain is:</p>
<pre tabindex="0"><code>expression → term → unary → number

-2 * 3  parses as  (-2) * 3   ✓
</code></pre><p>If unary were at expression level:</p>
<pre tabindex="0"><code>-2 * 3  would parse as  -(2 * 3)  ✗ Wrong!
</code></pre>
<h3 class="relative group">Trace of <code>-1 + 2</code>
    <div id="trace-of--1--2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#trace-of--1--2" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                        PARSING &#34;-1 + 2&#34;                                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Grammar:                                                                   │
│     expression → term ((&#34;+&#34; | &#34;-&#34;) term)*                                   │
│     term       → unary ((&#34;*&#34; | &#34;/&#34;) unary)*                                 │
│     unary      → &#34;-&#34; unary | NUMBER                                         │
│                                                                              │
│   Tokens: [MINUS] [1] [PLUS] [2]                                            │
│                                                                              │
│   expression():                                                              │
│       call term():                                                           │
│           call unary():                                                      │
│               see MINUS → consume it                                        │
│               call unary() recursively:                                      │
│                   see NUMBER(1) → return 1                                  │
│               return Negate(1)                                              │
│           see &#34;*&#34; or &#34;/&#34;? No                                                │
│           return Negate(1)                                                  │
│       left = Negate(1)                                                      │
│                                                                              │
│       see &#34;+&#34;? Yes → consume it                                             │
│       call term():                                                           │
│           call unary():                                                      │
│               see NUMBER(2) → return 2                                      │
│           return 2                                                          │
│       right = 2                                                             │
│       left = Add(Negate(1), 2)                                              │
│                                                                              │
│       see &#34;+&#34;? No                                                           │
│       return Add(Negate(1), 2)                                              │
│                                                                              │
│   Tree:                                                                      │
│              Add                                                             │
│             /   \                                                            │
│         Negate   2                                                           │
│            |                                                                 │
│            1                                                                 │
│                                                                              │
│   Evaluation: (-1) + 2 = 1  ✓                                               │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Adding Parentheses
    <div id="adding-parentheses" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#adding-parentheses" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Parentheses let users override precedence: <code>(1 + 2) * 3</code>.</p>

<h3 class="relative group">The Grammar Rule
    <div id="the-grammar-rule-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-grammar-rule-1" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>expression → term ((&#34;+&#34; | &#34;-&#34;) term)*
term       → unary ((&#34;*&#34; | &#34;/&#34;) unary)*
unary      → &#34;-&#34; unary | primary
primary    → NUMBER | &#34;(&#34; expression &#34;)&#34;
</code></pre><p>We renamed &ldquo;NUMBER&rdquo; to &ldquo;primary&rdquo; and added the parenthesis option.</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                         PARENTHESES RULE                                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   primary → NUMBER | &#34;(&#34; expression &#34;)&#34;                                     │
│                                                                              │
│   A primary is either:                                                       │
│     1. Just a number, OR                                                    │
│     2. An open paren, an EXPRESSION, and a close paren                      │
│                                                                              │
│   The magic: inside the parens, we RESTART at &#34;expression&#34;!                 │
│   This is RECURSION.                                                         │
│                                                                              │
│   Call chain for &#34;(1 + 2)&#34;:                                                 │
│                                                                              │
│     primary() sees &#34;(&#34;                                                       │
│         │                                                                    │
│         └──► calls expression()  ← RECURSION!                               │
│                  │                                                           │
│                  └──► parses &#34;1 + 2&#34;                                        │
│                       returns Add(1, 2)                                     │
│         │                                                                    │
│         └──► expects &#34;)&#34;                                                    │
│              returns Add(1, 2)                                              │
│                                                                              │
│   The parentheses DISAPPEAR from the AST.                                   │
│   Their job was to guide the parser - now structure is in the tree.        │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Trace of <code>(1 + 2) * 3</code>
    <div id="trace-of-1--2--3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#trace-of-1--2--3" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                      PARSING &#34;(1 + 2) * 3&#34;                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens: [LPAREN] [1] [PLUS] [2] [RPAREN] [STAR] [3]                       │
│                                                                              │
│   expression():                                                              │
│       call term():                                                           │
│           call unary():                                                      │
│               call primary():                                                │
│                   see &#34;(&#34; → consume it                                      │
│   ┌───────────────────────────────────────────────────────────────┐         │
│   │   call expression() RECURSIVELY:                               │         │
│   │       call term():                                             │         │
│   │           call unary():                                        │         │
│   │               call primary():                                  │         │
│   │                   see NUMBER(1) → return 1                    │         │
│   │               return 1                                        │         │
│   │           return 1                                            │         │
│   │       left = 1                                                │         │
│   │       see &#34;+&#34;? Yes → consume                                  │         │
│   │       call term():                                             │         │
│   │           call unary():                                        │         │
│   │               call primary():                                  │         │
│   │                   see NUMBER(2) → return 2                    │         │
│   │       right = 2                                               │         │
│   │       left = Add(1, 2)                                        │         │
│   │       see &#34;+&#34;? No (see &#34;)&#34;)                                   │         │
│   │       return Add(1, 2)                                        │         │
│   └───────────────────────────────────────────────────────────────┘         │
│                   expect &#34;)&#34; → consume it                                   │
│                   return Add(1, 2)                                          │
│               return Add(1, 2)                                              │
│           return Add(1, 2)                                                  │
│       left = Add(1, 2)                                                      │
│                                                                              │
│       see &#34;*&#34;? Yes → consume                                                │
│       call unary():                                                          │
│           call primary():                                                    │
│               see NUMBER(3) → return 3                                      │
│       right = 3                                                             │
│       left = Mul(Add(1, 2), 3)                                              │
│                                                                              │
│       see &#34;*&#34;? No                                                           │
│       return Mul(Add(1, 2), 3)                                              │
│                                                                              │
│   see &#34;+&#34;? No                                                               │
│   return Mul(Add(1, 2), 3)                                                  │
│                                                                              │
│   Tree:                                                                      │
│              Mul                                                             │
│             /   \                                                            │
│           Add    3                                                           │
│          /   \                                                               │
│         1     2                                                              │
│                                                                              │
│   Evaluation: (1 + 2) * 3 = 3 * 3 = 9  ✓                                    │
│                                                                              │
│   Notice: The parentheses are GONE from the tree.                           │
│   Their effect is captured in the STRUCTURE of the tree.                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">The Complete Expression Grammar
    <div id="the-complete-expression-grammar" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-complete-expression-grammar" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Here&rsquo;s our full expression grammar with 4 rules:</p>
<pre tabindex="0"><code>expression → term ((&#34;+&#34; | &#34;-&#34;) term)*
term       → unary ((&#34;*&#34; | &#34;/&#34;) unary)*
unary      → &#34;-&#34; unary | primary
primary    → NUMBER | IDENTIFIER | &#34;(&#34; expression &#34;)&#34;
</code></pre><p>(We added IDENTIFIER so variables like <code>x</code> work too.)</p>

<h3 class="relative group">Visual Summary
    <div id="visual-summary" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#visual-summary" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    THE COMPLETE EXPRESSION GRAMMAR                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   expression → term ((&#34;+&#34; | &#34;-&#34;) term)*       Precedence: LOWEST (3)        │
│       │                                                                      │
│       │ calls                                                                │
│       ▼                                                                      │
│   term → unary ((&#34;*&#34; | &#34;/&#34;) unary)*           Precedence: MEDIUM (2)        │
│       │                                                                      │
│       │ calls                                                                │
│       ▼                                                                      │
│   unary → &#34;-&#34; unary | primary                 Precedence: HIGH (1)          │
│       │                                                                      │
│       │ calls                                                                │
│       ▼                                                                      │
│   primary → NUMBER | IDENTIFIER | &#34;(&#34; expression &#34;)&#34;   Precedence: HIGHEST │
│                                        │                                     │
│                                        │ calls (recursion!)                  │
│                                        └────────────────────────────────────┐
│                                                                              │
│                                                                              │
│   What can it parse?                                                         │
│   ──────────────────                                                         │
│     42                              ✓ number                                │
│     x                               ✓ identifier                            │
│     1 + 2                           ✓ addition                              │
│     1 + 2 * 3                       ✓ precedence: 1 + (2 * 3)              │
│     -5                              ✓ unary minus                           │
│     --x                             ✓ double negation                       │
│     (1 + 2) * 3                     ✓ parentheses override                  │
│     -x * (y + z)                    ✓ complex expression                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">How Each Rule Maps to Precedence
    <div id="how-each-rule-maps-to-precedence" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-each-rule-maps-to-precedence" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌────────────────────────────────────────────────────────────────────────────┐
│                    PRECEDENCE LEVELS                                       │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│   Level   Rule          Operators    Evaluated                             │
│   ─────   ────          ─────────    ─────────                             │
│   3       expression    + -          LAST (outermost in tree)             │
│   2       term          * /          MIDDLE                                │
│   1       unary         - (prefix)   FIRST                                 │
│   0       primary       literals     FIRST (innermost in tree)            │
│                                                                            │
│   Lower level number = called first = evaluated first = higher precedence │
│                                                                            │
│   Example: -2 * 3 + 4                                                      │
│                                                                            │
│   Tree:           Add              (level 3, evaluated last)               │
│                  /   \                                                      │
│                Mul    4            (level 2)                               │
│               /   \                                                        │
│           Negate   3               (level 1, evaluated first)              │
│              |                                                             │
│              2                     (level 0)                               │
│                                                                            │
│   Evaluation order: 2 → -2 → (-2)*3=-6 → -6+4=-2                          │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">From Expressions to Statements
    <div id="from-expressions-to-statements" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#from-expressions-to-statements" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Expressions produce values. But programs also need <strong>statements</strong> - things that DO something.</p>

<h3 class="relative group">What&rsquo;s a Statement?
    <div id="whats-a-statement" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#whats-a-statement" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    EXPRESSIONS VS STATEMENTS                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   EXPRESSIONS produce a value:                                              │
│     42              → produces 42                                           │
│     x + y           → produces the sum                                      │
│     foo()           → produces return value                                 │
│                                                                              │
│   STATEMENTS perform an action:                                             │
│     const x = 5;    → creates a variable (no value produced)               │
│     return 42;      → exits the function (no value produced)               │
│     { ... }         → groups statements (no value produced)                │
│                                                                              │
│   Key difference: statements usually end with semicolons.                   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Statement Grammar Rules
    <div id="statement-grammar-rules" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#statement-grammar-rules" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>statement   → var_decl | return_stmt
var_decl    → &#34;const&#34; IDENTIFIER &#34;=&#34; expression &#34;;&#34;
return_stmt → &#34;return&#34; expression &#34;;&#34;
</code></pre>
<h3 class="relative group">Trace of <code>const x = 1 + 2;</code>
    <div id="trace-of-const-x--1--2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#trace-of-const-x--1--2" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    PARSING &#34;const x = 1 + 2;&#34;                                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens: [CONST] [x] [=] [1] [+] [2] [;]                                   │
│                                                                              │
│   statement():                                                               │
│       see &#34;const&#34;? Yes!                                                      │
│       call var_decl():                                                       │
│           expect &#34;const&#34; → consume                                          │
│           expect IDENTIFIER → consume, name = &#34;x&#34;                           │
│           expect &#34;=&#34; → consume                                              │
│           call expression():                                                 │
│               ... parses &#34;1 + 2&#34; ...                                        │
│               returns Add(1, 2)                                             │
│           value = Add(1, 2)                                                 │
│           expect &#34;;&#34; → consume                                              │
│           return VarDecl { name: &#34;x&#34;, value: Add(1, 2) }                   │
│                                                                              │
│   Tree:                                                                      │
│           VarDecl                                                            │
│          /       \                                                           │
│        &#34;x&#34;       Add                                                         │
│                 /   \                                                        │
│                1     2                                                       │
│                                                                              │
│   The key: var_decl CALLS expression for the value!                        │
│   This is how the grammar COMPOSES.                                         │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Trace of <code>return x + 1;</code>
    <div id="trace-of-return-x--1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#trace-of-return-x--1" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    PARSING &#34;return x + 1;&#34;                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens: [RETURN] [x] [+] [1] [;]                                          │
│                                                                              │
│   statement():                                                               │
│       see &#34;const&#34;? No                                                        │
│       see &#34;return&#34;? Yes!                                                     │
│       call return_stmt():                                                    │
│           expect &#34;return&#34; → consume                                         │
│           call expression():                                                 │
│               call term():                                                   │
│                   call unary():                                              │
│                       call primary():                                        │
│                           see IDENTIFIER &#34;x&#34; → return Ident(&#34;x&#34;)           │
│               left = Ident(&#34;x&#34;)                                             │
│               see &#34;+&#34;? Yes → consume                                        │
│               call term():                                                   │
│                   returns 1                                                 │
│               left = Add(Ident(&#34;x&#34;), 1)                                     │
│               return Add(Ident(&#34;x&#34;), 1)                                     │
│           value = Add(Ident(&#34;x&#34;), 1)                                        │
│           expect &#34;;&#34; → consume                                              │
│           return ReturnStmt { value: Add(Ident(&#34;x&#34;), 1) }                  │
│                                                                              │
│   Tree:                                                                      │
│           ReturnStmt                                                         │
│               |                                                              │
│              Add                                                             │
│             /   \                                                            │
│         Ident   1                                                           │
│           |                                                                  │
│          &#34;x&#34;                                                                 │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Adding Blocks
    <div id="adding-blocks" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#adding-blocks" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>A <strong>block</strong> is a sequence of statements wrapped in braces.</p>

<h3 class="relative group">The Grammar Rule
    <div id="the-grammar-rule-2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-grammar-rule-2" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>block → &#34;{&#34; statement* &#34;}&#34;
</code></pre><p>This says: an open brace, zero or more statements, and a close brace.</p>

<h3 class="relative group">Trace of <code>{ const x = 5; return x; }</code>
    <div id="trace-of--const-x--5-return-x-" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#trace-of--const-x--5-return-x-" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│              PARSING &#34;{ const x = 5; return x; }&#34;                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens: [{] [CONST] [x] [=] [5] [;] [RETURN] [x] [;] [}]                  │
│                                                                              │
│   block():                                                                   │
│       expect &#34;{&#34; → consume                                                  │
│       statements = []                                                        │
│                                                                              │
│       while not see &#34;}&#34;:                                                    │
│           call statement():                                                  │
│               ... parses &#34;const x = 5;&#34; ...                                 │
│               returns VarDecl { name: &#34;x&#34;, value: 5 }                       │
│           append to statements                                              │
│                                                                              │
│           call statement():                                                  │
│               ... parses &#34;return x;&#34; ...                                    │
│               returns ReturnStmt { value: Ident(&#34;x&#34;) }                      │
│           append to statements                                              │
│                                                                              │
│       expect &#34;}&#34; → consume                                                  │
│       return Block { statements: [VarDecl, ReturnStmt] }                    │
│                                                                              │
│   Tree:                                                                      │
│           Block                                                              │
│          /     \                                                             │
│     VarDecl   ReturnStmt                                                    │
│     /    \         |                                                         │
│   &#34;x&#34;     5    Ident(&#34;x&#34;)                                                   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Adding Functions
    <div id="adding-functions" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#adding-functions" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Now let&rsquo;s add function declarations.</p>

<h3 class="relative group">The Grammar Rules
    <div id="the-grammar-rules" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-grammar-rules" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>function → &#34;fn&#34; IDENTIFIER &#34;(&#34; parameters? &#34;)&#34; block
parameters → parameter (&#34;,&#34; parameter)*
parameter → IDENTIFIER &#34;:&#34; type
type → &#34;i32&#34; | &#34;bool&#34; | &#34;void&#34;
</code></pre><p>Let&rsquo;s break these down:</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                       FUNCTION GRAMMAR RULES                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   function → &#34;fn&#34; IDENTIFIER &#34;(&#34; parameters? &#34;)&#34; block                      │
│                                                                              │
│   This says: a function is:                                                 │
│     1. The keyword &#34;fn&#34;                                                     │
│     2. An identifier (the function name)                                    │
│     3. Open paren                                                           │
│     4. OPTIONAL parameters (that&#39;s what ? means)                            │
│     5. Close paren                                                          │
│     6. A block                                                              │
│                                                                              │
│   ────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   parameters → parameter (&#34;,&#34; parameter)*                                   │
│                                                                              │
│   This says: parameters are:                                                │
│     1. One parameter                                                        │
│     2. Followed by zero or more (comma, parameter) pairs                   │
│                                                                              │
│   Examples:                                                                  │
│     &#34;a: i32&#34;           → one parameter                                      │
│     &#34;a: i32, b: i32&#34;   → two parameters                                    │
│     &#34;&#34;                 → no parameters (handled by the ? in function)       │
│                                                                              │
│   ────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   parameter → IDENTIFIER &#34;:&#34; type                                           │
│                                                                              │
│   This says: a parameter is an identifier, a colon, and a type.            │
│                                                                              │
│   Example: &#34;a: i32&#34;                                                         │
│     IDENTIFIER = &#34;a&#34;                                                        │
│     &#34;:&#34;                                                                      │
│     type = &#34;i32&#34;                                                            │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">The <code>?</code> Operator
    <div id="the--operator-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the--operator-1" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The <code>?</code> means &ldquo;optional&rdquo; - zero or one occurrence:</p>
<pre tabindex="0"><code>parameters?

Matches:
  &#34;&#34;           (nothing - zero occurrences)   ✓
  &#34;a: i32&#34;     (one occurrence)               ✓
</code></pre>
<h3 class="relative group">Trace of <code>fn add(a: i32, b: i32) { return a + b; }</code>
    <div id="trace-of-fn-adda-i32-b-i32--return-a--b-" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#trace-of-fn-adda-i32-b-i32--return-a--b-" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│        PARSING &#34;fn add(a: i32, b: i32) { return a + b; }&#34;                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Tokens: [FN] [add] [(] [a] [:] [i32] [,] [b] [:] [i32] [)]                │
│           [{] [RETURN] [a] [+] [b] [;] [}]                                  │
│                                                                              │
│   function():                                                                │
│       expect &#34;fn&#34; → consume                                                 │
│       expect IDENTIFIER → consume, name = &#34;add&#34;                             │
│       expect &#34;(&#34; → consume                                                  │
│                                                                              │
│       see &#34;)&#34;? No, so parse parameters                                      │
│       call parameters():                                                     │
│           call parameter():                                                  │
│               expect IDENTIFIER → consume, name = &#34;a&#34;                       │
│               expect &#34;:&#34; → consume                                          │
│               expect type → consume, type = &#34;i32&#34;                           │
│               return Parameter { name: &#34;a&#34;, type: &#34;i32&#34; }                   │
│                                                                              │
│           see &#34;,&#34;? Yes → consume                                            │
│                                                                              │
│           call parameter():                                                  │
│               expect IDENTIFIER → consume, name = &#34;b&#34;                       │
│               expect &#34;:&#34; → consume                                          │
│               expect type → consume, type = &#34;i32&#34;                           │
│               return Parameter { name: &#34;b&#34;, type: &#34;i32&#34; }                   │
│                                                                              │
│           see &#34;,&#34;? No                                                       │
│           return [Param(&#34;a&#34;), Param(&#34;b&#34;)]                                   │
│                                                                              │
│       params = [Param(&#34;a&#34;), Param(&#34;b&#34;)]                                     │
│       expect &#34;)&#34; → consume                                                  │
│                                                                              │
│       call block():                                                          │
│           expect &#34;{&#34; → consume                                              │
│           call statement():                                                  │
│               call return_stmt():                                            │
│                   expect &#34;return&#34; → consume                                 │
│                   call expression():                                         │
│                       ... parses &#34;a + b&#34; ...                                │
│                       returns Add(Ident(&#34;a&#34;), Ident(&#34;b&#34;))                   │
│                   expect &#34;;&#34; → consume                                      │
│                   return ReturnStmt { value: Add(...) }                     │
│           expect &#34;}&#34; → consume                                              │
│           return Block { statements: [ReturnStmt] }                         │
│                                                                              │
│       return FnDecl {                                                        │
│           name: &#34;add&#34;,                                                       │
│           params: [Param(&#34;a&#34;, i32), Param(&#34;b&#34;, i32)],                       │
│           body: Block { ... }                                               │
│       }                                                                      │
│                                                                              │
│   Tree:                                                                      │
│                    FnDecl(&#34;add&#34;)                                             │
│                   /      |       \                                           │
│           Param(&#34;a&#34;)  Param(&#34;b&#34;)  Block                                     │
│              |           |           |                                       │
│            i32         i32      ReturnStmt                                  │
│                                      |                                       │
│                                     Add                                      │
│                                    /   \                                     │
│                               Ident   Ident                                  │
│                                 |       |                                    │
│                                &#34;a&#34;     &#34;b&#34;                                   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">The Complete Grammar
    <div id="the-complete-grammar" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-complete-grammar" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Here&rsquo;s our full grammar with 11 rules:</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                         THE COMPLETE GRAMMAR                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   PROGRAM                                                                    │
│   ───────                                                                    │
│   program     → function*                                                   │
│                                                                              │
│   FUNCTIONS                                                                  │
│   ─────────                                                                  │
│   function    → &#34;fn&#34; IDENTIFIER &#34;(&#34; parameters? &#34;)&#34; block                   │
│   parameters  → parameter (&#34;,&#34; parameter)*                                  │
│   parameter   → IDENTIFIER &#34;:&#34; type                                         │
│   type        → &#34;i32&#34; | &#34;bool&#34; | &#34;void&#34;                                     │
│                                                                              │
│   STATEMENTS                                                                 │
│   ──────────                                                                 │
│   block       → &#34;{&#34; statement* &#34;}&#34;                                          │
│   statement   → var_decl | return_stmt                                      │
│   var_decl    → &#34;const&#34; IDENTIFIER &#34;=&#34; expression &#34;;&#34;                       │
│   return_stmt → &#34;return&#34; expression &#34;;&#34;                                     │
│                                                                              │
│   EXPRESSIONS                                                                │
│   ───────────                                                                │
│   expression  → term ((&#34;+&#34; | &#34;-&#34;) term)*                                    │
│   term        → unary ((&#34;*&#34; | &#34;/&#34;) unary)*                                  │
│   unary       → &#34;-&#34; unary | primary                                         │
│   primary     → NUMBER | IDENTIFIER | &#34;(&#34; expression &#34;)&#34;                    │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Total: 11 rules                                                            │
│                                                                              │
│   This grammar can parse programs like:                                     │
│                                                                              │
│       fn main() {                                                           │
│           const x = 1 + 2;                                                  │
│           return x;                                                         │
│       }                                                                      │
│                                                                              │
│       fn add(a: i32, b: i32) {                                              │
│           return a + b;                                                     │
│       }                                                                      │
│                                                                              │
│       fn complex() {                                                        │
│           const result = (1 + 2) * -3;                                      │
│           return result;                                                    │
│       }                                                                      │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Structure Diagram
    <div id="structure-diagram" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#structure-diagram" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                        GRAMMAR STRUCTURE                                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   program                                                                    │
│       │                                                                      │
│       └──► function*                                                        │
│               │                                                              │
│               ├──► parameters                                               │
│               │       │                                                      │
│               │       └──► parameter*                                       │
│               │               │                                              │
│               │               └──► type                                     │
│               │                                                              │
│               └──► block                                                    │
│                       │                                                      │
│                       └──► statement*                                       │
│                               │                                              │
│                               ├──► var_decl ──► expression                  │
│                               │                                              │
│                               └──► return_stmt ──► expression               │
│                                                       │                      │
│                                                       └──► term*            │
│                                                              │              │
│                                                              └──► unary*    │
│                                                                     │       │
│                                                                     └──► primary
│                                                                            │
│                                                              ┌─────────────┘
│                                                              │              │
│                                                              └──► expression│
│                                                              (recursion!)   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Grammar Notation Reference
    <div id="grammar-notation-reference" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#grammar-notation-reference" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Here&rsquo;s a quick reference for all the symbols we&rsquo;ve used:</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                      GRAMMAR NOTATION REFERENCE                              │
├────────────┬─────────────────────────────────────────────────────────────────┤
│  Symbol    │  Meaning                                                        │
├────────────┼─────────────────────────────────────────────────────────────────┤
│  →         │  &#34;is defined as&#34; / &#34;is made of&#34;                                │
│            │  Example: expression → term                                    │
│            │  (an expression is made of a term)                             │
├────────────┼─────────────────────────────────────────────────────────────────┤
│  |         │  &#34;or&#34; (alternatives)                                           │
│            │  Example: primary → NUMBER | IDENTIFIER                        │
│            │  (a primary is either a number or an identifier)               │
├────────────┼─────────────────────────────────────────────────────────────────┤
│  *         │  &#34;zero or more&#34; (repetition)                                   │
│            │  Example: statement*                                           │
│            │  (zero or more statements)                                     │
├────────────┼─────────────────────────────────────────────────────────────────┤
│  +         │  &#34;one or more&#34; (at least one)                                  │
│            │  Example: digit+                                               │
│            │  (one or more digits)                                          │
├────────────┼─────────────────────────────────────────────────────────────────┤
│  ?         │  &#34;optional&#34; (zero or one)                                      │
│            │  Example: parameters?                                          │
│            │  (parameters are optional)                                     │
├────────────┼─────────────────────────────────────────────────────────────────┤
│  ( )       │  Grouping                                                      │
│            │  Example: (&#34;+&#34; term)*                                          │
│            │  (the whole &#34;+&#34; term pattern repeats)                          │
├────────────┼─────────────────────────────────────────────────────────────────┤
│  &#34; &#34;       │  Literal text (exact match)                                    │
│            │  Example: &#34;fn&#34;                                                 │
│            │  (the literal characters f and n)                              │
├────────────┼─────────────────────────────────────────────────────────────────┤
│  CAPS      │  Token from lexer                                              │
│            │  Example: NUMBER, IDENTIFIER                                   │
│            │  (tokens produced by the lexer)                                │
├────────────┼─────────────────────────────────────────────────────────────────┤
│  lowercase │  Another grammar rule                                          │
│            │  Example: expression, term, primary                            │
│            │  (references to other rules - calls another parse function)   │
└────────────┴─────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Examples of Each
    <div id="examples-of-each" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#examples-of-each" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                           NOTATION EXAMPLES                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   statement*                                                                 │
│   ──────────                                                                 │
│   Matches: &#34;&#34;                  (zero statements)                            │
│            &#34;return 1;&#34;         (one statement)                              │
│            &#34;const x = 1; return x;&#34;  (two statements)                       │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   parameters?                                                                │
│   ───────────                                                                │
│   Matches: &#34;&#34;                  (no parameters)                              │
│            &#34;a: i32&#34;            (has parameters)                             │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   NUMBER | IDENTIFIER                                                        │
│   ───────────────────                                                        │
│   Matches: &#34;42&#34;                (NUMBER)                                     │
│            &#34;foo&#34;               (IDENTIFIER)                                 │
│   NOT:     &#34;+&#34;                 (neither)                                    │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   (&#34;,&#34; parameter)*                                                          │
│   ────────────────                                                           │
│   Matches: &#34;&#34;                  (zero extra params)                          │
│            &#34;, b: i32&#34;          (one extra param)                            │
│            &#34;, b: i32, c: i32&#34;  (two extra params)                           │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   term ((&#34;+&#34; | &#34;-&#34;) term)*                                                  │
│   ────────────────────────                                                   │
│   Matches: &#34;1&#34;                 (just a term)                                │
│            &#34;1 + 2&#34;             (term, plus, term)                           │
│            &#34;1 - 2 + 3&#34;         (term, minus, term, plus, term)              │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">From Grammar to Code
    <div id="from-grammar-to-code" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#from-grammar-to-code" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Each grammar rule becomes one parse function. Here&rsquo;s the pattern:</p>

<h3 class="relative group">The Template
    <div id="the-template" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-template" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                     GRAMMAR RULE → PARSE FUNCTION                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Grammar notation          Code pattern                                    │
│   ────────────────          ────────────                                    │
│                                                                              │
│   &#34;keyword&#34;                 expect(KEYWORD) or consume(KEYWORD)             │
│                                                                              │
│   TOKEN                     consume(TOKEN) and use its value                │
│                                                                              │
│   rule                      call parseRule()                                │
│                                                                              │
│   A | B                     if see(A): parseA() else: parseB()              │
│                                                                              │
│   A*                        while see(A): parseA()                          │
│                                                                              │
│   A?                        if see(A): parseA()                             │
│                                                                              │
│   (A B)*                    while see(A): parseA(); parseB()                │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Example: expression → term ((&quot;+&quot; | &ldquo;-&rdquo;) term)*
    <div id="example-expression--term-----term" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-expression--term-----term" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>fn parseExpression():
    left = parseTerm()                    // term

    while see(PLUS) or see(MINUS):        // ((&#34;+&#34; | &#34;-&#34;) term)*
        op = consume()                    // consume &#34;+&#34; or &#34;-&#34;
        right = parseTerm()               // term
        left = BinaryNode(left, op, right)

    return left
</code></pre>
<h3 class="relative group">Example: unary → &ldquo;-&rdquo; unary | primary
    <div id="example-unary----unary--primary" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-unary----unary--primary" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>fn parseUnary():
    if see(MINUS):                        // &#34;-&#34; unary
        consume(MINUS)
        operand = parseUnary()            // recursive call
        return UnaryNode(MINUS, operand)
    else:                                 // | primary
        return parsePrimary()
</code></pre>
<h3 class="relative group">Example: block → &ldquo;{&rdquo; statement* &ldquo;}&rdquo;
    <div id="example-block---statement-" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-block---statement-" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>fn parseBlock():
    expect(LBRACE)                        // &#34;{&#34;

    statements = []
    while not see(RBRACE):                // statement*
        stmt = parseStatement()
        statements.append(stmt)

    expect(RBRACE)                        // &#34;}&#34;
    return BlockNode(statements)
</code></pre>
<h3 class="relative group">Example: function → &ldquo;fn&rdquo; IDENTIFIER &ldquo;(&rdquo; parameters? &ldquo;)&rdquo; block
    <div id="example-function--fn-identifier--parameters--block" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-function--fn-identifier--parameters--block" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>fn parseFunction():
    expect(FN)                            // &#34;fn&#34;
    name = consume(IDENTIFIER)            // IDENTIFIER
    expect(LPAREN)                        // &#34;(&#34;

    if not see(RPAREN):                   // parameters?
        params = parseParameters()
    else:
        params = []

    expect(RPAREN)                        // &#34;)&#34;
    body = parseBlock()                   // block

    return FunctionNode(name, params, body)
</code></pre>
<h3 class="relative group">The Complete Mapping
    <div id="the-complete-mapping" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-complete-mapping" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                  GRAMMAR RULES → PARSE FUNCTIONS                             │
├────────────────────────────────┬─────────────────────────────────────────────┤
│  Grammar Rule                  │  Parse Function                             │
├────────────────────────────────┼─────────────────────────────────────────────┤
│  program → function*           │  parseProgram()                             │
│  function → &#34;fn&#34; NAME ...      │  parseFunction()                            │
│  parameters → param (, param)* │  parseParameters()                          │
│  parameter → NAME &#34;:&#34; type     │  parseParameter()                           │
│  type → &#34;i32&#34; | &#34;bool&#34; | ...   │  parseType()                                │
│  block → &#34;{&#34; statement* &#34;}&#34;    │  parseBlock()                               │
│  statement → var | return      │  parseStatement()                           │
│  var_decl → &#34;const&#34; NAME ...   │  parseVarDecl()                             │
│  return_stmt → &#34;return&#34; ...    │  parseReturnStmt()                          │
│  expression → term ((+|-) ..)* │  parseExpression()                          │
│  term → unary ((*|/) unary)*   │  parseTerm()                                │
│  unary → &#34;-&#34; unary | primary   │  parseUnary()                               │
│  primary → NUM | ID | (expr)   │  parsePrimary()                             │
└────────────────────────────────┴─────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">The Key Insight
    <div id="the-key-insight" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-key-insight" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Let&rsquo;s summarize the most important things we&rsquo;ve learned:</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                          THE KEY INSIGHTS                                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   1. GRAMMAR STRUCTURE = AST STRUCTURE                                      │
│   ─────────────────────────────────────                                      │
│   The nesting in your grammar rules becomes the nesting in your tree.       │
│   If rule A calls rule B, then A nodes contain B nodes as children.         │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   2. NESTING DEPTH = PRECEDENCE                                             │
│   ─────────────────────────────                                              │
│   Rules that are called first (deepest in the call chain) have the          │
│   highest precedence. They&#39;re evaluated first because they&#39;re innermost.    │
│                                                                              │
│   expression → term → unary → primary                                       │
│   LOW prec    ───────────────►    HIGH prec                                 │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   3. CALL STACK = TREE STRUCTURE                                            │
│   ──────────────────────────────                                             │
│   As parse functions call each other, the call stack naturally forms        │
│   the tree structure. When functions return, they return tree nodes         │
│   to their parent callers.                                                   │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   4. EACH RULE = ONE FUNCTION                                               │
│   ───────────────────────────                                                │
│   There&#39;s a direct 1:1 mapping from grammar rules to parse functions.       │
│   Write the grammar first, then translating to code is mechanical.          │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   5. LOOPS FOR *, CONDITIONALS FOR |                                        │
│   ────────────────────────────────────                                       │
│   The * becomes a while loop. The | becomes an if-else chain.               │
│   The ? becomes a simple if check.                                          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Extending the Grammar
    <div id="extending-the-grammar" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#extending-the-grammar" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Once you understand the pattern, adding new features is straightforward.</p>

<h3 class="relative group">Adding If Statements
    <div id="adding-if-statements" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#adding-if-statements" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>statement → var_decl
          | return_stmt
          | if_stmt            ← NEW

if_stmt → &#34;if&#34; expression block (&#34;else&#34; block)?
</code></pre><p>Parse function:</p>
<pre tabindex="0"><code>fn parseIfStmt():
    expect(IF)
    condition = parseExpression()
    then_block = parseBlock()

    if see(ELSE):
        consume(ELSE)
        else_block = parseBlock()
    else:
        else_block = null

    return IfNode(condition, then_block, else_block)
</code></pre>
<h3 class="relative group">Adding While Loops
    <div id="adding-while-loops" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#adding-while-loops" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>statement → var_decl
          | return_stmt
          | if_stmt
          | while_stmt         ← NEW

while_stmt → &#34;while&#34; expression block
</code></pre><p>Parse function:</p>
<pre tabindex="0"><code>fn parseWhileStmt():
    expect(WHILE)
    condition = parseExpression()
    body = parseBlock()
    return WhileNode(condition, body)
</code></pre>
<h3 class="relative group">Adding More Operators
    <div id="adding-more-operators" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#adding-more-operators" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>To add comparison operators (<code>&lt;</code>, <code>&gt;</code>, <code>==</code>):</p>
<pre tabindex="0"><code>expression → comparison                                    ← CHANGE
comparison → term ((&#34;&lt;&#34; | &#34;&gt;&#34; | &#34;==&#34; | &#34;!=&#34;) term)*       ← NEW
term       → unary ((&#34;*&#34; | &#34;/&#34;) unary)*
unary      → &#34;-&#34; unary | primary
primary    → NUMBER | IDENTIFIER | &#34;(&#34; expression &#34;)&#34;
</code></pre><p>Now comparison has LOWER precedence than <code>+</code> and <code>-</code>.</p>
<p>Wait, that&rsquo;s wrong! Let&rsquo;s fix the precedence:</p>
<pre tabindex="0"><code>expression  → comparison                                    ← LOWEST
comparison  → additive ((&#34;&lt;&#34; | &#34;&gt;&#34; | &#34;==&#34;) additive)*      ← LOW
additive    → term ((&#34;+&#34; | &#34;-&#34;) term)*                     ← MEDIUM
term        → unary ((&#34;*&#34; | &#34;/&#34;) unary)*                   ← HIGH
unary       → &#34;-&#34; unary | primary                          ← HIGHER
primary     → NUMBER | IDENTIFIER | &#34;(&#34; expression &#34;)&#34;     ← HIGHEST
</code></pre><p>The pattern: <strong>insert new rules between existing ones</strong> based on where you want the precedence.</p>

<h3 class="relative group">Adding Function Calls
    <div id="adding-function-calls" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#adding-function-calls" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>primary → NUMBER
        | IDENTIFIER
        | IDENTIFIER &#34;(&#34; arguments? &#34;)&#34;    ← NEW: function call
        | &#34;(&#34; expression &#34;)&#34;

arguments → expression (&#34;,&#34; expression)*
</code></pre><p>But wait - both &ldquo;IDENTIFIER&rdquo; and &ldquo;IDENTIFIER (&rdquo; start with IDENTIFIER! We need to look ahead:</p>
<pre tabindex="0"><code>fn parsePrimary():
    if see(NUMBER):
        return parseNumber()

    if see(IDENTIFIER):
        if peekNext() == LPAREN:           // Look ahead!
            return parseCall()
        else:
            return parseIdentifier()

    if see(LPAREN):
        return parseGrouped()

    error(&#34;Expected primary expression&#34;)
</code></pre><hr>

<h2 class="relative group">The Grammar Design Process
    <div id="the-grammar-design-process" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-grammar-design-process" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Here&rsquo;s how to design a grammar for any language:</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    THE GRAMMAR DESIGN PROCESS                                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   STEP 1: Write example programs                                            │
│   ──────────────────────────────                                             │
│   What should your language look like? Write examples:                      │
│                                                                              │
│       1 + 2                                                                 │
│       const x = 5;                                                          │
│       fn add(a, b) { return a + b; }                                        │
│                                                                              │
│   STEP 2: Identify categories                                               │
│   ──────────────────────────                                                 │
│   What kinds of things exist?                                               │
│                                                                              │
│       - Expressions (produce values)                                        │
│       - Statements (do things)                                              │
│       - Declarations (define things)                                        │
│                                                                              │
│   STEP 3: List operators by precedence                                      │
│   ────────────────────────────────────                                       │
│   From lowest to highest:                                                   │
│                                                                              │
│       1. || (or)                                                            │
│       2. &amp;&amp; (and)                                                           │
│       3. == != &lt; &gt; (comparison)                                             │
│       4. + - (additive)                                                     │
│       5. * / (multiplicative)                                               │
│       6. - ! (unary prefix)                                                 │
│       7. () . [] (postfix)                                                  │
│                                                                              │
│   STEP 4: Write rules from bottom up                                        │
│   ──────────────────────────────────                                         │
│   Start with the HIGHEST precedence (primary),                              │
│   then work your way up to the LOWEST (expression).                         │
│                                                                              │
│   STEP 5: Add statements and declarations                                   │
│   ────────────────────────────────────────                                   │
│   Statements contain expressions.                                           │
│   Declarations contain statements (in blocks).                              │
│   Program contains declarations.                                            │
│                                                                              │
│   STEP 6: Translate to parse functions                                      │
│   ────────────────────────────────────                                       │
│   One rule = one function.                                                  │
│   Follow the mechanical translation.                                        │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Common Patterns
    <div id="common-patterns" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#common-patterns" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Here are patterns you&rsquo;ll use over and over:</p>

<h3 class="relative group">Binary Operators (Left-Associative)
    <div id="binary-operators-left-associative" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#binary-operators-left-associative" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>rule → next_level ((OP1 | OP2) next_level)*
</code></pre><pre tabindex="0"><code>fn parseRule():
    left = parseNextLevel()
    while see(OP1) or see(OP2):
        op = consume()
        right = parseNextLevel()
        left = BinaryNode(left, op, right)
    return left
</code></pre>
<h3 class="relative group">Unary Operators (Prefix)
    <div id="unary-operators-prefix" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#unary-operators-prefix" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>rule → OP rule | next_level
</code></pre><pre tabindex="0"><code>fn parseRule():
    if see(OP):
        consume()
        operand = parseRule()    // recursive
        return UnaryNode(OP, operand)
    return parseNextLevel()
</code></pre>
<h3 class="relative group">Optional Parts
    <div id="optional-parts" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#optional-parts" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>rule → A B?
</code></pre><pre tabindex="0"><code>fn parseRule():
    a = parseA()
    b = null
    if see(B_START):
        b = parseB()
    return Node(a, b)
</code></pre>
<h3 class="relative group">Lists with Separators
    <div id="lists-with-separators" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#lists-with-separators" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>list → item (&#34;,&#34; item)*
</code></pre><pre tabindex="0"><code>fn parseList():
    items = [parseItem()]
    while see(COMMA):
        consume(COMMA)
        items.append(parseItem())
    return items
</code></pre>
<h3 class="relative group">Blocks of Things
    <div id="blocks-of-things" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#blocks-of-things" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>block → &#34;{&#34; item* &#34;}&#34;
</code></pre><pre tabindex="0"><code>fn parseBlock():
    expect(LBRACE)
    items = []
    while not see(RBRACE):
        items.append(parseItem())
    expect(RBRACE)
    return items
</code></pre><hr>

<h2 class="relative group">Complex Example: Parsing a Complete Program
    <div id="complex-example-parsing-a-complete-program" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#complex-example-parsing-a-complete-program" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Let&rsquo;s trace through parsing a complete, non-trivial program:</p>
<pre tabindex="0"><code>fn factorial(n: i32) {
    const result = n * (n - 1);
    return result;
}

fn main() {
    const x = factorial(5);
    return x;
}
</code></pre>
<h3 class="relative group">The Token Stream
    <div id="the-token-stream" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-token-stream" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>First, the lexer produces this token stream:</p>
<pre tabindex="0"><code>[FN] [factorial] [LPAREN] [n] [COLON] [i32] [RPAREN] [LBRACE]
[CONST] [result] [EQUAL] [n] [STAR] [LPAREN] [n] [MINUS] [1] [RPAREN] [SEMICOLON]
[RETURN] [result] [SEMICOLON]
[RBRACE]
[FN] [main] [LPAREN] [RPAREN] [LBRACE]
[CONST] [x] [EQUAL] [factorial] [LPAREN] [5] [RPAREN] [SEMICOLON]
[RETURN] [x] [SEMICOLON]
[RBRACE]
[EOF]
</code></pre>
<h3 class="relative group">Full Parse Trace
    <div id="full-parse-trace" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#full-parse-trace" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                    PARSING COMPLETE PROGRAM                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   program():                                                                 │
│       functions = []                                                         │
│                                                                              │
│       ┌─ FIRST FUNCTION ─────────────────────────────────────────────────┐  │
│       │                                                                   │  │
│       │   function():                                                     │  │
│       │       expect FN → ✓                                              │  │
│       │       name = &#34;factorial&#34;                                         │  │
│       │       expect LPAREN → ✓                                          │  │
│       │                                                                   │  │
│       │       parameters():                                               │  │
│       │           parameter():                                            │  │
│       │               name = &#34;n&#34;                                         │  │
│       │               expect COLON → ✓                                   │  │
│       │               type = &#34;i32&#34;                                       │  │
│       │               return Parameter(&#34;n&#34;, i32)                         │  │
│       │           see COMMA? No                                          │  │
│       │           return [Parameter(&#34;n&#34;, i32)]                           │  │
│       │                                                                   │  │
│       │       expect RPAREN → ✓                                          │  │
│       │                                                                   │  │
│       │       block():                                                    │  │
│       │           expect LBRACE → ✓                                      │  │
│       │           statements = []                                        │  │
│       │                                                                   │  │
│       │           ┌─ FIRST STATEMENT ─────────────────────────────────┐  │  │
│       │           │                                                    │  │  │
│       │           │   statement():                                     │  │  │
│       │           │       see CONST? Yes                               │  │  │
│       │           │       var_decl():                                  │  │  │
│       │           │           expect CONST → ✓                        │  │  │
│       │           │           name = &#34;result&#34;                         │  │  │
│       │           │           expect EQUAL → ✓                        │  │  │
│       │           │                                                    │  │  │
│       │           │           expression():                            │  │  │
│       │           │               term():                              │  │  │
│       │           │                   unary():                         │  │  │
│       │           │                       primary():                   │  │  │
│       │           │                           see IDENT &#34;n&#34;           │  │  │
│       │           │                           return Ident(&#34;n&#34;)       │  │  │
│       │           │                   left = Ident(&#34;n&#34;)               │  │  │
│       │           │                   see STAR? Yes!                  │  │  │
│       │           │                   consume STAR                    │  │  │
│       │           │                   unary():                         │  │  │
│       │           │                       primary():                   │  │  │
│       │           │                           see LPAREN              │  │  │
│       │           │                           consume LPAREN          │  │  │
│       │           │                           ┌────────────────────┐  │  │  │
│       │           │                           │ NESTED expression: │  │  │  │
│       │           │                           │   term():          │  │  │  │
│       │           │                           │     Ident(&#34;n&#34;)     │  │  │  │
│       │           │                           │   see MINUS? Yes   │  │  │  │
│       │           │                           │   term():          │  │  │  │
│       │           │                           │     Number(1)      │  │  │  │
│       │           │                           │   return Sub(n, 1) │  │  │  │
│       │           │                           └────────────────────┘  │  │  │
│       │           │                           expect RPAREN → ✓       │  │  │
│       │           │                           return Sub(n, 1)       │  │  │
│       │           │                   right = Sub(n, 1)              │  │  │
│       │           │                   left = Mul(Ident(&#34;n&#34;), Sub(n,1))│ │  │
│       │           │                   see STAR? No                   │  │  │
│       │           │                   return Mul(...)                │  │  │
│       │           │               see PLUS/MINUS? No                  │  │  │
│       │           │               return Mul(Ident(&#34;n&#34;), Sub(n, 1))   │  │  │
│       │           │                                                    │  │  │
│       │           │           expect SEMICOLON → ✓                    │  │  │
│       │           │           return VarDecl(&#34;result&#34;, Mul(...))      │  │  │
│       │           │                                                    │  │  │
│       │           └────────────────────────────────────────────────────┘  │  │
│       │                                                                   │  │
│       │           ┌─ SECOND STATEMENT ────────────────────────────────┐  │  │
│       │           │                                                    │  │  │
│       │           │   statement():                                     │  │  │
│       │           │       see RETURN? Yes                              │  │  │
│       │           │       return_stmt():                               │  │  │
│       │           │           expect RETURN → ✓                       │  │  │
│       │           │           expression():                            │  │  │
│       │           │               ... returns Ident(&#34;result&#34;)         │  │  │
│       │           │           expect SEMICOLON → ✓                    │  │  │
│       │           │           return ReturnStmt(Ident(&#34;result&#34;))      │  │  │
│       │           │                                                    │  │  │
│       │           └────────────────────────────────────────────────────┘  │  │
│       │                                                                   │  │
│       │           see RBRACE? Yes                                        │  │
│       │           expect RBRACE → ✓                                      │  │
│       │           return Block([VarDecl, ReturnStmt])                    │  │
│       │                                                                   │  │
│       │       return FnDecl(&#34;factorial&#34;, [Param], Block)                 │  │
│       │                                                                   │  │
│       └───────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│       append FnDecl(&#34;factorial&#34;, ...) to functions                          │
│                                                                              │
│       ┌─ SECOND FUNCTION (main) ─────────────────────────────────────────┐  │
│       │                                                                   │  │
│       │   function():                                                     │  │
│       │       expect FN → ✓                                              │  │
│       │       name = &#34;main&#34;                                              │  │
│       │       expect LPAREN → ✓                                          │  │
│       │       see RPAREN? Yes (no parameters)                            │  │
│       │       expect RPAREN → ✓                                          │  │
│       │                                                                   │  │
│       │       block():                                                    │  │
│       │           expect LBRACE → ✓                                      │  │
│       │                                                                   │  │
│       │           statement(): var_decl                                   │  │
│       │               name = &#34;x&#34;                                         │  │
│       │               expression():                                       │  │
│       │                   primary():                                      │  │
│       │                       see IDENT &#34;factorial&#34;                      │  │
│       │                       peekNext() == LPAREN? Yes!                 │  │
│       │                       parseCall():                                │  │
│       │                           name = &#34;factorial&#34;                     │  │
│       │                           expect LPAREN → ✓                      │  │
│       │                           arguments():                           │  │
│       │                               expression() → Number(5)           │  │
│       │                           expect RPAREN → ✓                      │  │
│       │                           return Call(&#34;factorial&#34;, [5])          │  │
│       │               return VarDecl(&#34;x&#34;, Call(&#34;factorial&#34;, [5]))        │  │
│       │                                                                   │  │
│       │           statement(): return_stmt                                │  │
│       │               return ReturnStmt(Ident(&#34;x&#34;))                      │  │
│       │                                                                   │  │
│       │           return Block([VarDecl, ReturnStmt])                    │  │
│       │                                                                   │  │
│       │       return FnDecl(&#34;main&#34;, [], Block)                           │  │
│       │                                                                   │  │
│       └───────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│       append FnDecl(&#34;main&#34;, ...) to functions                               │
│                                                                              │
│       see EOF? Yes                                                           │
│       return Program([FnDecl(&#34;factorial&#34;), FnDecl(&#34;main&#34;)])                 │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">The Final AST
    <div id="the-final-ast" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-final-ast" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                         FINAL AST STRUCTURE                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Program                                                                    │
│   ├── FnDecl(&#34;factorial&#34;)                                                   │
│   │   ├── params: [Parameter(&#34;n&#34;, i32)]                                     │
│   │   └── body: Block                                                       │
│   │       ├── VarDecl(&#34;result&#34;)                                             │
│   │       │   └── value: Mul                                                │
│   │       │       ├── left: Ident(&#34;n&#34;)                                      │
│   │       │       └── right: Sub                                            │
│   │       │           ├── left: Ident(&#34;n&#34;)                                  │
│   │       │           └── right: Number(1)                                  │
│   │       └── ReturnStmt                                                    │
│   │           └── value: Ident(&#34;result&#34;)                                    │
│   │                                                                         │
│   └── FnDecl(&#34;main&#34;)                                                        │
│       ├── params: []                                                        │
│       └── body: Block                                                       │
│           ├── VarDecl(&#34;x&#34;)                                                  │
│           │   └── value: Call                                               │
│           │       ├── callee: &#34;factorial&#34;                                   │
│           │       └── args: [Number(5)]                                     │
│           └── ReturnStmt                                                    │
│               └── value: Ident(&#34;x&#34;)                                         │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Right-Associativity: Assignment and Exponentiation
    <div id="right-associativity-assignment-and-exponentiation" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#right-associativity-assignment-and-exponentiation" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>So far, all our operators have been <strong>left-associative</strong>:</p>
<pre tabindex="0"><code>1 - 2 - 3 = (1 - 2) - 3    Left-associative
</code></pre><p>But some operators are <strong>right-associative</strong>:</p>
<pre tabindex="0"><code>x = y = z    means    x = (y = z)    Right-associative (if = is expression)
2 ^ 3 ^ 4    means    2 ^ (3 ^ 4)    Right-associative (exponentiation)
</code></pre>
<h3 class="relative group">How to Achieve Right-Associativity
    <div id="how-to-achieve-right-associativity" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-to-achieve-right-associativity" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The trick: <strong>don&rsquo;t add 1</strong> to the precedence in recursive calls, OR use recursion instead of a loop.</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│               LEFT VS RIGHT ASSOCIATIVITY                                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   LEFT-ASSOCIATIVE (use loop OR precedence + 1):                            │
│   ──────────────────────────────────────────────                             │
│                                                                              │
│   fn parseAdditive():                                                        │
│       left = parseTerm()                                                    │
│       while see(PLUS) or see(MINUS):                                        │
│           op = consume()                                                    │
│           right = parseTerm()         ← calls SAME level                    │
│           left = BinaryNode(left, op, right)                                │
│       return left                                                            │
│                                                                              │
│   1 + 2 + 3 → ((1 + 2) + 3)                                                 │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   RIGHT-ASSOCIATIVE (use recursion):                                        │
│   ────────────────────────────────────                                       │
│                                                                              │
│   fn parseAssignment():                                                      │
│       left = parseEquality()                                                │
│       if see(EQUAL):                                                        │
│           consume()                                                         │
│           right = parseAssignment()   ← RECURSE to same function!           │
│           return AssignNode(left, right)                                    │
│       return left                                                            │
│                                                                              │
│   x = y = z → (x = (y = z))                                                 │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">Why Does Recursion Give Right-Associativity?
    <div id="why-does-recursion-give-right-associativity" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-does-recursion-give-right-associativity" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Parsing: x = y = 5

parseAssignment():
    left = parseEquality() → Ident(&#34;x&#34;)
    see &#34;=&#34;? Yes
    right = parseAssignment()           ← recursive call
        left = parseEquality() → Ident(&#34;y&#34;)
        see &#34;=&#34;? Yes
        right = parseAssignment()       ← recursive call
            left = parseEquality() → Number(5)
            see &#34;=&#34;? No
            return Number(5)
        return Assign(Ident(&#34;y&#34;), Number(5))
    return Assign(Ident(&#34;x&#34;), Assign(Ident(&#34;y&#34;), Number(5)))

Tree:
         Assign
        /      \
   Ident(&#34;x&#34;)  Assign
              /      \
         Ident(&#34;y&#34;)  Number(5)

This is: x = (y = 5)  ✓ Right-associative!
</code></pre>
<h3 class="relative group">Exponentiation Example
    <div id="exponentiation-example" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#exponentiation-example" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Grammar:
    power → unary (&#34;^&#34; power)?      ← recursive, not loop!

Parsing: 2 ^ 3 ^ 4

parsePower():
    left = parseUnary() → Number(2)
    see &#34;^&#34;? Yes
    consume &#34;^&#34;
    right = parsePower()              ← recurse!
        left = parseUnary() → Number(3)
        see &#34;^&#34;? Yes
        consume &#34;^&#34;
        right = parsePower()          ← recurse!
            left = parseUnary() → Number(4)
            see &#34;^&#34;? No
            return Number(4)
        return Power(3, 4)
    return Power(2, Power(3, 4))

Tree:
         Power
        /     \
       2      Power
             /     \
            3       4

Evaluation: 2 ^ (3 ^ 4) = 2 ^ 81 = huge number
(Not (2 ^ 3) ^ 4 = 8 ^ 4 = 4096)
</code></pre><hr>

<h2 class="relative group">Handling Errors Gracefully
    <div id="handling-errors-gracefully" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#handling-errors-gracefully" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Real parsers need to handle errors. What happens when input is invalid?</p>

<h3 class="relative group">Types of Parse Errors
    <div id="types-of-parse-errors" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#types-of-parse-errors" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                         COMMON PARSE ERRORS                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   1. UNEXPECTED TOKEN                                                        │
│   ───────────────────                                                        │
│   const x = ;                                                               │
│              ^                                                               │
│   Expected expression, got semicolon                                        │
│                                                                              │
│   2. MISSING TOKEN                                                          │
│   ────────────────                                                           │
│   const x = 5                                                               │
│               ^                                                              │
│   Expected semicolon, got EOF                                               │
│                                                                              │
│   3. UNCLOSED DELIMITER                                                     │
│   ─────────────────────                                                      │
│   fn foo() {                                                                │
│       return 5;                                                             │
│                 ^                                                            │
│   Expected }, got EOF                                                       │
│                                                                              │
│   4. INVALID EXPRESSION                                                     │
│   ─────────────────────                                                      │
│   const x = 1 + + 2;                                                        │
│                 ^                                                            │
│   Unexpected + in expression                                                │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 class="relative group">The <code>expect</code> Pattern
    <div id="the-expect-pattern" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-expect-pattern" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Use an <code>expect</code> function that reports errors:</p>
<pre tabindex="0"><code>fn expect(tokenType):
    if peek().type == tokenType:
        return consume()
    else:
        error(&#34;Expected &#34; + tokenType + &#34;, got &#34; + peek().type)
</code></pre>
<h3 class="relative group">Error Recovery: Synchronization
    <div id="error-recovery-synchronization" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#error-recovery-synchronization" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>After an error, the parser needs to &ldquo;recover&rdquo; to continue finding more errors. The common technique is <strong>synchronization</strong> - skip tokens until you find a safe point.</p>
<pre tabindex="0"><code>fn parseStatement():
    try:
        if see(CONST): return parseVarDecl()
        if see(RETURN): return parseReturnStmt()
        error(&#34;Expected statement&#34;)
    catch ParseError:
        synchronize()    // Skip to next statement
        return ErrorNode()

fn synchronize():
    // Skip tokens until we find a statement boundary
    while not isAtEnd():
        if previous().type == SEMICOLON:
            return    // Just passed a semicolon, good place to resume

        switch peek().type:
            CONST, RETURN, FN, IF, WHILE:
                return    // Found a keyword that starts a statement
            default:
                advance()    // Skip this token
</code></pre>
<h3 class="relative group">Example: Multiple Errors
    <div id="example-multiple-errors" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-multiple-errors" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>Input:
    const x = ;
    const y = 5;
    return

Parser output:
    Error at line 1: Expected expression, got semicolon
    Error at line 3: Expected expression after &#39;return&#39;
    Error at line 3: Expected semicolon, got EOF

Even though line 1 had an error, we recovered and parsed line 2
successfully, then found more errors on line 3.
</code></pre><hr>

<h2 class="relative group">Lookahead: When One Token Isn&rsquo;t Enough
    <div id="lookahead-when-one-token-isnt-enough" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#lookahead-when-one-token-isnt-enough" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Sometimes you need to look at more than just the current token.</p>

<h3 class="relative group">The Problem
    <div id="the-problem" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-problem" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>primary → IDENTIFIER
        | IDENTIFIER &#34;(&#34; arguments &#34;)&#34;    // function call
</code></pre><p>Both start with IDENTIFIER! How do we know which one?</p>

<h3 class="relative group">Solution: Peek Ahead
    <div id="solution-peek-ahead" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#solution-peek-ahead" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>fn parsePrimary():
    if see(IDENTIFIER):
        if peekNext() == LPAREN:
            return parseCall()
        else:
            return parseIdentifier()
    // ...
</code></pre>
<h3 class="relative group">When Lookahead Gets Complicated
    <div id="when-lookahead-gets-complicated" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#when-lookahead-gets-complicated" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>Some grammars need more than one token of lookahead:</p>
<pre tabindex="0"><code>// Is this a type annotation or a comparison?
x: i32           // type annotation (x has type i32)
x &lt; y            // comparison (is x less than y?)

// Both start with: IDENTIFIER followed by something
</code></pre><p>Solution: Restructure the grammar or use context:</p>
<pre tabindex="0"><code>// In a declaration context, expect type
var_decl → IDENTIFIER &#34;:&#34; type &#34;=&#34; expression &#34;;&#34;

// In an expression context, expect comparison
expression → ... ((&#34;&lt;&#34; | &#34;&gt;&#34;) ...)*
</code></pre><hr>

<h2 class="relative group">Putting It All Together: A Complete Parser
    <div id="putting-it-all-together-a-complete-parser" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#putting-it-all-together-a-complete-parser" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Here&rsquo;s the complete pseudocode for our parser:</p>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                        COMPLETE PARSER PSEUDOCODE                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   // ═══════════════════════════════════════════════════════════════════    │
│   // HELPER FUNCTIONS                                                        │
│   // ═══════════════════════════════════════════════════════════════════    │
│                                                                              │
│   fn peek():                                                                 │
│       return tokens[current]                                                │
│                                                                              │
│   fn previous():                                                             │
│       return tokens[current - 1]                                            │
│                                                                              │
│   fn isAtEnd():                                                              │
│       return peek().type == EOF                                             │
│                                                                              │
│   fn advance():                                                              │
│       if not isAtEnd(): current++                                           │
│       return previous()                                                     │
│                                                                              │
│   fn see(type):                                                              │
│       return peek().type == type                                            │
│                                                                              │
│   fn consume(type):                                                          │
│       if see(type): return advance()                                        │
│       error(&#34;Unexpected token&#34;)                                             │
│                                                                              │
│   fn expect(type):                                                           │
│       if see(type): return advance()                                        │
│       error(&#34;Expected &#34; + type)                                             │
│                                                                              │
│   // ═══════════════════════════════════════════════════════════════════    │
│   // PROGRAM &amp; FUNCTIONS                                                     │
│   // ═══════════════════════════════════════════════════════════════════    │
│                                                                              │
│   fn parseProgram():                                                         │
│       functions = []                                                        │
│       while not isAtEnd():                                                  │
│           functions.append(parseFunction())                                 │
│       return ProgramNode(functions)                                         │
│                                                                              │
│   fn parseFunction():                                                        │
│       expect(FN)                                                            │
│       name = expect(IDENTIFIER).lexeme                                      │
│       expect(LPAREN)                                                        │
│       params = []                                                           │
│       if not see(RPAREN):                                                   │
│           params = parseParameters()                                        │
│       expect(RPAREN)                                                        │
│       body = parseBlock()                                                   │
│       return FnDeclNode(name, params, body)                                 │
│                                                                              │
│   fn parseParameters():                                                      │
│       params = [parseParameter()]                                           │
│       while see(COMMA):                                                     │
│           advance()                                                         │
│           params.append(parseParameter())                                   │
│       return params                                                         │
│                                                                              │
│   fn parseParameter():                                                       │
│       name = expect(IDENTIFIER).lexeme                                      │
│       expect(COLON)                                                         │
│       type = parseType()                                                    │
│       return ParameterNode(name, type)                                      │
│                                                                              │
│   fn parseType():                                                            │
│       if see(I32): advance(); return TypeNode(&#34;i32&#34;)                        │
│       if see(BOOL): advance(); return TypeNode(&#34;bool&#34;)                      │
│       if see(VOID): advance(); return TypeNode(&#34;void&#34;)                      │
│       error(&#34;Expected type&#34;)                                                │
│                                                                              │
│   // ═══════════════════════════════════════════════════════════════════    │
│   // STATEMENTS                                                              │
│   // ═══════════════════════════════════════════════════════════════════    │
│                                                                              │
│   fn parseBlock():                                                           │
│       expect(LBRACE)                                                        │
│       statements = []                                                       │
│       while not see(RBRACE) and not isAtEnd():                              │
│           statements.append(parseStatement())                               │
│       expect(RBRACE)                                                        │
│       return BlockNode(statements)                                          │
│                                                                              │
│   fn parseStatement():                                                       │
│       if see(CONST) or see(VAR):                                            │
│           return parseVarDecl()                                             │
│       if see(RETURN):                                                       │
│           return parseReturnStmt()                                          │
│       if see(IF):                                                           │
│           return parseIfStmt()                                              │
│       if see(WHILE):                                                        │
│           return parseWhileStmt()                                           │
│       error(&#34;Expected statement&#34;)                                           │
│                                                                              │
│   fn parseVarDecl():                                                         │
│       isConst = see(CONST)                                                  │
│       advance()  // consume CONST or VAR                                    │
│       name = expect(IDENTIFIER).lexeme                                      │
│       expect(EQUAL)                                                         │
│       value = parseExpression()                                             │
│       expect(SEMICOLON)                                                     │
│       return VarDeclNode(name, value, isConst)                              │
│                                                                              │
│   fn parseReturnStmt():                                                      │
│       expect(RETURN)                                                        │
│       value = null                                                          │
│       if not see(SEMICOLON):                                                │
│           value = parseExpression()                                         │
│       expect(SEMICOLON)                                                     │
│       return ReturnNode(value)                                              │
│                                                                              │
│   fn parseIfStmt():                                                          │
│       expect(IF)                                                            │
│       condition = parseExpression()                                         │
│       thenBranch = parseBlock()                                             │
│       elseBranch = null                                                     │
│       if see(ELSE):                                                         │
│           advance()                                                         │
│           elseBranch = parseBlock()                                         │
│       return IfNode(condition, thenBranch, elseBranch)                      │
│                                                                              │
│   fn parseWhileStmt():                                                       │
│       expect(WHILE)                                                         │
│       condition = parseExpression()                                         │
│       body = parseBlock()                                                   │
│       return WhileNode(condition, body)                                     │
│                                                                              │
│   // ═══════════════════════════════════════════════════════════════════    │
│   // EXPRESSIONS                                                             │
│   // ═══════════════════════════════════════════════════════════════════    │
│                                                                              │
│   fn parseExpression():                                                      │
│       return parseEquality()                                                │
│                                                                              │
│   fn parseEquality():                                                        │
│       left = parseComparison()                                              │
│       while see(EQUAL_EQUAL) or see(BANG_EQUAL):                            │
│           op = advance()                                                    │
│           right = parseComparison()                                         │
│           left = BinaryNode(left, op, right)                                │
│       return left                                                            │
│                                                                              │
│   fn parseComparison():                                                      │
│       left = parseAdditive()                                                │
│       while see(LESS) or see(GREATER) or see(LESS_EQ) or see(GREATER_EQ):  │
│           op = advance()                                                    │
│           right = parseAdditive()                                           │
│           left = BinaryNode(left, op, right)                                │
│       return left                                                            │
│                                                                              │
│   fn parseAdditive():                                                        │
│       left = parseTerm()                                                    │
│       while see(PLUS) or see(MINUS):                                        │
│           op = advance()                                                    │
│           right = parseTerm()                                               │
│           left = BinaryNode(left, op, right)                                │
│       return left                                                            │
│                                                                              │
│   fn parseTerm():                                                            │
│       left = parseUnary()                                                   │
│       while see(STAR) or see(SLASH):                                        │
│           op = advance()                                                    │
│           right = parseUnary()                                              │
│           left = BinaryNode(left, op, right)                                │
│       return left                                                            │
│                                                                              │
│   fn parseUnary():                                                           │
│       if see(MINUS) or see(BANG):                                           │
│           op = advance()                                                    │
│           operand = parseUnary()                                            │
│           return UnaryNode(op, operand)                                     │
│       return parseCall()                                                    │
│                                                                              │
│   fn parseCall():                                                            │
│       expr = parsePrimary()                                                 │
│       if see(LPAREN):                                                       │
│           advance()                                                         │
│           args = []                                                         │
│           if not see(RPAREN):                                               │
│               args = parseArguments()                                       │
│           expect(RPAREN)                                                    │
│           return CallNode(expr, args)                                       │
│       return expr                                                            │
│                                                                              │
│   fn parseArguments():                                                       │
│       args = [parseExpression()]                                            │
│       while see(COMMA):                                                     │
│           advance()                                                         │
│           args.append(parseExpression())                                    │
│       return args                                                            │
│                                                                              │
│   fn parsePrimary():                                                         │
│       if see(NUMBER):                                                       │
│           return NumberNode(advance().value)                                │
│       if see(IDENTIFIER):                                                   │
│           return IdentNode(advance().lexeme)                                │
│       if see(TRUE):                                                         │
│           advance()                                                         │
│           return BoolNode(true)                                             │
│       if see(FALSE):                                                        │
│           advance()                                                         │
│           return BoolNode(false)                                            │
│       if see(LPAREN):                                                       │
│           advance()                                                         │
│           expr = parseExpression()                                          │
│           expect(RPAREN)                                                    │
│           return expr                                                        │
│       error(&#34;Expected expression&#34;)                                          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Common Mistakes to Avoid
    <div id="common-mistakes-to-avoid" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#common-mistakes-to-avoid" aria-label="Anchor">#</a>
    </span>
    
</h2>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                        COMMON MISTAKES                                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   1. WRONG ASSOCIATIVITY                                                    │
│   ──────────────────────                                                     │
│   Using recursion when you want left-associativity:                         │
│                                                                              │
│   // WRONG - gives right-associativity                                      │
│   fn parseAdditive():                                                        │
│       left = parseTerm()                                                    │
│       if see(PLUS):                                                         │
│           advance()                                                         │
│           right = parseAdditive()  // recursive!                            │
│           return BinaryNode(left, PLUS, right)                              │
│       return left                                                            │
│                                                                              │
│   // CORRECT - use a loop for left-associativity                            │
│   fn parseAdditive():                                                        │
│       left = parseTerm()                                                    │
│       while see(PLUS):                                                      │
│           advance()                                                         │
│           right = parseTerm()                                               │
│           left = BinaryNode(left, PLUS, right)                              │
│       return left                                                            │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   2. INFINITE LOOP                                                          │
│   ────────────────                                                           │
│   Forgetting to consume tokens in a loop:                                   │
│                                                                              │
│   // WRONG - infinite loop!                                                 │
│   while see(PLUS):                                                          │
│       right = parseTerm()  // never consumes PLUS!                          │
│                                                                              │
│   // CORRECT                                                                │
│   while see(PLUS):                                                          │
│       advance()            // consume the PLUS                              │
│       right = parseTerm()                                                   │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   3. WRONG PRECEDENCE ORDER                                                 │
│   ─────────────────────────                                                  │
│   Remember: rules called FIRST have HIGHER precedence                       │
│                                                                              │
│   // WRONG - * has lower precedence than +                                  │
│   expression → unary ((&#34;*&#34; | &#34;/&#34;) unary)*                                   │
│   term → primary ((&#34;+&#34; | &#34;-&#34;) primary)*                                     │
│                                                                              │
│   // CORRECT - * has higher precedence than +                               │
│   expression → term ((&#34;+&#34; | &#34;-&#34;) term)*                                     │
│   term → unary ((&#34;*&#34; | &#34;/&#34;) unary)*                                         │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   4. NOT HANDLING END OF INPUT                                              │
│   ────────────────────────────                                               │
│   Always check for EOF to avoid reading past the end:                       │
│                                                                              │
│   // WRONG - might read past EOF                                            │
│   while not see(RBRACE):                                                    │
│       statements.append(parseStatement())                                   │
│                                                                              │
│   // CORRECT - also check for end of input                                  │
│   while not see(RBRACE) and not isAtEnd():                                  │
│       statements.append(parseStatement())                                   │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   5. FORGETTING TO RETURN                                                   │
│   ───────────────────────                                                    │
│   Make sure all paths return a value:                                       │
│                                                                              │
│   // WRONG - might not return anything                                      │
│   fn parsePrimary():                                                         │
│       if see(NUMBER): return parseNumber()                                  │
│       if see(IDENTIFIER): return parseIdentifier()                          │
│       // what if neither? falls through without return!                     │
│                                                                              │
│   // CORRECT - handle the error case                                        │
│   fn parsePrimary():                                                         │
│       if see(NUMBER): return parseNumber()                                  │
│       if see(IDENTIFIER): return parseIdentifier()                          │
│       error(&#34;Expected expression&#34;)  // or throw/return error node          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">Summary
    <div id="summary" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#summary" aria-label="Anchor">#</a>
    </span>
    
</h2>
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                              SUMMARY                                         │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   A grammar is a set of rules describing valid programs.                    │
│                                                                              │
│   Each rule has:                                                             │
│     - A name (left side)                                                    │
│     - A definition (right side)                                             │
│                                                                              │
│   Rules can use:                                                             │
│     - Literals: &#34;fn&#34;, &#34;return&#34;                                              │
│     - Tokens: NUMBER, IDENTIFIER                                            │
│     - Other rules: expression, statement                                    │
│     - Operators: | (or), * (repeat), ? (optional)                           │
│                                                                              │
│   Precedence is handled by nesting rules:                                   │
│     - Outer rules = lower precedence                                        │
│     - Inner rules = higher precedence                                       │
│                                                                              │
│   Each rule becomes one parse function.                                     │
│                                                                              │
│   The call stack forms the tree structure.                                  │
│                                                                              │
│   Start with examples, identify patterns, write rules, translate to code.  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre><hr>

<h2 class="relative group">What&rsquo;s Next
    <div id="whats-next" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#whats-next" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Now you understand how to design a grammar. The next step is implementing it in code - creating the actual parse functions and AST nodes.</p>
<p>See the <a
  href="../compiler-tutorial/02-parser/">Parser Tutorial</a> for a complete implementation.</p>
<hr>

<h2 class="relative group">Quick Reference
    <div id="quick-reference" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#quick-reference" aria-label="Anchor">#</a>
    </span>
    
</h2>

<h3 class="relative group">Our Complete Grammar
    <div id="our-complete-grammar" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#our-complete-grammar" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>program     → function*
function    → &#34;fn&#34; IDENTIFIER &#34;(&#34; parameters? &#34;)&#34; block
parameters  → parameter (&#34;,&#34; parameter)*
parameter   → IDENTIFIER &#34;:&#34; type
type        → &#34;i32&#34; | &#34;bool&#34; | &#34;void&#34;
block       → &#34;{&#34; statement* &#34;}&#34;
statement   → var_decl | return_stmt
var_decl    → &#34;const&#34; IDENTIFIER &#34;=&#34; expression &#34;;&#34;
return_stmt → &#34;return&#34; expression &#34;;&#34;
expression  → term ((&#34;+&#34; | &#34;-&#34;) term)*
term        → unary ((&#34;*&#34; | &#34;/&#34;) unary)*
unary       → &#34;-&#34; unary | primary
primary     → NUMBER | IDENTIFIER | &#34;(&#34; expression &#34;)&#34;
</code></pre>
<h3 class="relative group">Notation Reference
    <div id="notation-reference" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#notation-reference" aria-label="Anchor">#</a>
    </span>
    
</h3>
<pre tabindex="0"><code>→     &#34;is defined as&#34;
|     &#34;or&#34;
*     &#34;zero or more&#34;
+     &#34;one or more&#34;
?     &#34;optional&#34;
( )   grouping
&#34; &#34;   literal
CAPS  token
lower other rule
</code></pre>
          
          
          
        </div>
        
        

        

        

      </div>

      
      
        
        
          
          
        
        
        
        <script
          type="text/javascript"
          src="/js/page.min.54b6f4371722649edbe871e431d8670d670878c22be8f36e229fe53cc9b786fe25a834def5e6de621f7a3e37b72bc8cd73839aa5ed907ed6cbd45cd3e1b0fa20.js"
          integrity="sha512-VLb0NxciZJ7b6HHkMdhnDWcIeMIr6PNuIp/lPMm3hv4lqDTe9ebeYh96Pje3K8jNc4Oape2QftbL1FzT4bD6IA=="
          data-oid="views_drafts/how-to-design-a-grammar.md"
          data-oid-likes="likes_drafts/how-to-design-a-grammar.md"></script>
      
    </section>

    
    <footer class="pt-8 max-w-prose print:hidden">
      
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600">
      <div class="flex justify-between pt-3">
        <span class="flex flex-col">
          
            <a
              class="flex text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
              href="/drafts/14-bytecode/">
              <span class="leading-6">
                <span class="inline-block rtl:rotate-180">&larr;</span>&ensp;Zig Compiler Internals Part 14: Understanding Bytecode
              </span>
            </a>
            
              <span class="ms-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                <time datetime="2025-12-18T00:00:00&#43;00:00">December 18, 2025</time>
              </span>
            
          
        </span>
        <span class="flex flex-col items-end">
          
            <a
              class="flex text-right text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
              href="/drafts/17-allocators/">
              <span class="leading-6">
                Part 17: Allocators Deep Dive - Inside Zig's Memory Management&ensp;<span class="inline-block rtl:rotate-180">&rarr;</span>
              </span>
            </a>
            
              <span class="me-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                <time datetime="2025-12-21T00:00:00&#43;00:00">December 21, 2025</time>
              </span>
            
          
        </span>
      </div>
    </div>
  


      
    </footer>
  </article>

        


  






<div
  id="scroll-to-top"
  class="fixed bottom-6 end-6 z-50 transform translate-y-4 opacity-0 duration-200">
  <a
    href="#the-top"
    class="pointer-events-auto flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="Scroll to top"
    title="Scroll to top">
    &uarr;
  </a>
</div>

      </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
  
  <div class="flex items-center justify-between">
    
    
      <p class="text-sm text-neutral-500 dark:text-neutral-400">
          &copy;
          2025
          Yohai
      </p>
    

    
    
      <p class="text-xs text-neutral-500 dark:text-neutral-400">
        
        
        Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
          href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
          href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a>
      </p>
    
  </div>
  
    <script>
      mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
        margin: 24,
        background: "rgba(0,0,0,0.5)",
        scrollOffset: 0,
      });
    </script>
  
  
  
  <script
    type="text/javascript"
    src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js"
    integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh] z-500"
  data-url="http://localhost:1313/">
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800">
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="Search"
          tabindex="0">
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="Close (Esc)">
        <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>
</span>
      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

    </div>
  </body>
  
</html>
